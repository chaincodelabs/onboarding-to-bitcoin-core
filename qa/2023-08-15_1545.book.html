<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Onboarding to Bitcoin Core</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>@import url('https://rsms.me/inter/inter.css');
html { font-family: 'Inter', sans-serif; }
@supports (font-variation-settings: normal) {
  html { font-family: 'Inter var', sans-serif; }
}
</style>

 <style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap');
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300&display=swap');
</style>

<style>
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
    #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
    #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
      padding-left: 0 }
    #tocbot a.toc-link{ height:100% }
    .is-collapsible{ max-height:3000px; overflow:hidden; }
    .is-collapsed{ max-height:0 }
    .is-active-link{ font-weight:700 }
  }
  @media print{
    #tocbot a.toc-link.node-name--H4{ display:none }
  }
</style>

<style>
h1, h2, h3, h4, h5, h6, body, #toctitle,
.sidebarblock > .content > .title, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
  font-family: 'Inter', sans-serif;
}
</style>

<style>
code {
    font-family: 'JetBrains Mono', monospace;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Onboarding to Bitcoin Core</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_overview_development_process">Overview &amp; Development process</a>
<ul class="sectlevel2">
<li><a href="#_contributor_journeys">Contributor journeys</a></li>
<li><a href="#_decentralized_development">Decentralized development</a></li>
<li><a href="#_developer_guidelines">Developer guidelines</a></li>
<li><a href="#_development_workflow">Development workflow</a>
<ul class="sectlevel3">
<li><a href="#_use_of_github">Use of GitHub</a></li>
<li><a href="#_reviewing_code">Reviewing code</a></li>
<li><a href="#_contributing_code">Contributing code</a></li>
<li><a href="#_codebase_archaeology">Codebase archaeology</a></li>
<li><a href="#_building_from_source">Building from source</a></li>
<li><a href="#_codebase_documentation">Codebase documentation</a></li>
<li><a href="#_testing">Testing</a></li>
<li><a href="#_getting_started_with_development">Getting started with development</a></li>
<li><a href="#_bitcoin_core_dev_irc_channel">#bitcoin-core-dev IRC channel</a></li>
<li><a href="#_communication">Communication</a></li>
<li><a href="#_backports">Backports</a></li>
</ul>
</li>
<li><a href="#_reproducible_guix_builds">Reproducible Guix builds</a></li>
<li><a href="#_software_life_cycle">Software Life-cycle</a></li>
<li><a href="#_organisation_roles">Organisation &amp; roles</a>
<ul class="sectlevel3">
<li><a href="#_contributors">Contributors</a></li>
<li><a href="#_members">Members</a></li>
<li><a href="#_maintainers">Maintainers</a></li>
<li><a href="#_organisation_fail_safes">Organisation fail-safes</a></li>
</ul>
</li>
<li><a href="#_bips">BIPs</a>
<ul class="sectlevel3">
<li><a href="#_what_does_having_a_bip_number_assigned_to_an_idea_mean">What does having a BIP number assigned to an idea mean</a></li>
</ul>
</li>
<li><a href="#_project_stats">Project stats</a></li>
<li><a href="#_exercises">Exercises</a></li>
</ul>
</li>
<li><a href="#_architecture">Architecture</a>
<ul class="sectlevel2">
<li><a href="#_general_design_principles">General design principles</a></li>
<li><a href="#_bitcoind_overview">bitcoind overview</a></li>
<li><a href="#_bitcoin_cli_overview"><code>bitcoin-cli</code> overview</a></li>
<li><a href="#_wallet_structure">Wallet structure</a></li>
<li><a href="#_tests_overview">Tests overview</a>
<ul class="sectlevel3">
<li><a href="#_test_directory_structure">Test directory structure</a></li>
<li><a href="#_test_coverage">Test coverage</a></li>
</ul>
</li>
<li><a href="#_threads">Threads</a>
<ul class="sectlevel3">
<li><a href="#_net_threads">Net threads</a></li>
<li><a href="#_thread_debugging">Thread debugging</a></li>
</ul>
</li>
<li><a href="#_library_structure">Library structure</a></li>
<li><a href="#_source_code_organization">Source code organization</a></li>
<li><a href="#_userspace_files">Userspace files</a>
<ul class="sectlevel3">
<li><a href="#_block_and_undo_files">Block and undo files</a></li>
<li><a href="#_indexes">Indexes</a></li>
</ul>
</li>
<li><a href="#_deep_technical_dive">Deep technical dive</a></li>
<li><a href="#_subtrees">Subtrees</a></li>
<li><a href="#_implementation_separation">Implementation separation</a></li>
</ul>
</li>
<li><a href="#_consensus_validation">Consensus &amp; validation</a>
<ul class="sectlevel2">
<li><a href="#_consensus_in_bitcoin_core">Consensus in Bitcoin Core</a>
<ul class="sectlevel3">
<li><a href="#_consensus_model">Consensus model</a></li>
</ul>
</li>
<li><a href="#_validation_in_bitcoin_core">Validation in Bitcoin Core</a></li>
<li><a href="#_consensus_vs_policy">Consensus vs Policy</a></li>
<li><a href="#_consensus_and_validation_bugs">Consensus and validation bugs</a>
<ul class="sectlevel3">
<li><a href="#_openssl_consensus_failure">OpenSSL consensus failure</a></li>
<li><a href="#_database_consensus">Database consensus</a></li>
<li><a href="#_an_inflation_bug">An inflation bug</a></li>
</ul>
</li>
<li><a href="#_hard_soft_forks">Hard &amp; Soft Forks</a></li>
<li><a href="#_making_forking_changes">Making forking changes</a></li>
<li><a href="#_upgrading_consensus_rules_with_soft_forks">Upgrading consensus rules with soft forks</a>
<ul class="sectlevel3">
<li><a href="#_segwit_upgrade">SegWit upgrade</a></li>
</ul>
</li>
<li><a href="#_fork_wish_lists">Fork wish lists</a></li>
<li><a href="#_bitcoin_core_consensus_specification">Bitcoin core consensus specification</a></li>
<li><a href="#_libbitcoinconsensus">libbitcoinconsensus</a></li>
<li><a href="#_libbitcoinkernel">libbitcoinkernel</a></li>
<li><a href="#_hardcoded_consensus_values">Hardcoded consensus values</a></li>
<li><a href="#_transaction_validation">Transaction validation</a>
<ul class="sectlevel3">
<li><a href="#_single_transactions">Single transactions</a></li>
<li><a href="#multiple_transactions">Multiple transactions (and packages)</a></li>
<li><a href="#_prechecks">PreChecks</a></li>
<li><a href="#_replacementchecks">ReplacementChecks</a></li>
<li><a href="#_policyscriptchecks">PolicyScriptChecks</a></li>
<li><a href="#_consensusscriptchecks">ConsensusScriptChecks</a></li>
<li><a href="#_packagemempoolchecks">PackageMempoolChecks</a></li>
<li><a href="#_finalize">Finalize</a></li>
<li><a href="#_transactions_from_blocks">Transactions from blocks</a></li>
</ul>
</li>
<li><a href="#_multiple_chains">Multiple chains</a></li>
<li><a href="#_responsible_disclosure">Responsible Disclosure</a></li>
<li><a href="#_exercises_2">Exercises</a></li>
</ul>
</li>
<li><a href="#_wallet">Wallet</a>
<ul class="sectlevel2">
<li><a href="#_wallet_overview">Wallet overview</a>
<ul class="sectlevel3">
<li><a href="#_wallet_database">Wallet Database</a></li>
<li><a href="#_key_type_classes_in_the_wallet">Key-type classes in the wallet</a></li>
<li><a href="#_encryption">Encryption</a></li>
<li><a href="#_transaction_tracking">Transaction tracking</a></li>
<li><a href="#_calculating_a_balance">Calculating a balance</a></li>
<li><a href="#_ismine">IsMine</a></li>
<li><a href="#_conflict_tracking">Conflict tracking</a></li>
<li><a href="#coin-selection-overview">Coin selection</a></li>
<li><a href="#_transaction_creation">Transaction creation</a></li>
<li><a href="#_signing">Signing</a></li>
</ul>
</li>
<li><a href="#_separation_of_wallet_and_node">Separation of wallet and node</a>
<ul class="sectlevel3">
<li><a href="#_wallet_interfaces">Wallet interfaces</a></li>
</ul>
</li>
<li><a href="#_wallet_component_initialisation">Wallet component initialisation</a></li>
<li><a href="#_wallets_and_program_initialisation">Wallets and program initialisation</a>
<ul class="sectlevel3">
<li><a href="#_specifying_wallets_loaded_at_startup">Specifying wallets loaded at startup</a></li>
<li><a href="#_verifywallets">VerifyWallets</a></li>
<li><a href="#_loadwallets">LoadWallets</a></li>
<li><a href="#_startwallets">StartWallets</a></li>
<li><a href="#_flushwallets">FlushWallets</a></li>
</ul>
</li>
<li><a href="#_wallet_locks">Wallet Locks</a>
<ul class="sectlevel3">
<li><a href="#_the_cs_wallet_lock">The <code>cs_wallet</code> lock</a></li>
<li><a href="#_other_wallet_locks">Other wallet locks</a></li>
</ul>
</li>
<li><a href="#_controlling_the_wallet">Controlling the wallet</a>
<ul class="sectlevel3">
<li><a href="#_wallet_via_rpc">Wallet via RPC</a></li>
<li><a href="#_via_bitcoin_cli_tool">Via <code>bitcoin-cli</code> tool</a></li>
</ul>
</li>
<li><a href="#_cwallet">CWallet</a>
<ul class="sectlevel3">
<li><a href="#_cwallet_creation">CWallet creation</a></li>
</ul>
</li>
<li><a href="#scriptpubkeymanagers">ScriptPubKeyManagers (SPKM)</a>
<ul class="sectlevel3">
<li><a href="#_keys_in_the_wallet">Keys in the wallet</a></li>
<li><a href="#_how_wallets_identify_relevant_transactions">How wallets identify relevant transactions</a></li>
</ul>
</li>
<li><a href="#_constructing_transactions">Constructing transactions</a>
<ul class="sectlevel3">
<li><a href="#_createtransactioninternal">CreateTransactionInternal</a></li>
<li><a href="#_availablecoins_2">AvailableCoins</a></li>
<li><a href="#_createtransactioninternal_continued">CreateTransactionInternal continued</a></li>
<li><a href="#coin-selection">Coin selection</a></li>
</ul>
</li>
<li><a href="#_multiwallet">Multiwallet</a></li>
<li><a href="#_exercises_3">Exercises</a></li>
</ul>
</li>
<li><a href="#_gui">GUI</a>
<ul class="sectlevel2">
<li><a href="#_motivation_for_a_gui">Motivation for a GUI</a></li>
<li><a href="#_building_the_gui">Building the GUI</a></li>
<li><a href="#_qt">Qt</a></li>
<li><a href="#_qt_documentation">Qt documentation</a></li>
<li><a href="#_main_gui_program">Main GUI program</a></li>
<li><a href="#_gui_initialisation">GUI initialisation</a></li>
<li><a href="#_qml_gui">QML GUI</a></li>
<li><a href="#_bitcoin_design">Bitcoin design</a></li>
<li><a href="#_testing_qt">Testing QT</a></li>
</ul>
</li>
<li><a href="#_p2p">P2P</a>
<ul class="sectlevel2">
<li><a href="#_design_philosophy">Design philosophy</a></li>
<li><a href="#_design_goals">Design goals</a></li>
<li><a href="#_p2p_attacks">P2P attacks</a>
<ul class="sectlevel3">
<li><a href="#_eclipse_attacks">Eclipse attacks</a></li>
<li><a href="#_identification_of_the_network_topology">Identification of the network topology</a></li>
</ul>
</li>
<li><a href="#_node_p2p_components">Node P2P components</a>
<ul class="sectlevel3">
<li><a href="#_netgroupmanager">NetGroupManager</a></li>
<li><a href="#_addrman">Addrman</a></li>
<li><a href="#_banman">Banman</a></li>
<li><a href="#_connman">Connman</a></li>
</ul>
</li>
<li><a href="#_bootstrapping">Bootstrapping</a></li>
<li><a href="#_service_flags">Service flags</a></li>
<li><a href="#_managing_connections">Managing connections</a></li>
<li><a href="#_message_relay">Message relay</a>
<ul class="sectlevel3">
<li><a href="#_address_relay">Address relay</a></li>
<li><a href="#_transaction_relay">Transaction relay</a></li>
<li><a href="#_block_relay">Block relay</a></li>
<li><a href="#_blocksonly_vs_block_relay_only">blocksonly vs block-relay-only</a></li>
<li><a href="#_notifying_peers_of_relay_preferences">Notifying peers of relay preferences</a></li>
</ul>
</li>
<li><a href="#_p2p_message_encryption">P2P message encryption</a>
<ul class="sectlevel3">
<li><a href="#_networking_contribution_to_node_rng_entropy">Networking contribution to node RNG entropy</a></li>
</ul>
</li>
<li><a href="#_peer_state">Peer state</a></li>
<li><a href="#_p2p_violations">P2P violations</a></li>
<li><a href="#_testing_p2p_changes">Testing P2P changes</a>
<ul class="sectlevel3">
<li><a href="#_testing_transaction_and_block_relay_under_segwit">Testing transaction and block relay under SegWit</a></li>
</ul>
</li>
<li><a href="#_exercises_4">Exercises</a></li>
</ul>
</li>
<li><a href="#_mempool">Mempool</a>
<ul class="sectlevel2">
<li><a href="#_mempool_terminology">Mempool terminology</a></li>
<li><a href="#_mempool_purpose">Mempool purpose</a></li>
<li><a href="#_mempool_policy_goals">Mempool policy goals</a></li>
<li><a href="#_mempool_life_cycle">Mempool life cycle</a>
<ul class="sectlevel3">
<li><a href="#_initialisation">Initialisation</a></li>
<li><a href="#_runtime_execution">Runtime execution</a></li>
<li><a href="#_mempool_shutdown">Mempool shutdown</a></li>
</ul>
</li>
<li><a href="#_addition_to_the_mempool">Addition to the mempool</a></li>
<li><a href="#_removal_from_the_mempool">Removal from the mempool</a></li>
<li><a href="#_mempool_unbroadcast_set">Mempool unbroadcast set</a></li>
<li><a href="#_transaction_format_in_the_mempool">Transaction format in the mempool</a></li>
<li><a href="#_mapping_transactions_in_the_mempool">Mapping transactions in the mempool</a></li>
<li><a href="#_package_relay">Package relay</a></li>
<li><a href="#_pinning_attacks">Pinning attacks</a></li>
</ul>
</li>
<li><a href="#_script">Script</a>
<ul class="sectlevel2">
<li><a href="#_script_origins">Script origins</a></li>
<li><a href="#_scripts_in_bitcoin_core">Scripts in Bitcoin Core</a></li>
<li><a href="#_validating_scripts">Validating scripts</a>
<ul class="sectlevel3">
<li><a href="#_precheck_script_checks">PreCheck script checks</a></li>
<li><a href="#_policyscriptchecks_script_checks">PolicyScriptChecks script checks</a></li>
<li><a href="#_verifyscript">VerifyScript</a></li>
<li><a href="#_evalscript">EvalScript</a></li>
</ul>
</li>
<li><a href="#_signing_a_transaction">Signing a transaction</a>
<ul class="sectlevel3">
<li><a href="#_producing_a_signature">Producing a signature</a></li>
<li><a href="#_creating_a_signature">Creating a signature</a></li>
</ul>
</li>
<li><a href="#_working_with_bitcoin_script_from_the_command_line">Working with bitcoin script from the command line</a></li>
<li><a href="#_appendix">Appendix</a>
<ul class="sectlevel3">
<li><a href="#_executing_scripts">Executing scripts</a></li>
<li><a href="#_script_inside_of_addresses">Script inside of addresses</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_build_system">Build system</a></li>
<li><a href="#_rpc_rest_zmq">RPC / REST / ZMQ</a>
<ul class="sectlevel2">
<li><a href="#_adding_new_rpcs">Adding new RPCs</a></li>
<li><a href="#_http_server">HTTP Server</a></li>
</ul>
</li>
<li><a href="#_appendix_2">Appendix</a>
<ul class="sectlevel2">
<li><a href="#pimpl-technique">PIMPL technique</a></li>
</ul>
</li>
<li><a href="#_glossary">Glossary</a>
<ul class="sectlevel2">
<li><a href="#_a">A</a></li>
<li><a href="#_b">B</a></li>
<li><a href="#_c">C</a></li>
<li><a href="#_d">D</a></li>
<li><a href="#_e">E</a></li>
<li><a href="#_f">F</a></li>
<li><a href="#_g">G</a></li>
<li><a href="#_h">H</a></li>
<li><a href="#_k">K</a></li>
<li><a href="#_l">L</a></li>
<li><a href="#_m">M</a></li>
<li><a href="#_n">N</a></li>
<li><a href="#_o">O</a></li>
<li><a href="#_p">P</a></li>
<li><a href="#_r">R</a></li>
<li><a href="#_s">S</a></li>
<li><a href="#_t">T</a></li>
<li><a href="#_u">U</a></li>
<li><a href="#_w">W</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_overview_development_process"><a class="link" href="#_overview_development_process">Overview &amp; Development process</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Whilst this disclaimer is present this documentation is considered a work in progress and may be subject to minor or major changes at any time without notice.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This documentation can temporarily be found hosted at <a href="https://bitcoincore.wtf" target="_blank" rel="noopener">bitcoincore.wtf</a>, however the hosted location is likely to change in the near future.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_contributor_journeys"><a class="link" href="#_contributor_journeys">Contributor journeys</a></h3>
<div class="paragraph">
<p>Some Contributors have documented their journeys into the space which lets us learn about approaches they found useful, and also any pitfalls and things they found difficult along the way.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/amitiuttarwar" target="_blank" rel="noopener">Amiti Uttarwar</a> - <a href="https://medium.com/@amitiu/onboarding-to-bitcoin-core-7c1a83b20365" target="_blank" rel="noopener">Onboarding to Bitcoin Core</a></p>
</li>
<li>
<p><a href="https://github.com/jonatack" target="_blank" rel="noopener">Jon Atack</a> - <a href="https://jonatack.github.io/articles/on-reviewing-and-helping-those-who-do-it" target="_blank" rel="noopener">On Reviewing, and Helping Those Who Do It</a></p>
</li>
<li>
<p><a href="https://github.com/jimmysong" target="_blank" rel="noopener">Jimmy Song</a> - <a href="https://bitcointechtalk.com/a-gentle-introduction-to-bitcoin-core-development-fdc95eaee6b8" target="_blank" rel="noopener">A Gentle Introduction to Bitcoin Core Development</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_decentralized_development"><a class="link" href="#_decentralized_development">Decentralized development</a></h3>
<div class="paragraph">
<p>Olivia Lovenmark and Amiti Uttarwar describe in their <a href="https://blog.okcoin.com/2020/09/15/developing-bitcoin/" target="_blank" rel="noopener">blog post</a> "Developing Bitcoin", how changes to bitcoin follow the pathway from proposal to being merged into the software, and finally into voluntary adoption by users choosing to use the software.</p>
</div>
</div>
<div class="sect2">
<h3 id="_developer_guidelines"><a class="link" href="#_developer_guidelines">Developer guidelines</a></h3>
<div class="paragraph">
<p>The Bitcoin Core project itself contains three documents of particular interest to Contributors:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://github.com/bitcoin/bitcoin/tree/master/CONTRIBUTING.md" target="_blank" rel="noopener">CONTRIBUTING.md</a>&#8201;&#8212;&#8201;How to get started contributing to the project.  (Forking, creating branches, commit patches)</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bitcoin/tree/master/doc/developer-notes.md" target="_blank" rel="noopener">developer-notes.md</a>&#8201;&#8212;&#8201;Development guidelines, coding style etc.</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bitcoin/blob/master/doc/productivity.md" target="_blank" rel="noopener">productivity.md</a>&#8201;&#8212;&#8201;Many tips for improving developer productivity (ccache, reviewing code, refspecs, git diffs)</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bitcoin/blob/master/test/README.md">test/README.md</a>&#8201;&#8212;&#8201;Guidance on running the test suite</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Using <code>ccache</code> as described in <em>productivity.md</em> above will speed up builds of Bitcoin Core dramatically.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Setting up a ramdisk for the test suite as described in <em>test/README.md</em> will speed up running the test suite dramatically.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_development_workflow"><a class="link" href="#_development_workflow">Development workflow</a></h3>
<div class="paragraph">
<p>Bitcoin Core uses a GitHub-based workflow for development.
The primary function of GitHub in the workflow is to discuss patches and connect them with review comments.</p>
</div>
<div class="paragraph">
<p>While some other prominent projects, e.g. the Linux kernel, use email to solicit feedback and review, Bitcoin Core has used GitHub for many years.
Initially, Satoshi distributed the code through private emails and hosting source archives at bitcoin.org, and later by hosting on SourceForge (which used SVN but did not at that time have a pull request system like GitHub).
The earliest reviewers submitted changes using patches either through email exchange with Satoshi, or by posting them on the bitcoin forum.</p>
</div>
<div class="paragraph">
<p>In August 2009, the source code was moved to GitHub by Sirius, and development has remained there and used the GitHub workflows ever since.</p>
</div>
<div class="sect3">
<h4 id="_use_of_github"><a class="link" href="#_use_of_github">Use of GitHub</a></h4>
<div class="paragraph">
<p>The GitHub side of the Bitcoin Core workflow for Contributors consists primarily of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Issues</p>
</li>
<li>
<p>PRs</p>
</li>
<li>
<p>Reviews</p>
</li>
<li>
<p>Comments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generally, issues are used for two purposes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Posting known issues with the software, e.g., bug reports, crash logs</p>
</li>
<li>
<p>Soliciting feedback on potential changes without providing associated code, as would be required in a PR.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>GitHub provides their own <a href="https://guides.github.com/features/issues/" target="_blank" rel="noopener">guide</a> on mastering Issues which is worth reading to understand the feature-set available when working with an issue.</p>
</div>
<div class="paragraph">
<p>PRs are where Contributors can submit their code against the main codebase and solicit feedback on the concept, the approach taken for the implementation, and the actual implementation itself.</p>
</div>
<div class="paragraph">
<p>PRs and Issues are often linked to/from one another:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>One common workflow is when an Issue is opened to report a bug.
After replicating the issue, a Contributor creates a patch and then opens a PR with their proposed changes.</p>
</div>
<div class="paragraph">
<p>In this case, the Contributor should, in addition to comments about the patch, reference that the patch fixes the issue.
For a patch which fixes issue 22889 this would be done by writing "fixes #22889" in the PR description or in a commit message.
In this case, the syntax "fixes #issue-number" is caught by GitHub&#8217;s <a href="https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue" target="_blank" rel="noopener">pull request linker</a>, which handles the cross-link automatically.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Another use-case of Issues is soliciting feedback on ideas that might require <em>significant</em> changes.
This helps free the project from having too many PRs open which aren&#8217;t ready for review and might waste reviewers' time.
In addition, this workflow can also save Contributors their <em>own</em> valuable time, as an idea might be identified as unlikely to be accepted <em>before</em> the contributor spends their time writing the code for it.</p>
</div>
<div class="paragraph">
<p>Most code changes to bitcoin are proposed directly as PRs&#8201;&#8212;&#8201;there&#8217;s no need to open an Issue for every idea before implementing it unless it may require significant changes.
Additionally, other Contributors (and would-be Reviewers) will often agree with the approach of a change, but want to "see the implementation" before they can really pass judgement on it.</p>
</div>
<div class="paragraph">
<p>GitHub is therefore used to help store and track reviews to PRs in a public way.</p>
</div>
<div class="paragraph">
<p>Comments (inside Issues, PRs, Projects etc.) are where all (GitHub) users can discuss relevant aspects of the item and have history of those discussions preserved for future reference.
Often Contributors having "informal" discussions about changes on e.g. IRC will be advised that they should echo the gist of their conversation as a comment on GitHub, so that the rationale behind changes can be more easily determined in the future.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reviewing_code"><a class="link" href="#_reviewing_code">Reviewing code</a></h4>
<div class="paragraph">
<p>Jon Atack provides a guide to reviewing a Bitcoin Core PR in his article <a href="https://jonatack.github.io/articles/how-to-review-pull-requests-in-bitcoin-core" target="_blank" rel="noopener">How To Review Pull Requests in Bitcoin Core</a>.</p>
</div>
<div class="paragraph">
<p>Gloria Zhao&#8217;s <a href="https://github.com/glozow/bitcoin-notes/blob/master/review-checklist.md" target="_blank" rel="noopener">review checklist</a> details what a "good" review might look like, along with some examples of what she personally considers good reviews.
In addition to this, it details how potential Reviewers can approach a new PR they have chosen to review, along with the sorts of questions they should be asking (and answering) in order to provide a meaningful review.
Some examples of the subject areas Gloria covers include the PR&#8217;s subject area, motivation, downsides, approach, security and privacy risks, implementation of the idea, performance impact, concurrency footguns, tests and documentation needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_contributing_code"><a class="link" href="#_contributing_code">Contributing code</a></h4>
<div class="paragraph">
<p>This section details some of the processes surrounding code contributions to the Bitcoin Core project along with some common pitfalls and tips to try and avoid them.</p>
</div>
<div class="sect4">
<h5 id="_branches"><a class="link" href="#_branches">Branches</a></h5>
<div class="paragraph">
<p>You should <strong>not</strong> use the built-in GitHub branch <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository" target="_blank" rel="noopener">creation</a> process, as this interferes with and confuses the Bitcoin Core git process.</p>
</div>
<div class="paragraph">
<p>Instead, you should use either the native <a href="https://git-scm.com/downloads" target="_blank" rel="noopener"><code>git</code></a> or the GitHub <a href="https://github.com/cli/cli" target="_blank" rel="noopener"><code>gh</code> cli</a> (requires <code>git</code>) tools to create your own branches locally, before pushing them to your fork of the repo, and opening a PR against the Bitcoin Core repo from there.</p>
</div>
</div>
<div class="sect4">
<h5 id="_creating_a_pr"><a class="link" href="#_creating_a_pr">Creating a PR</a></h5>
<div class="paragraph">
<p>Jon Atack&#8217;s article <a href="https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core" target="_blank" rel="noopener">How To Contribute Pull Requests To Bitcoin Core</a> describes some less-obvious requirements that any PR you make might be subjected to during peer review, for example that it needs an accompanying test, or that an intermediate commit on the branch doesn&#8217;t compile.
It also describes the uncodified expectation that Contributors should not only be writing code, but perhaps more importantly be providing reviews on other Contributors' PRs.
Most developers enjoy writing their own code more than reviewing code from others, but the decentralized review process is arguably the most critical defence Bitcoin development has against malicious actors and therefore important to try and uphold.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Jon&#8217;s estimates of "5-15 PR reviews|issues solved" per PR submitted is not a hard requirement, just what Jon himself feels would be best for the project. Don&#8217;t be put off submitting a potentially valuable PR just because "you haven&#8217;t done enough reviews"!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For some tips on how to maintain an open PR using git, such as how to redo commit history, as well as edit specific commits, check out this <a href="https://github.com/satsie/bitcoin-notez/blob/master/bitcoin-core-development/git-guide.md" target="_blank" rel="noopener">guide</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_commit_messages"><a class="link" href="#_commit_messages">Commit messages</a></h5>
<div class="paragraph">
<p>When writing commit messages be sure to have read Chris Beams' "How to Write a Git Commit Message" <a href="https://chris.beams.io/posts/git-commit/" target="_blank" rel="noopener">blog post</a>.
As described in CONTRIBUTING.md, PRs should be prefixed with the component or area the PR affects.
Common areas are listed in CONTRIBUTING.md section: <a href="https://github.com/bitcoin/bitcoin/tree/master/CONTRIBUTING.md#creating-the-pull-request" target="_blank" rel="noopener">Creating the pull request</a>.
Individual commit messages are also often given similar prefixes in the commit title depending on which area of the codebase the changes primarily affect.</p>
</div>
</div>
<div class="sect4">
<h5 id="_continuous_integration"><a class="link" href="#_continuous_integration">Continuous integration</a></h5>
<div class="paragraph">
<p>When PRs are submitted against the primary Bitcoin Core repo a series of CI <a href="https://github.com/bitcoin/bitcoin/tree/v23.0/ci" target="_blank" rel="noopener">tests</a> will automatically be run.
These include a series of linters and formatters such as <code>clang-format</code>, <code>flake8</code> and <code>shellcheck</code>.
It&#8217;s possible (and advised) to run these checks locally against any changes you make before you push them.</p>
</div>
<div class="paragraph">
<p>In order to run the lints yourself you&#8217;ll have to first make sure your python environment and system have the packages listed in the CI install <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/ci/lint/04_install.sh">script</a>.
You can then run a decent sub-set of the checks by running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">python test/lint/lint-circular-dependencies.py

# requires requires 'flake8', 'mypy', 'pyzmq', 'codespell', 'vulture'
python test/lint/lint-python.py

python test/lint/lint-whitespace.py</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can run all checks with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">python test/lint/all-lint.py</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Previously these checks were shell scripts (<code>*.sh</code>), but they have now been migrated to python on master.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>+
If you are following with tag v23.0 these may still exist as <code>*.sh</code>.</p>
</div>
<div class="paragraph">
<p>Linting your changes reduces the chances of pushing them as a PR and then having them quickly being marked as failing CI. The GitHub PR page auto-updates the CI status.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you do fail a lint or any other CI check, force-pushing the fix to your branch will cancel the currently-running CI checks and restart them.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_build_issues"><a class="link" href="#_build_issues">Build issues</a></h5>
<div class="paragraph">
<p>Some compile-time issues can be caused by an unclean build directory.
The comments in <a href="https://github.com/bitcoin/bitcoin/issues/19330" target="_blank" rel="noopener">issue 19330</a> provide some clarifications and tips on how other Contributors clean their directories, as well as some ideas for shell aliases to boost productivity.</p>
</div>
</div>
<div class="sect4">
<h5 id="_debugging_bitcoin_core"><a class="link" href="#_debugging_bitcoin_core">Debugging Bitcoin Core</a></h5>
<div class="paragraph">
<p>Fabian Jahr has created a <a href="https://github.com/fjahr/debugging_bitcoin" target="_blank" rel="noopener">guide</a> on "Debugging Bitcoin Core", aimed at detailing the ways in which various Bitcoin Core components can be debugged, including the Bitcoin Core binary itself, unit tests, functional tests along with an introduction to core dumps and the Valgrind memory leak detection suite.</p>
</div>
<div class="paragraph">
<p>Of particular note to Developers are the configure flags used to build Bitcoin Core without optimisations to permit more effective debugging of the various resulting binary files.</p>
</div>
<div class="paragraph">
<p>Fabian has also presented on this topic a number of times.
A <a href="https://btctranscripts.com/scalingbitcoin/tel-aviv-2019/edgedevplusplus/debugging-bitcoin/" target="_blank" rel="noopener">transcript</a> of his edgedevplusplus talk is available.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_codebase_archaeology"><a class="link" href="#_codebase_archaeology">Codebase archaeology</a></h4>
<div class="paragraph">
<p>When considering changing code it can be helpful to try and first understand the rationale behind why it was implemented that way originally.
One of the best ways to do this is by using a combination of git tools:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>git blame</code></p>
</li>
<li>
<p><code>git log -S</code></p>
</li>
<li>
<p><code>git log -G</code></p>
</li>
<li>
<p><code>git log -p</code></p>
</li>
<li>
<p><code>git log -L</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As well as the discussions in various places on the GitHub repo.</p>
</div>
<div class="sect4">
<h5 id="_git_blame"><a class="link" href="#_git_blame">git blame</a></h5>
<div class="paragraph">
<p>The git <code>blame</code> command will show you when (and by who) a particular line of code was last <em>changed</em>.</p>
</div>
<div class="paragraph">
<p>For example, if we checkout Bitcoin Core at <a href="https://github.com/bitcoin/bitcoin/tree/v22.0" target="_blank" rel="noopener">v22.0</a> and we are planning to make a change related to the <code>m_addr_send_times_mutex</code> found in <em>src/net_processing.cpp</em>, we might want to find out more about its history before touching it.</p>
</div>
<div class="paragraph">
<p>With <code>git `blame</code> we can find out the last person who touched this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash"># Find the line number for blame
$ grep -n m_addr_send_times_mutex src/net_processing.cpp
233:    mutable Mutex m_addr_send_times_mutex;
235:    std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};
237:    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(m_addr_send_times_mutex){0};
4304:    LOCK(peer.m_addr_send_times_mutex);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ git blame -L233,233 src/net_processing.cpp

76568a3351 (John Newbery 2020-07-10 16:29:57 +0100 233)     mutable Mutex m_addr_send_times_mutex;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this information we can easily look up that commit to gain some additional context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ git show 76568a3351


commit 76568a3351418c878d30ba0373cf76988f93f90e
Author: John Newbery &lt;john@johnnewbery.com&gt;
Date:   Fri Jul 10 16:29:57 2020 +0100

    [net processing] Move addr relay data and logic into net processing</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we&#8217;ve learned now that this mutex was moved here by John from <em>net.{cpp|h}</em> in it&#8217;s most recent touch.
Let&#8217;s see what else we can find out about it.</p>
</div>
</div>
<div class="sect4">
<h5 id="_git_log_s"><a class="link" href="#_git_log_s">git log -S</a></h5>
<div class="paragraph">
<p><code>git log -S</code> allows us to search for commits where this line was <em>modified</em> (not where it was only moved, for that use <code>git log -G</code>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A 'modification' (vs. a 'move') in git parlance is the result of uneven instances of the search term in the commit diffs' add/remove sections.</p>
</div>
<div class="paragraph">
<p>This implies that this term has either been added or removed in the commit.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ git log -S m_addr_send_times_mutex

commit 76568a3351418c878d30ba0373cf76988f93f90e
Author: John Newbery &lt;john@johnnewbery.com&gt;
Date:   Fri Jul 10 16:29:57 2020 +0100

    [net processing] Move addr relay data and logic into net processing


commit ad719297f2ecdd2394eff668b3be7070bc9cb3e2
Author: John Newbery &lt;john@johnnewbery.com&gt;
Date:   Thu Jul 9 10:51:20 2020 +0100

    [net processing] Extract `addr` send functionality into MaybeSendAddr()

    Reviewer hint: review with

     `git diff --color-moved=dimmed-zebra --ignore-all-space`


commit 4ad4abcf07efefafd439b28679dff8d6bbf62943
Author: John Newbery &lt;john@johnnewbery.com&gt;
Date:   Mon Mar 29 11:36:19 2021 +0100

    [net] Change addr send times fields to be guarded by new mutex</code></pre>
</div>
</div>
<div class="paragraph">
<p>We learn now that John also originally added this to <em>net.{cpp|h}</em>, before later moving it into <em>net_processing.{cpp|h}</em> as part of a push to separate out <code>addr</code> relay data and logic from <em>net.cpp</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_git_log_p"><a class="link" href="#_git_log_p">git log -p</a></h5>
<div class="paragraph">
<p><code>git log -p</code> (usually also given with a file name argument) follows each commit message with a <em>patch</em> (diff) of the changes made by that commit to that file (or files).
This is similar to <code>git blame</code> except that <code>git blame</code> shows the source of only lines <em>currently</em> in the file.</p>
</div>
</div>
<div class="sect4">
<h5 id="_git_log_l"><a class="link" href="#_git_log_l">git log -L</a></h5>
<div class="paragraph">
<p>The <code>-L</code> parameter provided to git log will allow you to trace certain lines of a file through a range given by <code>&lt;start,&lt;end&gt;</code>.</p>
</div>
<div class="paragraph">
<p>However, newer versions of git will also allow you to provide <code>git log -L</code> with a function name and a file, using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">git log -L :&lt;funcname&gt;:&lt;file&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will then display commits which modified this function in your pager.</p>
</div>
</div>
<div class="sect4">
<h5 id="_git_log_follow_file"><a class="link" href="#_git_log_follow_file">git log --follow <em>file&#8230;&#8203;</em></a></h5>
<div class="paragraph">
<p>One of the most famous <a href="https://github.com/bitcoin/bitcoin/pull/9260" target="_blank" rel="noopener">file renames</a> was <em>src/main.{h,cpp}</em> to <em>src/validation.{h,cpp}</em> in 2016.
If you simply run <code>git log src/validation.h</code>, the oldest displayed commit is one that implemented the rename.
<code>git log --follow src/validation.h</code> will show the same recent commits followed by the older <em>src/main.h</em> commits.</p>
</div>
<div class="paragraph">
<p>To see the history of a file that&#8217;s been removed, specify "&#8201;&#8212;&#8201;" before the file name, such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">git log -- some_removed_file.cpp</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pr_discussion"><a class="link" href="#_pr_discussion">PR discussion</a></h5>
<div class="paragraph">
<p>To get even more context on the change we can leverage GitHub and take a look at the comments on the PR where this mutex was introduced (or at any subsequent commit where it was modified).
To find the PR you can either paste the commit hash (<code>4ad4abcf07efefafd439b28679dff8d6bbf62943</code>) into GitHub, or list merge commits in reverse order, showing oldest merge with the commit at the top to show the specific PR number e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ git log --merges --reverse --oneline --ancestry-path 4ad4abcf07efefafd439b28679dff8d6bbf62943..upstream | head -n 1

d3fa42c79 Merge bitcoin/bitcoin#21186: net/net processing: Move addr data into net_processing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reading up on <a href="https://github.com/bitcoin/bitcoin/pull/21186" target="_blank" rel="noopener">PR#21186</a> will hopefully provide us with more context we can use.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>We can see from the linked <a href="https://github.com/bitcoin/bitcoin/issues/19398#issue-646725848" target="_blank" rel="noopener">issue 19398</a> what the motivation for this move was.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_building_from_source"><a class="link" href="#_building_from_source">Building from source</a></h4>
<div class="paragraph">
<p>When building Bitcoin Core from source, there are some platform-dependant instructions to follow.</p>
</div>
<div class="paragraph">
<p>To learn how to build for your platform, visit the Bitcoin Core <a href="https://github.com/bitcoin/bitcoin/tree/master/doc" target="_blank" rel="noopener">bitcoin/doc</a> directory, and read the file named "build-*.md", where "*" is the name of your platform.
For windows this is "build-windows.md", for macOS this is "build-osx.md" and for most linux distributions this is "build-unix.md".</p>
</div>
<div class="paragraph">
<p>There is also a guide by Jon Atack on how to <a href="https://jonatack.github.io/articles/how-to-compile-bitcoin-core-and-run-the-tests" target="_blank" rel="noopener">compile and test Bitcoin Core</a>.</p>
</div>
<div class="paragraph">
<p>Finally, Blockchain Commons also offer a guide to <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/A2_0_Compiling_Bitcoin_from_Source.md" target="_blank" rel="noopener">building from source</a>.</p>
</div>
<div class="sect4">
<h5 id="_cleaner_builds"><a class="link" href="#_cleaner_builds">Cleaner builds</a></h5>
<div class="paragraph">
<p>It can be helpful to use a separate build directory e.g. <code>build/</code> when compiling from source.
This can help avoid spurious Linker errors without requiring you to run <code>make clean</code> often.</p>
</div>
<div class="paragraph">
<p>From within your Bitcoin Core source directory you can run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"># Clean current source dir in case it was already configured
make distclean

# Make new build dir
mkdir build &amp;&amp; cd build

# Run normal build sequence with amended path
../autogen.sh
../configure --your-normal-options-here
make -j `nproc`
make check</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To run individual functional tests using the bitcoind binary built in an out-of-source build change directory back to the root source and specify the <em>config.ini</em> file from within the build directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">$ pwd
/path/to/source/build
$ cd ..
$ test/functional/p2p_ping.py --configfile build/test/config.ini</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_codebase_documentation"><a class="link" href="#_codebase_documentation">Codebase documentation</a></h4>
<div class="paragraph">
<p>Bitcoin Core uses <a href="https://www.doxygen.nl/index.html" target="_blank" rel="noopener">Doxygen</a> to generate developer documentation automatically from its annotated C++ codebase.
Developers can access documentation of the current release of Bitcoin Core online at <a href="https://doxygen.bitcoincore.org/" target="_blank" rel="noopener">doxygen.bitcoincore.org</a>, or alternatively can generate documentation for their current git <code>HEAD</code> using <code>make docs</code> (see <a href="https://github.com/bitcoin/bitcoin/tree/master/doc/developer-notes.md#generating-documentation" target="_blank" rel="noopener">Generating Documentation</a> for more info).</p>
</div>
</div>
<div class="sect3">
<h4 id="_testing"><a class="link" href="#_testing">Testing</a></h4>
<div class="paragraph">
<p>Three types of test network are available:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Testnet</p>
</li>
<li>
<p>Regtest</p>
</li>
<li>
<p>Signet</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These three networks all use coins of zero value, so can be used experimentally.</p>
</div>
<div class="paragraph">
<p>They primary differences between the networks are as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Comparison of different test networks</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Testnet</th>
<th class="tableblock halign-left valign-top">Regtest</th>
<th class="tableblock halign-left valign-top">Signet</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Mining algorithm</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Public hashing with difficulty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local hashing, low difficulty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Signature from authorized signers</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Block production schedule</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Varies per hashrate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">On-demand</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reliable intervals (default 2.5 mins)</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">P2P port</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">18333</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18444</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">38333</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">RPC port</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">18332</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">38332</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Peers</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Public</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Public</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Topology</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Organic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Organic</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Chain birthday</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">2011-02-02</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">At time of use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2020-09-01</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Can initiate re-orgs</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">If Miner</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Primary use</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Networked testing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automated integration tests</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Networked testing</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_signet"><a class="link" href="#_signet">Signet</a></h5>
<div class="paragraph">
<p>Signet is both a tool that allows Developers to create their own networks for testing interactions between different Bitcoin software, and the name of the most popular of these public testing networks.
Signet was codified in <a href="https://github.com/bitcoin/bips/tree/master/bip-0325.mediawiki" target="_blank" rel="noopener">BIP 325</a>.</p>
</div>
<div class="paragraph">
<p>To connect to the "main" Signet network, simply start bitcoind with the signet option, e.g. <code>bitcoind -signet</code>.
Don&#8217;t forget to also pass the signet option to <code>bitcoin-cli</code> if using it to control bitcoind, e.g. <code>bitcoin-cli -signet your_command_here</code>.
Instructions on how to setup your own Signet network can be found in the Bitcoin Core Signet <a href="https://github.com/bitcoin/bitcoin/tree/master/contrib/signet/README.md" target="_blank" rel="noopener">README.md</a>.
The Bitcoin wiki Signet <a href="https://en.bitcoin.it/wiki/Signet" target="_blank" rel="noopener">page</a> provides additional background on Signet.</p>
</div>
</div>
<div class="sect4">
<h5 id="_regtest"><a class="link" href="#_regtest">Regtest</a></h5>
<div class="paragraph">
<p>Another test network named <em>regtest</em>, which stands for <em>regression test</em>, is also available.
This network is enabled by starting bitcoind with the <code>-regtest</code> option.
This is an entirely self-contained mode, giving you complete control of the state of the blockchain.
Blocks can simply be mined on command by the network operator.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc" target="_blank" rel="noopener">functional tests</a> use this mode, but you can also run it manually.
It provides a good means to learn and experiment on your own terms.
It&#8217;s often run with a single node but may be run with multiple co-located (local) nodes (most of the functional tests do this).
The blockchain initially contains only the genesis block, so you need to mine &gt;100 blocks in order to have any spendable coins from a mature coinbase.
Here&#8217;s an example session (after you&#8217;ve built <code>bitcoind</code> and <code>bitcoin-cli</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ mkdir -p /tmp/regtest-datadir
$ src/bitcoind -regtest -datadir=/tmp/regtest-datadir
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getblockchaininfo
{
  "chain": "regtest",
  "blocks": 0,
  "headers": 0,
  "bestblockhash": "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",
  _(...)_
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir createwallet testwallet
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir -generate 3
{
  "address": "bcrt1qpw3pjhtf9myl0qk9cxt54qt8qxu2mj955c7esx",
  "blocks": [
    "6b121b0c094b5e107509632e8acade3f6c8c2f837dc13c72153e7fa555a29984",
    "5da0c549c3fddf2959d38da20789f31fa7642c3959a559086436031ee7d7ba54",
    "3210f3a12c25ea3d8ab38c0c4c4e0d5664308b62af1a771dfe591324452c7aa9"
  ]
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getblockchaininfo
{
  "chain": "regtest",
  "blocks": 3,
  "headers": 3,
  "bestblockhash": "3210f3a12c25ea3d8ab38c0c4c4e0d5664308b62af1a771dfe591324452c7aa9",
  _(...)_
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getbalances
{
  "mine": {
    "trusted": 0.00000000,
    "untrusted_pending": 0.00000000,
    "immature": 150.00000000
  }
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir stop</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may stop and restart the node and it will use the existing state.
(Simply remove the data directory to start again from scratch.)</p>
</div>
<div class="paragraph">
<p>Blockchain Commons offer a guide to <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/A3_0_Using_Bitcoin_Regtest.md" target="_blank" rel="noopener">Using Bitcoin Regtest</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_testnet"><a class="link" href="#_testnet">Testnet</a></h5>
<div class="paragraph">
<p>Testnet is a public bitcoin network where mining is performed in the usual way (hashing) by decentralized miners.</p>
</div>
<div class="paragraph">
<p>However, due to much lower hashrate (than mainnet), testnet is susceptible extreme levels of inter-block volatility due to the way the difficulty adjustment (DA) works: if a mainnet-scale miner wants to "test" their mining setup on testnet then they may cause the difficulty to increase greatly.
Once the miner has concluded their tests they may remove all hashpower from the network at once.
This can leave the network with a high difficulty which the DA will take a long time to compensate for.</p>
</div>
<div class="paragraph">
<p>Therefore a <a href="https://en.bitcoin.it/wiki/Testnet#Differences" target="_blank" rel="noopener">"20 minute" rule</a> was introduced such that the difficulty would reduce to the minimum for one block before returning to its previous value.
This ensures that there are no intra-block times greater than 20 minutes.</p>
</div>
<div class="paragraph">
<p>However there is a bug in the implementation which means that if this adjustment occurs on a difficulty adjustment block the difficulty is lowered to the minimum for one block but then not reset, making it permanent rather than a one-off adjustment.
This will result in a large number of blocks being found until the DA catches up to the level of hashpower on the network.</p>
</div>
<div class="paragraph">
<p>It&#8217;s usually preferable to test private changes on a local regtest, or public changes on a Signet for this reason.</p>
</div>
</div>
<div class="sect4">
<h5 id="_manual_testing_while_running_a_functional_test"><a class="link" href="#_manual_testing_while_running_a_functional_test">Manual testing while running a functional test</a></h5>
<div class="paragraph">
<p>Running regtest as described allows you to start from scratch with an empty chain, empty wallet, and no existing state.</p>
</div>
<div class="paragraph">
<p>An effective way to use regtest is to start a <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc" target="_blank" rel="noopener">functional test</a> and insert a python debug breakpoint.
You can set a breakpoint in a test by adding <code>import pdb; pdb.set_trace()</code> at the desired stopping point; when the script reaches this point you&#8217;ll see the debugger&#8217;s <code>(Pdb)</code> prompt, at which you can type <code>help</code> and see and do all kinds of useful things.</p>
</div>
<div class="paragraph">
<p>While the (Python) test is paused, you can still control the node using <code>bitcoin-cli</code>.
First you need to look up the data directory for the node(s), as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ ps alx | grep bitcoind
0  1000   57478   57476  20   0 1031376 58604 pipe_r SLl+ pts/10    0:06 /g/bitcoin/src/bitcoind -datadir=/tmp/bitcoin_func_test_ovsi15f9/node0 -logtimemicros -debug (...)
0  1000   57479   57476  20   0 965964 58448 pipe_r SLl+ pts/10     0:06 /g/bitcoin/src/bitcoind -datadir=/tmp/bitcoin_func_test_ovsi15f9/node1 -logtimemicros -debug (...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the <code>-datadir</code> path you can look at the <code>bitcoin.conf</code> files within the data directories to see what config options are being specified for the test (there&#8217;s always <code>regtest=1</code>) in addition to the runtime options, which is a good way to learn about some advanced uses of regtest.</p>
</div>
<div class="paragraph">
<p>In addition to this, we can use the <code>-datadir=</code> option with <code>bitcoin-cli</code> to control specific nodes, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="bash">$ src/bitcoin-cli -datadir=/tmp/bitcoin_func_test_ovsi15f9/node0 getblockchaininfo</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_getting_started_with_development"><a class="link" href="#_getting_started_with_development">Getting started with development</a></h4>
<div class="paragraph">
<p>One of the roles most in-demand from the project is that of code review, and in fact this is also one of the best ways of getting familiarized with the codebase too!
Reviewing a few PRs and adding your review comments to the PR on GitHub can be really valuable for you, the PR author and the bitcoin community.
This <a href="https://testing.googleblog.com/2018/05/code-health-understanding-code-in-review.html" target="_blank" rel="noopener">Google Code Health</a> blog post gives some good advice on how to go about code review and getting past "feeling that you&#8217;re not as smart as the programmer who wrote the change".
If you&#8217;re going to ask some questions as part of review, try and keep questions <a href="https://testing.googleblog.com/2019/11/code-health-respectful-reviews-useful.html" target="_blank" rel="noopener">respectful</a>.</p>
</div>
<div class="paragraph">
<p>There is also a Bitcoin Core PR <a href="https://bitcoincore.reviews/" target="_blank" rel="noopener">Review Club</a> held weekly on IRC which provides an ideal entry point into the Bitcoin Core codebase.
A PR is selected, questions on the PR are provided beforehand to be discussed on irc.libera.chat #bitcoin-core-pr-reviews IRC room and a host will lead discussion around the changes.</p>
</div>
<div class="paragraph">
<p>Aside from review, there are 3 main avenues which might lead you to submitting your <strong>own</strong> PR to the repository:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Finding a <code>good first issue</code>, as tagged in the <a href="https://github.com/bitcoin/bitcoin/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22" target="_blank" rel="noopener">issue tracker</a></p>
</li>
<li>
<p>Fixing a bug</p>
</li>
<li>
<p>Adding a new feature (that you want for yourself?)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Choosing a "good first issue" from an area of the codebase that seems interesting to you is often a good approach.
This is because these issues have been somewhat implicitly "concept ACKed" by other Contributors as "something that is likely worth someone working on".
Don&#8217;t confuse this for meaning that if you work on it that it is certain to be merged though.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t have a bug fix or new feature in mind and you&#8217;re struggling to find a good first issue which looks suitable for you, don&#8217;t panic.
Instead keep reviewing other Contributors' PRs to continue improving your understanding of the process (and the codebase) while you watch the Issue tracker for something which you like the look of.</p>
</div>
<div class="paragraph">
<p>When you&#8217;ve decided what to work on it&#8217;s time to take a look at the current behaviour of that part of the code and perhaps more importantly, try to understand <em>why</em> this was originally implemented in this way.
This process of codebase "archaeology" will prove invaluable in the future when you are trying to learn about other parts of the codebase on your own.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bitcoin_core_dev_irc_channel"><a class="link" href="#_bitcoin_core_dev_irc_channel">#bitcoin-core-dev IRC channel</a></h4>
<div class="paragraph">
<p>The Bitcoin Core project has an IRC channel <code>#bitcoin-core-dev</code> available on the Libera.chat network.
If you are unfamiliar with IRC there is a short guide on how to use it with a client called Matrix <a href="https://hackmd.io/ZcCoEDnOSTSqb2RDa7fB8Q" target="_blank" rel="noopener">here</a>.
IRC clients for all platforms and many terminals are available.</p>
</div>
<div class="paragraph">
<p>"Lurking" (watching but not talking) in the IRC channel can both be a great way to learn about new developments as well as observe how new technical changes and issues are described and thought about from other developers with an adversarial mindset.
Once you are comfortable with the rules of the room and have questions about development then you can join in too!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This channel is reserved for discussion about <em>development of the Bitcoin Core software only</em>, so please don&#8217;t ask general Bitcoin questions or talk about the price or other things which would be off topic in there.</p>
</div>
<div class="paragraph">
<p>There are plenty of other channels on IRC where those topics can be discussed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are also regular meetings held on #bitcoin-core-dev which are free and open for anyone to attend.
Details and timings of the various meetings are found <a href="https://bitcoincore.org/en/meetings/" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_communication"><a class="link" href="#_communication">Communication</a></h4>
<div class="paragraph">
<p>In reality there are no hard rules on choosing a discussion forum, but in practice there are some common conventions which are generally followed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to discuss the codebase of the Bitcoin Core implementation, then discussion on either the GitHub repo or IRC channel is usually most-appropriate.</p>
</li>
<li>
<p>If you want to discuss changes to the core bitcoin protocol, then discussion on the mailing list is usually warranted to solicit feedback from (all) bitcoin developers, including the many of them that do not work on Bitcoin Core directly.</p>
<div class="ulist">
<ul>
<li>
<p>If mailing list discussions seem to indicate interest for a proposal, then creation of a BIP usually follows.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If discussing something Bitcoin Core-related, there can also be a question of whether it&#8217;s best to open an Issue, to first discuss the problem and brainstorm possible solution approaches, or whether you should implement the changes as you see best first, open a PR, and then discuss changes in the PR.
Again, there are no hard rules here, but general advice would be that for potentially-controversial subjects, it might be worth opening an Issue first, before (potentially) wasting time implementing a PR fix which is unlikely to be accepted.</p>
</div>
<div class="paragraph">
<p>Regarding communication timelines it is important to remember that many contributors are unpaid volunteers, and even if they are sponsored or paid directly, nobody owes you their time.
That being said, often during back-and-forth communication you might want to nudge somebody for a response and it&#8217;s important that you do this in a courteous way.
There are again no hard rules here, but it&#8217;s often good practice to give somebody on the order of a few days to a week to respond.
Remember that people have personal lives and often jobs outside of Bitcoin development.</p>
</div>
<div class="sect4">
<h5 id="_ack_nack"><a class="link" href="#_ack_nack">ACK / NACK</a></h5>
<div class="paragraph">
<p>If you are communicating on an Issue or PR, you might be met with "ACK"s and "NACK"s (or even "approach (N)ACK" or similar).
ACK, or "acknowledge" generally means that the commenter approves with what is being discussed previously.
NACK means they tend to not approve.</p>
</div>
<div class="paragraph">
<p>What should you do if your PR is met with NACKs or a mixture of ACKs and NACKs?
Again there are no hard rules but generally you should try to consider all feedback as constructive criticism.
This can feel hard when veteran contributors appear to drop by and with a single "NACK" shoot down your idea, but in reality it presents a good moment to pause and reflect on <em>why</em> someone is not agreeing with the path forward you have presented.</p>
</div>
<div class="paragraph">
<p>Although there are again no hard "rules" or "measurement" systems regarding (N)ACKs, maintainers&#8201;&#8212;&#8201;who&#8217;s job it is to measure whether a change has consensus before merging&#8201;&#8212;&#8201;will often use their discretion to attribute more weight behind the (N)ACKs of contributors that they feel have a good understanding of the codebase in this area.</p>
</div>
<div class="paragraph">
<p>This makes sense for many reasons, but lets imagine the extreme scenario where members of a Reddit/Twitter thread (or other group) all "<a href="https://www.dictionary.com/e/slang/brigading/">brigade</a>" a certain pull request on GitHub, filling it with tens or even hundreds of NACKs&#8230;&#8203;
In this scenario it makes sense for a maintainer to somewhat reduce the weighting of these NACKs vs the (N)ACKs of regular contributors:</p>
</div>
<div class="paragraph">
<p>We are not sure which members of this brigade:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Know how to code and with what competency</p>
</li>
<li>
<p>Are familiar with the Bitcoin Core codebase</p>
</li>
<li>
<p>Understand the impact and repercussions of the change</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whereas we can be more sure that regular contributors <strong>and</strong> those respondents who are providing additional rationale in addition to their (N)ACK, have some understanding of this nature.
Therefore it makes sense that we should weight regular contributors' responses, and those with additional compelling rationale, more heavily than GitHub accounts created yesterday which reply with a single word (N)ACK.</p>
</div>
<div class="paragraph">
<p>From this extreme example we can then use a sliding scale to the other extreme where, if a proven expert in this area is providing a lone (N)ACK to a change, that we should perhaps step back and consider this more carefully.</p>
</div>
<div class="paragraph">
<p>Does this mean that your views as a new contributor are likely to be ignored?
<strong>No</strong>!!
However it might mean that you might like to include rationale in any ACK/NACK comments you leave on PRs, to give more credence to your views.</p>
</div>
<div class="paragraph">
<p>When others are (N)ACK-ing your work, you should not feel discouraged because they have been around longer than you.
If they have not left rationale for the comment, then you should ask them for it.
If they have left rationale but you disagree, then you can politely state your reasons for disagreement.</p>
</div>
<div class="paragraph">
<p>In terms of choosing a tone, the best thing to do it to participate in PR review for a while and observe the tone used in public when discussing changes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_backports"><a class="link" href="#_backports">Backports</a></h4>
<div class="paragraph">
<p>Bitcoin Core often backports fixes for bugs and soft fork activations into previous software releases.</p>
</div>
<div class="paragraph">
<p>Generally maintainers will handle backporting for you, unless for some reason the process will be too difficult.
If this point is reached a decision will be made on whether the backport is abandoned, or a specific (new) fix is created for the older software version.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reproducible_guix_builds"><a class="link" href="#_reproducible_guix_builds">Reproducible Guix builds</a></h3>
<div class="paragraph">
<p>Bitcoin Core uses the <a href="https://guix.gnu.org/" target="_blank" rel="noopener">Guix</a> package manager to achieve reproducible builds.
Carl Dong gave an introduction to GUIX via a <a href="https://btctranscripts.com/breaking-bitcoin/2019/bitcoin-build-system/" target="_blank" rel="noopener">remote talk</a> in 2019, and also discussed it further on a ChainCode <a href="https://btctranscripts.com/chaincode-labs/chaincode-podcast/2020-11-30-carl-dong-reproducible-builds/" target="_blank" rel="noopener">podcast</a> episode.</p>
</div>
<div class="paragraph">
<p>There are official <a href="https://github.com/bitcoin/bitcoin/blob/master/contrib/guix/README.md" target="_blank" rel="noopener">instructions</a> on how to run a Guix build in the Bitcoin Core repo which you should certainly follow for your first build, but once you have managed to set up the Guix environment (along with e.g. MacOS SDK), hebasto provides a more concise workflow for subsequent or repeated builds in his <a href="https://gist.github.com/hebasto/7293726cbfcd0b58e1cfd5418316cee3" target="_blank" rel="noopener">gist</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_software_life_cycle"><a class="link" href="#_software_life_cycle">Software Life-cycle</a></h3>
<div class="paragraph">
<p>An overview of the software life-cycle for Bitcoin Core can be found at <a href="https://bitcoincore.org/en/lifecycle/" class="bare">https://bitcoincore.org/en/lifecycle/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_organisation_roles"><a class="link" href="#_organisation_roles">Organisation &amp; roles</a></h3>
<div class="paragraph">
<p>The objective of the Bitcoin Core Organisation is to represent an entity that is decentralized as much as practically possible on a centralised platform.
One where no single Contributor, Member, or Maintainer has unilateral control over what is/isn&#8217;t merged into the project.
Having multiple Maintainers, Members, Contributors, and Reviewers gives this objective the best chance of being realised.</p>
</div>
<div class="sect3">
<h4 id="_contributors"><a class="link" href="#_contributors">Contributors</a></h4>
<div class="paragraph">
<p>Anyone who contributes code to the codebase is labelled a Contributor by GitHub and also by the community.
As of Version 23.0 of Bitcoin Core, there are &gt; 850 individual Contributors credited with changes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_members"><a class="link" href="#_members">Members</a></h4>
<div class="paragraph">
<p>Some Contributors are also labelled as Members of the <a href="https://github.com/orgs/bitcoin/people" target="_blank" rel="noopener">Bitcoin organisation</a>.
There are no defined criteria for becoming a Member of the organisation; persons are usually nominated for addition or removal by current Maintainer/Member/Admin on an ad-hoc basis.
Members are typically frequent Contributors/Reviewers and have good technical knowledge of the codebase.</p>
</div>
<div class="paragraph">
<p>Some members also have some additional permissions over Contributors, such as adding/removing tags on issues and Pull Requests (PRs); however, being a Member <strong>does not</strong> permit you to merge PRs into the project.
Members can also be assigned sections of the codebase in which they have specific expertise to be more easily requested for review as Suggested Reviewers by PR authors.</p>
</div>
</div>
<div class="sect3">
<h4 id="_maintainers"><a class="link" href="#_maintainers">Maintainers</a></h4>
<div class="paragraph">
<p>Some organisation Members are also project Maintainers.
The number of maintainers is arbitrary and is subject to change as people join and leave the project, but has historically been less than 10.
PRs can only be merged into the main project by Maintainers.
While this might give the illusion that Maintainers are in control of the project, the Maintainers' role dictates that they <strong>should not</strong> be unilaterally deciding which PRs get merged and which don&#8217;t.
Instead, they should be determining the mergability of changes based primarily on the reviews and discussions of other Contributors on the GitHub PR.</p>
</div>
<div class="paragraph">
<p>Working on that basis, the Maintainers' role becomes largely <em>janitorial</em>.
They are simply executing the desires of the community review process, a community which is made up of a decentralized and diverse group of Contributors.</p>
</div>
</div>
<div class="sect3">
<h4 id="_organisation_fail_safes"><a class="link" href="#_organisation_fail_safes">Organisation fail-safes</a></h4>
<div class="paragraph">
<p>It is possible for a "rogue PR" to be submitted by a Contributor; we rely on systematic and thorough peer review to catch these.
There has been <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019490.html" target="_blank" rel="noopener">discussion</a> on the mailing list about purposefully submitting malicious PRs to test the robustness of this review process.</p>
</div>
<div class="paragraph">
<p>In the event that a Maintainer goes rogue and starts merging controversial code, or conversely, <em>not</em> merging changes that are desired by the community at large, then there are two possible avenues of recourse:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Have the Lead Maintainer remove the malicious Maintainer</p>
</li>
<li>
<p>In the case that the Lead Maintainer themselves is considered to be the rogue agent: fork the project to a new location and continue development there.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the case that GitHub itself becomes the rogue entity, there have been numerous discussions about how to move away from GitHub, which have been summarized on the devwiki <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/GitHub-alternatives-for-Bitcoin-Core" target="_blank" rel="noopener">here</a>.
This summary came in part from discussions on <a href="https://github.com/bitcoin/bitcoin/issues/20227" target="_blank" rel="noopener">this</a> GitHub issue.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bips"><a class="link" href="#_bips">BIPs</a></h3>
<div class="paragraph">
<p>Bitcoin uses Bitcoin Improvement Proposals (BIPs) as a design document for introducing new features or behaviour into bitcoin.
Bitcoin Magazine describes what a BIP is in their article <a href="https://bitcoinmagazine.com/guides/what-is-a-bitcoin-improvement-proposal-bip" target="_blank" rel="noopener">What Is A Bitcoin Improvement Proposal (BIP)</a>, specifically highlighting how BIPs are not necessarily binding documents required to achieve consensus.</p>
</div>
<div class="paragraph">
<p>The BIPs are currently hosted on GitHub in the bitcoin/bips <a href="https://github.com/bitcoin/bips" target="_blank" rel="noopener">repo</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">BIP process</div>
<div class="paragraph">
<p>The BIPs include <a href="https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki" target="_blank" rel="noopener">BIP 2</a> which self-describes the BIP process in more detail.
Of particular interest might be the sections <a href="https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki#BIP_types" target="_blank" rel="noopener">BIP Types</a> and <a href="https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki#BIP_workflow" target="_blank" rel="noopener">BIP Workflow</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_what_does_having_a_bip_number_assigned_to_an_idea_mean"><a class="link" href="#_what_does_having_a_bip_number_assigned_to_an_idea_mean">What does having a BIP number assigned to an idea mean</a></h4>
<div class="paragraph">
<p>Bitcoin Core <a href="https://github.com/bitcoin/bitcoin/pull/22665" target="_blank" rel="noopener">issue #22665</a> described how BIP125 was not being strictly adhered to by Bitcoin Core.
This raised discussion amongst developers about whether the code (i.e. "the implementation") or the BIP itself should act as the specification, with most developers expressing that they felt that "the code was the spec" and any BIP generated was merely a design document to aid with re-implementation by others, and should be corrected if necessary.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This view was not completely unanimous in the community.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For consensus-critical code most Bitcoin Core Developers consider "the code is the spec" to be the ultimate source of truth, which is one of the reasons that recommending running other full node implementations can be so difficult.
A knock-on effect of this was that there were calls for review on BIP2 itself, with respect to how BIPs should be updated/amended.
Newly-appointed BIP maintainer Karl-Johan Alm (a.k.a. kallewoof) posted his thoughts on this to the <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019457.html" target="_blank" rel="noopener">bitcoin-dev mailing list</a>.</p>
</div>
<div class="paragraph">
<p>In summary a BIP represents a design document which should assist others in implementing a specific feature in a compatible way.
These features are optional to usage of Bitcoin, and therefore implementation of BIPs are not required to use Bitcoin, only to remain compatible.
Simply being <em>assigned</em> a BIP does <strong>not</strong> mean that an idea is endorsed as being a "good" idea, only that it is fully-specified in a way that others could use to re-implement.
Many ideas are assigned a BIP and then never implemented or used on the wider network.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_project_stats"><a class="link" href="#_project_stats">Project stats</a></h3>
<div class="listingblock">
<div class="title">Bitcoin Core @ v24.0.1</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="text">===============================================================================
 Language            Files        Lines         Code     Comments       Blanks
===============================================================================
 GNU Style Assembly      1          913          742           96           75
 Autoconf               23         3530         1096         1727          707
 Automake                5         1803         1505           85          213
 BASH                   10         1772         1100          438          234
 Batch                   1            1            1            0            0
 C                      22        37994        35681         1183         1130
 C Header              481        72043        43968        17682        10393
 CMake                   3          901          706           86          109
 C++                   687       197249       153482        20132        23635
 Dockerfile              2           43           32            5            6
 HEX                    29          576          576            0            0
 Java                    1           23           18            0            5
 JSON                   94         7968         7630            0          338
 Makefile               51         2355         1823          198          334
 MSBuild                 2           88           87            0            1
 Objective-C++           3          186          134           20           32
 Prolog                  2           22           16            0            6
 Python                298        66473        48859         7598        10016
 Scheme                  1          638          577           29           32
 Shell                  50         2612         1745          535          332
 SVG                    20          720          697           15            8
 Plain Text              6         1125            0         1113           12
 TypeScript             98       228893       228831            0           62
 Visual Studio Pro|     16          956          940            0           16
 Visual Studio Sol|      1          162          162            0            0
 XML                     2           53           47            0            6
-------------------------------------------------------------------------------
 HTML                    2          401          382            0           19
 |- CSS                  2           98           82            1           15
 (Total)                            499          464            1           34
-------------------------------------------------------------------------------
 Markdown              192        33460            0        26721         6739
 |- BASH                16          206          173           12           21
 |- C                    2           53           47            3            3
 |- C++                  3          345          267           54           24
 |- INI                  1            7            6            0            1
 |- Lisp                 1           13           13            0            0
 |- PowerShell           1            1            1            0            0
 |- Python               2          346          280           61            5
 |- Shell                3           21           17            1            3
 |- XML                  1            4            4            0            0
 (Total)                          34456          808        26852         6796
===============================================================================
 Total                2103       662960       530837        77663        54460
===============================================================================</code></pre>
</div>
</div>
<div class="paragraph">
<p>Source: <a href="https://github.com/XAMPPRocky/tokei" target="_blank" rel="noopener">tokei</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_exercises"><a class="link" href="#_exercises">Exercises</a></h3>
<div class="paragraph">
<p>Subsequent sections will contain various exercises related to their subject areas which will require controlling Bitcoin Core nodes, compiling Bitcoin Core and making changes to the code.</p>
</div>
<div class="paragraph">
<p>To prepare for this we will begin with the following exercises which will ensure that our environment is ready:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Build Bitcoin Core from source</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Clone Bitcoin Core repository from GitHub</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Check out the latest release tag (e.g. <code>v24.0.1</code>)</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Install any dependencies required for your system</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Follow the build instructions to compile the programs</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Run <code>make check</code> to run the <a href="https://github.com/bitcoin/bitcoin/tree/master/src/test#readme" target="_blank" rel="noopener">unit tests</a></p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Follow the documentation to install dependencies required to run the <a href="https://github.com/bitcoin/bitcoin/tree/master/test" target="_blank" rel="noopener">functional tests</a></p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Run the functional tests</p>
</li>
</ul>
</div>
</li>
<li>
<p>Run a <code>bitcoind</code> node in regtest mode and control it using the <code>cli</code> tool<br></p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>./src/bitcoind -regtest</code> will start bitcoind in regtest mode. You can then control it using <code>./src/bitcoin-cli -regtest -getinfo</code>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Run and control a Bitcoin Core node using the <code>TestShell</code> python class from the test framework in a Jupyter notebook</p>
<div class="ulist">
<ul>
<li>
<p>See <a href="#test_shell_nodes">Running nodes via Test Framework</a> for more information on how to do this</p>
</li>
</ul>
</div>
</li>
<li>
<p>Review a Pull Request from the repo</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Find a PR (which can be open or closed) on GitHub which looks interesting and/or accessible</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Checkout the PR locally</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Review the changes</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Record any questions that arise during code review</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Build the PR</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Test the PR</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Break a test / add a new test</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Leave review feedback on GitHub, possibly including:</p>
<div class="paragraph">
<p>ACK/NACK</p>
</div>
<div class="paragraph">
<p>Approach</p>
</div>
<div class="paragraph">
<p>How you reviewed it</p>
</div>
<div class="paragraph">
<p>Your system specifications if relevant</p>
</div>
<div class="paragraph">
<p>Any suggested nits</p>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="test_shell_nodes" class="sidebarblock">
<div class="content">
<div class="title">Running nodes via Test Framework</div>
<h3 id="_why" class="discrete">Why</h3>
<div class="paragraph">
<p>Using Bitcoin Core&#8217;s Test Framework means that nodes can be started, controlled and stopped using a python control class.
Additionally, they are run in a temporary directory which is automatically removed by the operating system, if not done
manually.</p>
</div>
<div class="paragraph">
<p>In addition to this, the <code>TestShell</code> class has an extremely similar interface to <code>bitcoin-cli</code>, where most <code>bitcoin-cli</code> commands have an equivalent <code>TestShell</code> method, and arguments can be supplied positionally or as named values.
Specifically, all <code>bitcoind</code> RPCs are available to <code>TestShell</code>.</p>
</div>
<div class="paragraph">
<p>However, certain <code>bitcoin-cli</code> commands, for example <code>-getinfo</code> require <code>bitcoin-cli</code> to call multiple RPCs and combine the results into something more user-friendly.
These commands are not natively available to <code>TestShell</code>, but you can re-create them yourself by running multiple <code>TestShell</code> RPCs and combining the outputs to mimic the <code>bitcoin-cli</code> commands!</p>
</div>
<div class="paragraph">
<p>When <code>TestShell</code> is combined with a jupyter notebook the result is easy-to-setup ephemeral nodes where iteration on complex commands is more pleasant than in the shell, and complex sequences of commands can be reproduced without having to write bash scripts or use shell history.</p>
</div>
<div class="paragraph">
<p>Once a complex command or sequence of commands is established, they can generally be translated to <code>bitcoin-cli</code> commands or a shell script without much difficulty.</p>
</div>
<h3 id="_how" class="discrete">How</h3>
<div class="paragraph">
<p>You <strong>MUST</strong> have a compiled <code>bitcoind</code> binary in the Bitcoin Core source directory.
You can use any recent supported version of Bitcoin Core.</p>
</div>
<div class="paragraph">
<p>In order to add startup (<code>bitcoind</code> program) options to our node(s) we need <a href="https://github.com/bitcoin/bitcoin/pull/26617/commits/989a52e0a50c0ae30a5c2bd3c08bb3ad1363a250" target="_blank" rel="noopener">this</a> commit.
We can include this two ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the master branch of Bitcoin Core and running <code>git pull</code>, which will include the change.</p>
</li>
<li>
<p>Use any recent tag (e.g. v24.0.1) and running <code>git cherry-pick 989a52e0</code> to pull that change into the Test Framework code.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You <strong>MUST</strong> have a copy of the jupyter notebook, either manually downloaded from <a href="https://github.com/chaincodelabs/onboarding-to-bitcoin-core" class="bare">https://github.com/chaincodelabs/onboarding-to-bitcoin-core</a> or by cloning the onboarding-to-bitcoin-core repo (recommended) with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">git clone https://github.com/chaincodelabs/onboarding-to-bitcoin-core.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>You <strong>MAY</strong> want to use a python virtual environment (recommended) which can be done as follows when in the onboarding to bitcoin core top level directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">cd /path/to/source/onboarding-to-bitcoin-core
python3 -m venv "obc-venv"
source obc-venv/bin/activate</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
if using fish shell you can use: <code>source obc-venv/bin/activate.fish</code> instead
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once your venv is set up and activated you can install the requirements for jupyter notebook using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">pip install -r requirements.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next start the notebook with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">jupyter notebook</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will open a list of all the files in this directory.
Opening the file named <code>exercise_tutorial.ipynb</code> will start the notebook containing instructions on how to use <code>TestShell</code> from the test Framework.</p>
</div>
<div class="paragraph">
<p>When you are finished you can deactivate the venv using</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">deactivate</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t forget to re-activate your venv each time you want to start the Jupyter notebook after deactivating the venv!
</td>
</tr>
</table>
</div>
<h3 id="_quick_use" class="discrete">Quick use</h3>
<div class="paragraph">
<p>Once you have familiarized yourself with the <code>TestShell</code> method using <code>exercise_tutorial.ipynb</code>, you can instead start new notebooks for exercises based on the <code>exercise_base.ipynb</code> notebook, which has much of the instruction removed and will let you get started faster.</p>
</div>
<div class="paragraph">
<p>If you correct the import path for your system in this file and save it, you can then easily make copies of it to use as start points for different exercises:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jupyter_duplicate.png" alt="jupyter duplicate" width="300">
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_architecture"><a class="link" href="#_architecture">Architecture</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bitcoin Core v0.1 contained 26 source code and header files (*.h/cpp) with <em>main.cpp</em> containing the majority of the business logic.
As of v23.0 there are more than 800 source files (excluding <em>bench/</em>, <em>test/</em> and all subtrees), more than 200 benchmarking and cpp unit tests, and more than 200 python tests and lints.</p>
</div>
<div class="sect2">
<h3 id="_general_design_principles"><a class="link" href="#_general_design_principles">General design principles</a></h3>
<div class="paragraph">
<p>Over the last decade, as the scope, complexity and test coverage of the codebase has increased, there has been a general effort to not only break Bitcoin Core down from its monolithic structure but also to move towards it being a collection of self-contained subsystems.
The rationale for such a goal is that this makes components easier to reason about, easier to test, and less-prone to layer violations, as subsystems can contain a full view of all the information they need to operate.</p>
</div>
<div class="paragraph">
<p>Subsystems can be notified of events relevant to them and take appropriate actions on their own.
On the GUI/QT side this is handled with signals and slots, but in the core daemon this is largely still a producer/consumer pattern.</p>
</div>
<div class="paragraph">
<p>The various subsystems are often suffixed with <code>Manager</code> or <code>man</code>, e.g. <code>CConnman</code> or <code>ChainstateManager</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The extra "C" in <code>CConnman</code> is a hangover from the <a href="https://en.wikipedia.org/wiki/Hungarian_notation" target="_blank" rel="noopener">Hungarian notation</a> used originally by Satoshi.
This is being phased out as-and-when affected code is touched during other changes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can see some (but not all) of these subsystems being initialized in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1113" target="_blank" rel="noopener"><em>init.cpp#AppInitMain()</em></a>.</p>
</div>
<div class="paragraph">
<p>There is a recent preference to favour python over bash/sh for scripting, e.g. for linters, but many shell scripts remain in place for CI and contrib/ scripts.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoind_overview"><a class="link" href="#_bitcoind_overview">bitcoind overview</a></h3>
<div class="paragraph">
<p>The following diagram gives a brief overview of how some of the major components in bitcoind are related.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This diagram is <strong>not</strong> exhaustive and includes simplifications.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
dashed lines indicate optional components
</td>
</tr>
</table>
</div>
<div id="bitcoind-overview" class="literalblock">
<div class="title"><code>bitcoind</code> overview</div>
<div class="content">
<pre>flowchart LR
    bitcoind
    RPCServer -.-&gt; bitcoind
    RESTServer -.-&gt; bitcoind
    Node -----&gt; bitcoind
    AddrMan --&gt; Node
    CConnman --&gt; Node
    Interfaces::Chain --&gt; Node
    ChainstateManager --&gt; Node
    NetGroupManager --&gt; AddrMan
    CTxMemPool --&gt; Node
    PeerManager --&gt; Node
    Wallet -.-&gt; bitcoind
    ScriptPubKeyMan --&gt; Wallet
    WalletDatabase --&gt; Wallet
    sqlite -.-&gt; WalletDatabase
    BDB -.-&gt; WalletDatabase
    Logger --&gt; bitcoind
    ZMQ -.-&gt; bitcoind
    BlockManager --&gt; ChainstateManager
    LevelDB --&gt; BlockManager</pre>
</div>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 2. Brief description of components in <a href="#bitcoind-overview"><code>bitcoind</code> overview</a></caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Simplified description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AddrMan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manage peers' network addresses</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CConnman</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manage network connections to peers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Interfaces::Chain</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Give clients access to chain state, fee rate estimates, notifications and allow tx submission</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ChainstateManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An interface for interacting with 1 or 2 chainstates (1. IBD-verified, 2. optional snapshot)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NetGroupManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manage net groups. Ensure we don&#8217;t connect to multiple nodes in the same ASN bucket</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CTxMemPool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validate and store (valid) transactions which may be included in the next block</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PeerManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manage peer state and interaction e.g. processing messages, fetching blocks &amp; removing for misbehaviour</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BlockManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maintains a tree of blocks on disk (via LevelDB) to determine most-work tip</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScriptPubKeyMan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manages <code>scriptPubKeys</code> in a wallet. Can give out new <code>scriptPubKeys</code> as well as call into a <code>SigningProvider</code> to sign transactions</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_bitcoin_cli_overview"><a class="link" href="#_bitcoin_cli_overview"><code>bitcoin-cli</code> overview</a></h3>
<div class="paragraph">
<p>The following diagram gives a brief overview of the major components in bitcoin-cli.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This diagram is <strong>not</strong> exhaustive and includes simplifications.
</td>
</tr>
</table>
</div>
<div id="bitcoin-cli-overview-chart" class="literalblock">
<div class="title"><code>bitcoin-cli</code> overview</div>
<div class="content">
<pre>flowchart LR
    BaseRequestHandler["BaseRequestHandler()"]
    AddrInfoRequestHandler["AddrInfoRequestHandler()"]
    ConnectAndCallRPC["ConnectAndCallRPC()"]
    GetInfoRequestHandler["GetInfoRequestHandler()"]
    NetInfoRequestHandler["NetInfoRequestHandler()"]
    GenerateToAddressHandler["GenerateToAddressHandler()"]
    DefaultRequestHandler["DefaultRequestHandler()"]
    BaseRequestHandler --&gt; AddrInfoRequestHandler --&gt; ConnectAndCallRPC
    BaseRequestHandler --&gt; GetInfoRequestHandler --&gt; ConnectAndCallRPC
    BaseRequestHandler --&gt; NetInfoRequestHandler --&gt; ConnectAndCallRPC
    BaseRequestHandler --&gt; GenerateToAddressHandler --&gt; ConnectAndCallRPC
    BaseRequestHandler --&gt; DefaultRequestHandler --&gt; ConnectAndCallRPC
    ConnectAndCallRPC &lt;---&gt; bitcoin-cli
    ArgsManager --&gt; bitcoin-cli</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wallet_structure"><a class="link" href="#_wallet_structure">Wallet structure</a></h3>
<div class="paragraph">
<p>The following diagram gives a brief overview of how the wallet is structured.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This diagram is <strong>not</strong> exhaustive and includes simplifications.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
dashed lines indicate optional components
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="title">Wallet structure overview</div>
<div class="content">
<pre>flowchart LR
    ScriptPubKeyMan --&gt; DescriptorScriptPubKeyMan
    ScriptPubKeyMan --&gt; LegacyScriptPubKeyMan
    subgraph Descriptor or Legacy wallet
    DescriptorScriptPubKeyMan
    LegacyScriptPubKeyMan
    end
    DescriptorScriptPubKeyMan -.-&gt; CWallet
    LegacyScriptPubKeyMan -.-&gt; CWallet
    Interfaces::Chain --&gt; CWallet
    WalletDatabase --&gt; CWallet
    cs_wallet{{cs_wallet}} ---&gt; CWallet

    subgraph BDB or sqlite database
    BDB
    sqlite
    end
    BDB -.-&gt; WalletDatabase
    sqlite -.-&gt; WalletDatabase

    SigningProvider --&gt; ScriptPubKeyMan
    WalletStorage --&gt; ScriptPubKeyMan
    Scripts --&gt; ScriptPubKeyMan
    Keys --&gt; ScriptPubKeyMan</pre>
</div>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 3. Brief description of components</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Simplified description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WalletDatabase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a single wallet. Handles reads and writes to disk</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScriptPubKeyMan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base class for the below SPKM classes to override before being used by <code>CWallet</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DescriptorScriptPubKeyMan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A SPKM for <a href="https://github.com/bitcoin/bitcoin/pull/16528" target="_blank" rel="noopener">descriptor-based</a> wallets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LegacyScriptPubKeyMan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A SPKM for legacy wallets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SigningProvider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An interface for a <code>KeyStore</code> to sign transactions from</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Interfaces::Chain</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Give clients access to chain state, fee rate estimates, notifications and allow tx submission</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cs_wallet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The primary wallet lock, held for atomic wallet operations</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_tests_overview"><a class="link" href="#_tests_overview">Tests overview</a></h3>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 4. Tests overview</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tool</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unit tests</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>make check</code> or <code>./src/test_bitcoin</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">functional tests</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>test/functional/test_runner.py</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lint checks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>test/lint/all-lint.py</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fuzz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See the <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/fuzzing.md" target="_blank" rel="noopener">documentation</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">util tests</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>test/util/test_runner.py</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Bitcoin Core is also introducing (functional) "stress tests" which challenge the program via interruptions and missing files to ensure that we fail gracefully, e.g. the tests introduced in <a href="https://github.com/bitcoin/bitcoin/pull/23289" target="_blank" rel="noopener">PR#23289</a>.</p>
</div>
<div class="sect3">
<h4 id="_test_directory_structure"><a class="link" href="#_test_directory_structure">Test directory structure</a></h4>
<div class="paragraph">
<p>The following diagram gives a brief overview of how the tests are structured within the source directory.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This diagram is <strong>not</strong> exhaustive and includes simplifications.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
dashed lines indicate optional components
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>fuzz_targets</code> themselves are located in the <code>test</code> folder, however the fuzz tests are run via the <code>test_runner</code> in src/test so we point fuzz to there.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>qa_assets</code> are found in a <a href="https://github.com/bitcoin-core/qa-assets" target="_blank" rel="noopener">separate</a> repo altogether, as they are quite large (~3.5GB repo size and ~13.4GB on clone).
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="title">Test directory Structure</div>
<div class="content">
<pre>flowchart LR
    TR1[test_runner]
    functional --&gt; test
    lint --&gt; test
    util --&gt; test
    test_framework --&gt; functional
    TR1 --&gt; functional

    TR2["test_runner (fuzz)"]
    fuzz_targets --&gt; fuzz
    fuzz --&gt; src/test
    libFuzzer -.-&gt; fuzz
    TR2 --&gt; fuzz
    qa-assets -.-&gt; fuzz
    unit --&gt; src/test
    Boost --&gt; unit
    test_bitcoin --&gt; unit

    classDef types fill:green,color:white,stroke:green;
    class functional,lint,util,fuzz,unit types</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_test_coverage"><a class="link" href="#_test_coverage">Test coverage</a></h4>
<div class="paragraph">
<p>Bitcoin Core&#8217;s test coverage reports can be found <a href="https://marcofalke.github.io/btc_cov/" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_threads"><a class="link" href="#_threads">Threads</a></h3>
<div class="paragraph">
<p>The <code>main()</code> function starts the main bitcoind process thread, usefully named <code>bitcoind</code>.
All subsequent threads are currently started as children of the <code>bitcoind</code> thread, although this is not an explicit design requirement.</p>
</div>
<div class="paragraph">
<p>The Bitcoin Core Developer <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#threads=" target="_blank" rel="noopener">docs</a> contains a section on threads, which is summarised below in two tables, one for net threads, and one for other threads.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 5. Non-net threads</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bitcoind</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>main()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Responsible for starting up and shutting down the application, and spawning all sub-threads</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-loadblk</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadImport</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loads blocks from <code>blk*.dat</code> files or <code>-loadblock=&lt;file&gt;</code> on startup</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-scriptch.x</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadScriptCheck</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parallel script validation threads for transactions in blocks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-http</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadHTTP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Libevent thread to listen for RPC and REST connections</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-httpworker.x</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartHTTPServer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP worker threads. Threads to service RPC and REST requests</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-txindex.x</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadSync</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indexer threads. One thread per indexer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-scheduler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SchedulerThread</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Does asynchronous background tasks like dumping wallet contents, dumping <code>addrman</code> and running asynchronous <code>validationinterface</code> callbacks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-torcontrol</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TorControlThread</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Libevent thread for tor connections</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_net_threads"><a class="link" href="#_net_threads">Net threads</a></h4>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 6. Net threads</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-msghand</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadMessageHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application level message handling (sending and receiving). Almost all <code>net_processing</code> and validation logic runs on this thread</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-dnsseed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadDNSAddressSeed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loads addresses of peers from the <code>ThreadDNS</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-upnp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadMapPort</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Universal plug-and-play startup/shutdown</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-net</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadSocketHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sends/Receives data from peers on port 8333</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-addcon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadOpenAddedConnections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opens network connections to added nodes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-opencon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadOpenConnections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiates new connections to peers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>b-i2paccept</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ThreadI2PAcceptIncoming</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Listens for and accepts incoming I2P connections through the I2P SAM proxy</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_thread_debugging"><a class="link" href="#_thread_debugging">Thread debugging</a></h4>
<div class="paragraph">
<p>In order to debug a multi-threaded application like bitcoind using gdb you will need to enable following child processes.
Below is shown the contents of a file <code>threads.brk</code> which can be sourced into gdb using <code>source threads.brk</code>, before you start debugging bitcoind.
The file also loads break points where new threads are spawned.</p>
</div>
<div class="listingblock">
<div class="title">threads.brk</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="bash">set follow-fork-mode child
break node::ThreadImport
break StartScriptCheckWorkerThreads
break ThreadHTTP
break StartHTTPServer
break ThreadSync
break SingleThreadedSchedulerClient
break TorControlThread
break ThreadMessageHandler
break ThreadDNSAddressSeed
break ThreadMapPort
break ThreadSocketHandler
break ThreadOpenAddedConnections
break ThreadOpenConnections
break ThreadI2PAcceptIncoming</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_library_structure"><a class="link" href="#_library_structure">Library structure</a></h3>
<div class="paragraph">
<p>Bitcoin Core compilation outputs a number of libraries, some which are designed to be used internally, and some which are designed to be re-used by external applications.
The internally-used libraries generally have unstable APIs making them unsuitable for re-use, but <code>libbitcoin_consensus</code> and <code>libbitcoin_kernel</code> are designed to be re-used by external applications.</p>
</div>
<div class="paragraph">
<p>Bitcoin Core has a <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/design/libraries.md" target="_blank" rel="noopener">guide</a> which describes the various libraries, their conventions, and their various dependencies.
The dependency graph is shown below for convenience, but may not be up-to-date with the Bitcoin Core document.</p>
</div>
<div id="library-dependency-graph" class="literalblock">
<div class="title">Bitcoin library dependency graph</div>
<div class="content">
<pre>flowchart TB
    bitcoin-wallet --&gt; libbitcoin_wallet_tool
    bitcoin-wallet --&gt; libbitcoin_wallet

    bitcoin-qt ---&gt; libbitcoin_wallet
    bitcoin-qt ---&gt; libbitcoinqt
    bitcoin-qt ---&gt; libbitcoin_node

    bitcoind ---&gt; libbitcoin_wallet
    bitcoind --&gt; libbitcoin_node

    bitcoin-cli ---&gt; libbitcoin-cli

    libbitcoin_wallet_tool --&gt; libbitcoin_wallet
    libbitcoin_wallet_tool --&gt; libbitcoin_util

    libbitcoin-cli --&gt; libbitcoin_common
    libbitcoin-cli --&gt; libbitcoin_util

    libbitcoin_node --&gt; libbitcoin_common
    libbitcoin_node --&gt; libbitcoin_consensus
    libbitcoin_node --&gt; libbitcoin_kernel
    libbitcoin_node --&gt; libbitcoin_util

    libbitcoinqt --&gt; libbitcoin_util
    libbitcoinqt --&gt; libbitcoin_common

    libbitcoin_wallet --&gt; libbitcoin_util
    libbitcoin_wallet --&gt; libbitcoin_common

    libbitcoin_common --&gt; libbitcoin_util
    libbitcoin_common --&gt; libbitcoin_consensus

    libbitcoin_kernel --&gt; libbitcoin_consensus
    libbitcoin_kernel --&gt; libbitcoin_util

    classDef types fill:green,color:white,stroke:green;
    class bitcoin-wallet,bitcoind,bitcoin-cli,bitcoin-qt types</pre>
</div>
</div>
<div class="paragraph">
<p>It follows that API changes to the libraries which are internally-facing can be done slightly easier than for libraries with externally-facing APIs, for which more care for compatibility must be taken.</p>
</div>
</div>
<div class="sect2">
<h3 id="_source_code_organization"><a class="link" href="#_source_code_organization">Source code organization</a></h3>
<div class="paragraph">
<p>Issue <a href="https://github.com/bitcoin/bitcoin/issues/15732" target="_blank" rel="noopener">#15732</a> describes how the Bitcoin Core project is striving to organize libraries and their associated source code, copied below for convenience:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Here is how I am thinking about the organization:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>libbitcoin_server.a</code>, <code>libbitcoin_wallet.a</code>, and <code>libbitcoinqt.a</code> should all be terminal dependencies. They should be able to depend on other symbols in other libraries, but no other libraries should depend on symbols in them (and they shouldn&#8217;t depend on each other).</p>
</li>
<li>
<p><code>libbitcoin_consensus.a</code> should be a standalone library that doesn&#8217;t depend on symbols in other libraries mentioned here</p>
</li>
<li>
<p><code>libbitcoin_common.a</code> and <code>libbitcoin_util.a</code> seem very interchangeable right now and mutually depend on each other. I think we should either merge them into one library, or create a new top-level <code>src/common/</code> directory complementing <code>src/util/</code>, and start to distinguish general purpose utility code (like argument parsing) from bitcoin-specific utility code (like formatting bip32 paths and using ChainParams). Both these libraries can be depended on by <code>libbitcoin_server.a</code>, <code>libbitcoin_wallet.a</code>, and <code>libbitcoinqt.a</code>, and they can depend on <code>libbitcoin_consensus.a</code>. If we want to split util and common up, as opposed to merging them together, then util shouldn&#8217;t depend on libconsensus, but common should.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Over time, I think it&#8217;d be nice if source code organization reflected library organization . I think it&#8217;d be nice if all <code>libbitcoin_util</code> source files lived in <code>src/util</code>, all <code>libbitcoin_consensus.a</code> source files lived in <code>src/consensus</code>, and all <code>libbitcoin_server.a</code> code lived in <code>src/node</code> (and maybe the library was called <code>libbitcoin_node.a</code>).</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You can track the progress of these changes by following links from the issue to associated PRs.</p>
</div>
<div class="paragraph">
<p>The <code>libbitcoin-kernel</code> <a href="https://github.com/bitcoin/bitcoin/issues/24303" target="_blank" rel="noopener">project</a> will provide further clean-ups and improvements in this area.</p>
</div>
<div class="paragraph">
<p>If you want to explore for yourself which sources certain libraries require on the current codebase, you can open the file <code>src/Makefile.am</code> and search for <code>_SOURCES</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_userspace_files"><a class="link" href="#_userspace_files">Userspace files</a></h3>
<div class="paragraph">
<p>Bitcoin Core stores a number of files in its data directory ($DATADIR) at runtime.</p>
</div>
<div class="sect3">
<h4 id="_block_and_undo_files"><a class="link" href="#_block_and_undo_files">Block and undo files</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1">$DATADIR/blocks/blk*.dat</dt>
<dd>
<p>Stores raw network-format block data in order received.</p>
</dd>
<dt class="hdlist1">$DATADIR/blocks/rev*.dat</dt>
<dd>
<p>Stores block "undo" data in order processed.</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>You can see blocks as 'patches' to the chain state (they consume some unspent outputs, and produce new ones), and see the undo data as reverse patches. They are necessary for rolling back the chainstate, which is necessary in case of reorganisations.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Pieter Wuille<br>
<cite><a href="https://bitcoin.stackexchange.com/questions/11104/what-is-the-database-for?rq=1">stackexchange</a></cite>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_indexes"><a class="link" href="#_indexes">Indexes</a></h4>
<div class="paragraph">
<p>With data from the raw block* and rev* files, various LevelDB indexes can be built.
These indexes enable fast lookup of data without having to rescan the entire block chain on disk.</p>
</div>
<div class="paragraph">
<p>Some of these databases are mandatory and some of them are optional and can be enabled using run-time configuration flags.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Block Index</dt>
<dd>
<p>Filesystem location of blocks + some metadata</p>
</dd>
<dt class="hdlist1">Chainstate Index</dt>
<dd>
<p>All current UTXOs + some metadata</p>
</dd>
<dt class="hdlist1">Tx Index</dt>
<dd>
<p>Filesystem location of all transactions by txid</p>
</dd>
<dt class="hdlist1">Block Filter Index</dt>
<dd>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki">BIP157</a> filters, hashes and headers</p>
</dd>
<dt class="hdlist1">Coinstats Index</dt>
<dd>
<p>UTXO set <a href="https://github.com/bitcoin/bitcoin/blob/b3f866a8dfd652b6339b79124843e58bd0bf3013/src/index/coinstatsindex.h#L26-L37">statistics</a></p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Location</th>
<th class="tableblock halign-left valign-top">Optional</th>
<th class="tableblock halign-left valign-top">Class</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Block Index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>$DATADIR/blocks/index</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BlockIndex</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chainstate Index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>$DATADIR/chainstate</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Chainstate</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tx Index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>$DATADIR/indexes/txindex</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TxIndex</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Block Filter Index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>$DATADIR/indexes/blockfilter/&lt;filter name&gt;</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BlockFilterIndex</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Coinstats Index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>$DATADIR/indexes/coinstats</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CoinstatsIndex</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_deep_technical_dive"><a class="link" href="#_deep_technical_dive">Deep technical dive</a></h3>
<div class="paragraph">
<p>lsilva01 has written a deep technical dive into the architecture of Bitcoin Core as part of the Bitcoin Core Onboarding Documentation in <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc" target="_blank" rel="noopener">Bitcoin Architecture</a>.</p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve gained some insight into the architecture of the program itself you can learn further details about which code files implement which functionality from the <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.1_regions.asciidoc" target="_blank" rel="noopener">Bitcoin Core regions</a> document.</p>
</div>
<div class="paragraph">
<p>James O&#8217;Beirne has recorded 3 videos which go into detail on how the codebase is laid out, how the build system works, what developer tools there are, as well as what the primary function of many of the files in the codebase are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://www.youtube.com/watch?v=J1Ru8V36z_Y" target="_blank" rel="noopener">Architectural tour of Bitcoin Core (part 1 of 3)</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=RVWcUnpZX4E" target="_blank" rel="noopener">Architectural tour of Bitcoin Core (part 2 of 3)</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=UiD5DZU9Zp4" target="_blank" rel="noopener">Architectural tour of Bitcoin Core (part 3 of 3)</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>ryanofsky has written a handy <a href="https://github.com/ryanofsky/bitcoin/blob/pr/libs/doc/design/libraries.md" target="_blank" rel="noopener">guide</a> covering the different libraries contained within Bitcoin Core, along with some of their conventions and a dependency graph for them.
Generally speaking, the desire is for the Bitcoin Core project to become more modular and less monolithic over time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_subtrees"><a class="link" href="#_subtrees">Subtrees</a></h3>
<div class="paragraph">
<p>Several parts of the repository (LevelDB, crc32c, secp256k1 etc.) are subtrees of software maintained elsewhere.</p>
</div>
<div class="paragraph">
<p>Some of these are maintained by active developers of Bitcoin Core, in which case changes should go directly upstream without being PRed directly against the project.
They will be merged back in the next subtree merge.</p>
</div>
<div class="paragraph">
<p>Others are external projects without a tight relationship with our project.</p>
</div>
<div class="paragraph">
<p>There is a tool in <code>test/lint/git-subtree-check.sh</code> to check a subtree directory for consistency with its upstream repository.</p>
</div>
<div class="paragraph">
<p>See the full <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#subtrees" target="_blank" rel="noopener">subtrees</a> documentation for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementation_separation"><a class="link" href="#_implementation_separation">Implementation separation</a></h3>
<div class="paragraph">
<p>Many of the classes found throughout the codebase use the PIMPL technique to separate their implementation from the external representation.
See <a href="#pimpl-technique">PIMPL technique</a> in the Appendix for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_consensus_validation"><a class="link" href="#_consensus_validation">Consensus &amp; validation</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the fundamental concepts underlying bitcoin is that nodes on the network are able to maintain decentralized consensus on the ordering of transactions in the system.</p>
</div>
<div class="paragraph">
<p>The primary mechanism at work is that all nodes validate every block, and every transaction contained within that block, against their own copy of the consensus rules.
The secondary mechanism is that in the event of a discrepancy between two competing chain tips nodes should follow the chain with the most cumulative proof-of-work.
The result is that all honest nodes in the network will eventually converge onto a single, canonical, valid chain.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If all nodes do not compute consensus values identically (including edge cases) a chainsplit will result.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information on how the bitcoin networks' decentralized consensus mechanism works see the Mastering Bitcoin section on <a href="https://github.com/bitcoinbook/bitcoinbook/tree/develop/ch10.asciidoc#decentralized-consensus" target="_blank" rel="noopener">decentralized consensus</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In Bitcoin Core there are an extra level of validation checks applied to incoming transactions in addition to consensus checks called "policy" which have a slightly different purpose, see <a href="#_consensus_vs_policy">Consensus vs Policy</a> for more information on the differences between the two.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Consensus</dt>
<dd>
<p>A collection of functions and variables which <strong>must</strong> be computed identically to all <a href="https://bitnodes.io/nodes/" target="_blank" rel="noopener">other</a> nodes on the network in order to remain in consensus and therefore on the main chain.</p>
</dd>
<dt class="hdlist1">Validation</dt>
<dd>
<p>Validation of blocks, transactions and scripts, with a view to permitting them to be added to either the blockchain (must pass consensus checks) or our local mempool (must pass policy checks).</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_consensus_in_bitcoin_core"><a class="link" href="#_consensus_in_bitcoin_core">Consensus in Bitcoin Core</a></h3>
<div class="paragraph">
<p>Naturally one might assume that all code related to consensus could be found in the <em>src/consensus/</em> directory, however this is not entirely the case.
Components of consensus-related code can be found across the Bitcoin Core codebase in a number of files, including but not limited to:</p>
</div>
<div id="consensus-components" class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="listing"> bitcoin
   src
     consensus
     script
      interpreter.cpp
     validation.h
     validation.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consensus-critical functions can also be found in proximity to code which could affect whether a node considers a transaction or block valid.
This could extend to, for example, block storage <a href="#_database_consensus">database</a> code.</p>
</div>
<div class="paragraph">
<p>An abbreviated list of some of the more notable consensus functions and variables is shown below.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Some consensus functions and variables</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">File</th>
<th class="tableblock halign-left valign-top">Objects</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/amount.h</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COIN</code>, <code>MAX_MONEY</code>, <code>MoneyRange()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/consensus.h</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BLOCK{SIZE|WEIGHT|SIGOPS_COST}</code>, <code>COINBASE_MATURITY</code>, <code>WITNESS_SCALE_FACTOR</code>, <code>MIN_TX_WEIGHT</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/merkle.{h|cpp}</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ComputeMerkleRoot(),</code> <code>BlockMerkleRoot(),</code> <code>BlockWitnessMerkleRoot()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/params.h</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BuriedDeployment</code>, <code>Params</code>(buried blocks which are valid but known to fail default script verify checks, BIP height activations, PoW params)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/tx_check.{h|cpp}</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CheckTransaction()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/tx_verify.{h|cpp}</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CheckTxInputs(),</code> <code>Get{Legacy}SigOpCount()</code>, <code>IsFinalTx(),</code> <code>SequenceLock(s)()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>src/consensus/validation.h</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TxValidationResult</code> (validation result reason), <code>BlockValidationResult</code> (validation result reason), <code>ValidationState</code>, <code>Get{Transaction|Block|TransactionInput}Weight()</code></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_consensus_model"><a class="link" href="#_consensus_model">Consensus model</a></h4>
<div class="paragraph">
<p>The consensus model in the codebase can be thought of as a database of the current state of the blockchain.
When a new block is learned about it is processed and the consensus code must determine which block is the current best.
Consensus can be thought of as a function of available information&#8201;&#8212;&#8201;it&#8217;s output is simply a deterministic function of its input.</p>
</div>
<div class="paragraph">
<p>There are a simple set of rules for determining the best block:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Only consider valid blocks</p>
</li>
<li>
<p>Where multiple chains exist choose the one with the most cumulative Proof of Work (PoW)</p>
</li>
<li>
<p>If there is a tie-breaker (same height and work), then use first-seen</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The result of these rules is a tree-like structure from genesis to the current day, building on only valid blocks.</p>
</div>
<div class="paragraph">
<p>Whilst this is easy-enough to reason about in theory, the implementation doesn&#8217;t work exactly like that.
It must consider state, do I go forward or backwards for example.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validation_in_bitcoin_core"><a class="link" href="#_validation_in_bitcoin_core">Validation in Bitcoin Core</a></h3>
<div class="paragraph">
<p>Originally consensus and validation were much of the same thing, in the same source file.
However splitting of the code into strongly delineated sections was never fully completed, so validation.* files still hold some consensus codepaths.</p>
</div>
</div>
<div class="sect2">
<h3 id="_consensus_vs_policy"><a class="link" href="#_consensus_vs_policy">Consensus vs Policy</a></h3>
<div class="paragraph">
<p>What is the difference between consensus and policy checks?
Both seem to be related to validating transactions.
We can learn a lot about the answer to this question from sdaftuar&#8217;s StackExchange <a href="https://bitcoin.stackexchange.com/questions/100317/what-is-the-difference-between-policy-and-consensus-when-it-comes-to-a-bitcoin-c/100319#100319" target="_blank" rel="noopener">answer</a>.</p>
</div>
<div class="paragraph">
<p>The answer teaches us that policy checks are a superset of validation checks&#8201;&#8212;&#8201; that is to say that a transaction that passes policy checks has implicitly passed consensus checks too.
Nodes perform policy-level checks on all transactions they learn about before adding them to their local mempool.
Many of the policy checks contained in <code>policy</code> are called from inside <code>validation</code>, in the context of adding a new transaction to the mempool.</p>
</div>
</div>
<div class="sect2">
<h3 id="_consensus_and_validation_bugs"><a class="link" href="#_consensus_and_validation_bugs">Consensus and validation bugs</a></h3>
<div class="paragraph">
<p>Consensus and validation bugs can arise both from inside the Bitcoin Core codebase itself, and from external dependencies.
Bitcoin wiki <a href="https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures" target="_blank" rel="noopener">lists</a> some CVE and other Exposures.</p>
</div>
<div class="sect3">
<h4 id="_openssl_consensus_failure"><a class="link" href="#_openssl_consensus_failure">OpenSSL consensus failure</a></h4>
<div class="paragraph">
<p>Pieter Wuille <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-July/009697.html" target="_blank" rel="noopener">disclosed</a> the possibility of a consensus failure via usage of OpenSSL.
The issue was that the OpenSSL signature verification was accepting <strong>multiple</strong> signature serialization formats (for the same signature) as valid.
This effectively meant that a transactions' ID (txid) could be changed, because the signature contributes to the txid hash.</p>
</div>
<details>
<summary class="title">Click to show the code comments related to pubkey signature parsing from <em>pubkey.cpp</em></summary>
<div class="content">
<div class="listingblock">
<div class="title">src/pubkey.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/** This function is taken from the libsecp256k1 distribution and implements
 *  DER parsing for ECDSA signatures, while supporting an arbitrary subset of
 *  format violations.
 *
 *  Supported violations include negative integers, excessive padding, garbage
 *  at the end, and overly long length descriptors. This is safe to use in
 *  Bitcoin because since the activation of BIP66, signatures are verified to be
 *  strict DER before being passed to this module, and we know it supports all
 *  violations present in the blockchain before that point.
 */
int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {
    // ...
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>There were a few cases to consider:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>signature length descriptor malleation (extension to 5 bytes)</p>
</li>
<li>
<p>third party malleation: signature may be slightly "tweaked" or padded</p>
</li>
<li>
<p>third party malleation: negating the <code>S</code> value of the signature</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the length descriptor case there is a higher risk of causing a consensus-related chainsplit.
The sender can create a normal-length valid signature, but which uses a 5 byte length descriptor meaning that it might not be accepted by OpenSSL on all platforms.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Note that the sender can also "malleate" the signature whenever they like, by simply creating a new one, but this will be handled differently than a length-descriptor-extended signature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the second case, signature tweaking or padding, there is a lesser risk of causing a consensus-related chainsplit.
However the ability of third parties to tamper with valid transactions may open up off-chain attacks related to Bitcoin services or layers (e.g. Lightning) in the event that they are relying on txids to track transactions.</p>
</div>
<div class="paragraph">
<p>It is interesting to consider the order of the steps taken to fix this potential vulnerability:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First the default policy in Bitcoin Core was altered (via <code>isStandard()</code>) to prevent the software from relaying or accepting into the mempool transactions with non-DER signature encodings.<br>
This was carried out in <a href="https://github.com/bitcoin/bitcoin/pull/2520" target="_blank" rel="noopener">PR#2520</a>.</p>
</li>
<li>
<p>Following the policy change, the strict encoding rules were later enforced by consensus in <a href="https://github.com/bitcoin/bitcoin/pull/5713" target="_blank" rel="noopener">PR#5713</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can see the resulting flag in the script verification enum:</p>
</div>
<div class="listingblock">
<div class="title">src/script/interpreter.h</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
// Evaluating a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) by checksig causes script failure.
// (not used or intended as a consensus rule).
SCRIPT_VERIFY_STRICTENC = (1U &lt;&lt; 1),</code></pre>
</div>
</div>
<details>
<summary class="title">Expand to see where this flag is checked in <em>src/script/interpreter.cpp</em></summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">bool CheckSignatureEncoding(const std::vector&lt;unsigned char&gt; &amp;vchSig, unsigned int flags, ScriptError* serror) {
    // Empty signature. Not strictly DER encoded, but allowed to provide a
    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG
    if (vchSig.size() == 0) {
        return true;
    }
    if ((flags &amp; (SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC)) != 0 &amp;&amp; !IsValidSignatureEncoding(vchSig)) {
        return set_error(serror, SCRIPT_ERR_SIG_DER);
    } else if ((flags &amp; SCRIPT_VERIFY_LOW_S) != 0 &amp;&amp; !IsLowDERSignature(vchSig, serror)) {
        // serror is set
        return false;
    } else if ((flags &amp; SCRIPT_VERIFY_STRICTENC) != 0 &amp;&amp; !IsDefinedHashtypeSignature(vchSig)) {
        return set_error(serror, SCRIPT_ERR_SIG_HASHTYPE);
    }
    return true;
}

bool static CheckPubKeyEncoding(const valtype &amp;vchPubKey, unsigned int flags, const SigVersion &amp;sigversion, ScriptError* serror) {
    if ((flags &amp; SCRIPT_VERIFY_STRICTENC) != 0 &amp;&amp; !IsCompressedOrUncompressedPubKey(vchPubKey)) {
        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);
    }
    // Only compressed keys are accepted in segwit
    if ((flags &amp; SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 &amp;&amp; sigversion == SigVersion::WITNESS_V0 &amp;&amp; !IsCompressedPubKey(vchPubKey)) {
        return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);
    }
    return true;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Do you think this approach&#8201;&#8212;&#8201;first altering policy, followed later by consensus&#8201;&#8212;&#8201;made sense for implementing the changes needed to fix this consensus vulnerability?
Are there circumstances where it might not make sense?</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Having OpenSSL as a consensus-critical dependency to the project was ultimately fixed in <a href="https://github.com/bitcoin/bitcoin/pull/6954" target="_blank" rel="noopener">PR#6954</a> which switched to using the in-house libsecp256k1 library (as a <a href="#_subtrees">subtree</a>) for signature verification.</p>
</div>
</div>
<div class="sect3">
<h4 id="_database_consensus"><a class="link" href="#_database_consensus">Database consensus</a></h4>
<div class="paragraph">
<p>Historically Bitcoin Core used Berkeley DB (BDB) for transaction and block indices.
In 2013 a migration to LevelDB for these indices was included with Bitcoin Core v0.8.
What developers at the time could not foresee was that nodes that were still using BDB, all pre 0.8 nodes, were silently consensus-bound by a relatively obscure BDB-specific database lock counter.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
BDB required a configuration setting for the total number of locks available to the database.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bitcoin Core was interpreting a failure to grab the required number of locks as equivalent to block validation failing.
This caused some BDB-using nodes to mark blocks created by LevelDB-using nodes as invalid and caused a consensus-level chain split.
<a href="https://github.com/bitcoin/bips/tree/master/bip-0050.mediawiki" target="_blank" rel="noopener">BIP 50</a> provides further explanation on this incident.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Although database code is not in close proximity to the <code>/src/consensus</code> region of the codebase it was still able to induce a consensus bug.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>BDB has caused other potentially-dangerous behaviour in the past.
Developer Greg Maxwell <a href="https://btctranscripts.com/greg-maxwell/2015-04-29-gmaxwell-bitcoin-selection-cryptography/#qa" target="_blank" rel="noopener">describes</a> in a Q&amp;A how even the same versions of BDB running on the same system exhibited non-deterministic behaviour which might have been able to initiate chain re-orgs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_an_inflation_bug"><a class="link" href="#_an_inflation_bug">An inflation bug</a></h4>
<div class="paragraph">
<p>This Bitcoin Core <a href="https://bitcoincore.org/en/2018/09/20/notice/" target="_blank" rel="noopener">disclosure</a> details a potential inflation bug.</p>
</div>
<div class="paragraph">
<p>It originated from trying to speed up transaction validation in <code>main.cpp#CheckTransaction()</code> which is now <code>consensus/tx_check.cpp#CheckTransaction()</code>, something which would in theory help speed up IBD (and less noticeably singular/block transaction validation).
The result in Bitcoin Core versions 0.15.x &#8594; 0.16.2 was that a coin that was created in a previous block, could be spent twice in the same block by a miner, without the block being rejected by other Bitcoin Core nodes (of the aforementioned versions).</p>
</div>
<div class="paragraph">
<p>Whilst this bug originates from validation, it can certainly be described as a breach of consensus parameters.
In addition, nodes of version 0.14.x &#8656; <code>node_version</code> &gt;= 0.16.3 would reject inflation blocks, ultimately resulting in a chain split provided that miners existed using both inflation-resistant and inflation-permitting clients.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hard_soft_forks"><a class="link" href="#_hard_soft_forks">Hard &amp; Soft Forks</a></h3>
<div class="paragraph">
<p>Before continuing with this section, ensure that you have a good understanding of what soft and hard forks are, and how they differ.
Some good resources to read up on this further are found in the table below.</p>
</div>
<table class="tableblock frame-all grid-all fit-content stretch">
<caption class="title">Table 8. Hard and soft fork resources</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Title</th>
<th class="tableblock halign-left valign-top">Resource</th>
<th class="tableblock halign-left valign-top">Link</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">What is a soft fork, what is a hard fork, what are their differences?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">StackExchange</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://bitcoin.stackexchange.com/questions/30817/what-is-a-soft-fork-what-is-a-hard-fork-what-are-their-differences" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soft forks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitcoin.it/wiki</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.bitcoin.it/wiki/Softfork" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hard forks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitcoin.it/wiki</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.bitcoin.it/wiki/Hardfork" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soft fork activation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bitcoin Optech</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://bitcoinops.org/en/topics/soft-fork-activation/" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of consensus forks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BitMex research</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://blog.bitmex.com/bitcoins-consensus-forks/" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A taxonomy of forks (BIP99)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/bitcoin/bips/blob/master/bip-0099.mediawiki" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Modern Soft Fork Activation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bitcoin-dev mailing list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-January/017547.html" target="_blank" rel="noopener">link</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chain splits and Resolutions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BitcoinMagazine guest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://bitcoinmagazine.com/technical/guest-post-chain-splits-and-resolutions" target="_blank" rel="noopener">link</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When making changes to Bitcoin Core its important to consider whether they could have any impact on the <strong>consensus rules</strong>, or the interpretation of those rules.
If they do, then the changes will end up being either a soft or hard fork, depending on the nature of the rule change.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
As <a href="#_database_consensus">described</a>, certain Bitcoin Core components, such as the block database can also unwittingly introduce forking behaviour, even though they do not directly modify consensus rules.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some of the components which are known to alter consensus behaviour, and should therefore be approached with caution, are listed in the section <a href="#consensus-components">consensus components</a>.</p>
</div>
<div class="paragraph">
<p>Changes are not made to consensus values or computations without extreme levels of review and necessity.
In contrast, changes such as refactoring can be (and are) made to areas of consensus code, when we can be sure that they will not alter consensus validation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_making_forking_changes"><a class="link" href="#_making_forking_changes">Making forking changes</a></h3>
<div class="paragraph">
<p>There is some debate around whether it&#8217;s preferable to make changes via soft or hard fork.
Each technique has advantages and disadvantages.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 9. Hard vs soft forks for changes</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Advantages</th>
<th class="tableblock halign-left valign-top">Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soft fork</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Backwards compatible</p>
</li>
<li>
<p><strong>Low risk of chain split</strong> in worst case</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Cannot change all values (e.g. block size, money supply)</p>
</li>
<li>
<p>Might require clever programming tricks</p>
</li>
<li>
<p>Might introduce "technical debt" and associated comprehension burden on reviewers and future programmers</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hard fork</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Can change any values you want (e.g. block size, money supply)</p>
</li>
<li>
<p>Might be cleaner (code-wise) and therefore easier to reason about</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Not backwards compatible</p>
<div class="ulist">
<ul>
<li>
<p>Requires all nodes to upgrade in lock-step</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>High risk of chainsplit</strong></p>
</li>
<li>
<p>We have no experience with them</p>
</li>
<li>
<p>Other changes often required</p>
</li>
<li>
<p>See bitcoincore.org for <a href="https://bitcoincore.org/en/2015/12/23/capacity-increases-faq/" target="_blank" rel="noopener">more information</a></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_upgrading_consensus_rules_with_soft_forks"><a class="link" href="#_upgrading_consensus_rules_with_soft_forks">Upgrading consensus rules with soft forks</a></h3>
<div class="paragraph">
<p>When soft-forking in new bitcoin consensus rules it is important to consider how old nodes will interpret the new rules.
For this reason the preferred method historically was to make something (e.g. an unused OPCODE which was to be repurposed) "non-standard" prior to the upgrade.
Making the opcode non-standard has the effect that transaction scripts using it will not be relayed by nodes using this policy.
Once the soft fork is activated policy is amended to make relaying transactions using this opcode standard policy again, so long as they comply with the ruleset of the soft fork.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Soft forking marble statues</div>
<div class="paragraph">
<p>An analogy might be to think of the current consensus ruleset like a big block of marble.
The current rules have already been carved out of it and eventually it will form into a complex statue.</p>
</div>
<div class="paragraph">
<p>As we soft fork new rules into bitcoin we are taking an un-touched area of the marble and carving something new out of it.
Importantly with soft forks we can only ever take parts of the marble <em>away</em>, so we must be considerate about what, where and how much we carve out for any upgrade.</p>
</div>
<div class="paragraph">
<p>There are parts of the statue currently untouched because they&#8217;re reserved for future upgrades.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Using the analogy above, we could think of OP_NOP opcodes as unsculpted areas of marble.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Currently OP_NOP1 and OP_NOP4-NOP_NOP10 remain available for this.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the opcode has been made non-standard we can then sculpt the new rule from the marble and later re-standardize transactions using the opcode so long as they follow the new rule.</p>
</div>
<div class="paragraph">
<p>This makes sense from the perspective of an old, un-upgraded node who we are trying to remain in consensus with.
From their perspective they see an OP_NOP performing (like the name implies) nothing, but not marking the transaction as invalid.
After the soft fork they will <em>still</em> see the (repurposed) OP_NOP apparently doing nothing but also not failing the transaction.</p>
</div>
<div class="paragraph">
<p>However from the perspective of the upgraded node they now have two possible evaluation paths for the OP_NOP: 1) Do nothing (for the success case) and 2) Fail evaluation (for the failure case).
This is summarized in the table below.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 10. Soft forking changes using OP_NOP opcodes</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Before soft fork</th>
<th class="tableblock halign-left valign-top">After soft fork</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1) Nothing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1) Nothing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Upgraded Node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1) Nothing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1) Nothing (soft forked rule evaluation success)<br>
2) Mark transaction invalid (soft forked rule evaluation failure)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You may notice here that there is still room for discrepancy; a miner who is not upgraded could possibly include transactions in a block which were valid according to legacy nodes, but invalid according to upgraded nodes.
If this miner had any significant hashpower this would be enough to initiate a chainsplit, as upgraded miners would not follow this tip.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Selecting upgrade activation times</div>
<div class="paragraph">
<p>Originally Satoshi used height-based upgrade points for activating soft forks.
The bitcoin network was so small and concentrated, and Satoshi could dictate the height quite easily, that this worked OK in that era.</p>
</div>
<div class="paragraph">
<p>After Satoshi left attempts were made to make the activation point a more predictable moment in <em>time</em>; with the intent on assisting engineers and services who relied on knowing when the upgrade was likely to activate (as wall time).
For this reason BIP16 and BIP30 were activated on a (block) timestamp, after miners had signalled readiness for the upgrade in their coinbase transactions.</p>
</div>
<div class="paragraph">
<p>The concept of miner activated soft forks (MASF) were invented with <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki" target="_blank" rel="noopener">BIP34</a> which said that every coinbase transaction needed to include the (block) height as the first item in its scriptSig, along with an increased block version number.
The block height requirement had the effect that no two coinbase transactions could have the same txid, which was previously possible (see <a href="https://blockstream.info/block/00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e" target="_blank" rel="noopener">1</a> and <a href="https://blockstream.info/block/00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721" target="_blank" rel="noopener">2</a> for example).
The increased version number was accompanied by rules which <a href="https://github.com/bitcoin/bitcoin/pull/1526/commits" target="_blank" rel="noopener">stipulated</a> a form of miner readiness signalling, which could avoid a diktat from any individual about what time a particular upgrade should be activated.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The UTXO in the second of those two blocks, along with a second block also containing a duplicate coinbase txid have a <a href="https://github.com/bitcoin/bitcoin/commit/ab91bf39b7c11e9c86bb2043c24f0f377f1cf514" target="_blank" rel="noopener">special carve-out</a> in the code to enable them to pass validation.</p>
</div>
<div class="paragraph">
<p>Unfortunately though the second UTXO effectively overwrote the first in the UTXO set, so in both cases 50 BTC was lost from the spendable supply.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>MASF was used for BIP65 and BIP66.
A summary of the mechanism is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If 750/1000 blocks signal this new version number then the new rule is active.</p>
</li>
<li>
<p>At 950/1000 you <strong>must</strong> signal.</p>
<div class="ulist">
<ul>
<li>
<p>Forcibly kick the last 5% stragglers out.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, even using miner signalling for BIP16 had already caused drama, as the idea of activation based on miner signalling was interpreted as a vote (by only miners), rather than what it was, which was miners saying "yes, I am ready for the upgrade".</p>
</div>
<div class="paragraph">
<p>When upgrading via soft fork we want everyone to be on the same page to minimize the risk of a chainsplit and miner signalling was deemed the best method we had to achieve rough consensus on this.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Whenever we want to change the consensus rules, this presents a serious problem because we dont really want to just force new rules on the network. Theres no central authority that can do this really. We need to have a way for the network to adapt to the new rules, decide whether or not it wants to adjust to these rules, and to make sure that everyone still ends up agreeing in the end.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Eric Lombrozo<br>
<cite>Bitcoin Magazine</cite>
</div>
</div>
<div class="paragraph">
<p>In the end bitcoin developers concluded that MASF indeed had potential for centralization and so produced the <a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki" target="_blank" rel="noopener">BIP9</a> specification with which to use for future upgrades.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Repurposing OP_NOPs does have its limitations.
First and foremost they cannot manipulate the stack, as this is something that un-upgraded nodes would not expect or validate identically.
Getting rid of the OP_DROP requirement when using repurposed OP_NOPs would require a hard fork.</p>
</div>
<div class="paragraph">
<p>Examples of soft forks which re-purposed OP_NOPs include CLTV and CSV.
Ideally these operations would remove the subsequent object from the stack when they had finished processing it, so you will often see them followed by OP_DROP which removes the object, for example in the script used for the <code>to_local</code> output in a lightning commitment transaction:</p>
</div>
<div class="listingblock">
<div class="title">Lightning <a href="https://github.com/lightning/bolts/blob/master/03-transactions.md#to_local-output" target="_blank" rel="noopener">commitment transaction</a> output</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="text">OP_IF
    # Penalty transaction
    &lt;revocationpubkey&gt;
OP_ELSE
    `to_self_delay`
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    &lt;local_delayedpubkey&gt;
OP_ENDIF
OP_CHECKSIG</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other limitations associated with repurposing OP_NOPs, and ideally bitcoin needed a better upgrade system&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_segwit_upgrade"><a class="link" href="#_segwit_upgrade">SegWit upgrade</a></h4>
<div class="paragraph">
<p>SegWit was the first attempt to go beyond simply repurposing OP_NOPs for upgrades.
The idea was that the <code>scriptPubKey</code>/<code>redeemScript</code> would consist of a 1 byte push opcode (0-16) followed by a data push between 2 and 40 bytes.
The value of the first push would represent the version number, and the second push the <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program" target="_blank" rel="noopener">witness program</a>.
If the conditions to interpret this as a SegWit script were matched, then this would be followed by a <code>witness</code>, whose data varied on whether this was a P2WPKH or P2WSH witness program.</p>
</div>
<div class="paragraph">
<p>Legacy nodes, who would not have the witness data, would interpret this output as <code>anyonecanspend</code> and so would be happy to validate it, whereas upgraded nodes could validate it using the additional <code>witness</code> against the new rules.
To revert to the statue analogy this gave us the ability to work with a new area of the marble which was entirely untouched.</p>
</div>
<div class="paragraph">
<p>The addition of a versioning scheme to SegWit was a relatively late addition which stemmed from noticing that, due to the CLEANSTACK policy rule which required exactly 1 true element to remain on the stack after execution, SegWit outputs would be of the form <code>OP_N + DATA</code>.
With SegWit we wanted a compact way of creating a new output which didn&#8217;t have any consensus rules associated with it, yet had lots of freedom, was ideally already non-standard, and was permitted by CLEANSTACK.</p>
</div>
<div class="paragraph">
<p>The solution was to use two pushes: according to old nodes there are two elements, which was non-standard.
The first push must be at least one byte, so we can use one of the <code>OP_N</code> opcodes, which we then interpret as the SegWit version.
The second is the data we have to push.</p>
</div>
<div class="paragraph">
<p>Whilst this immediately gave us new upgrade paths via SegWit versions Taproot (SegWit version 1) went a step further and declared <em>new opcodes inside of SegWit</em>, also evaluated as <code>anyonecanspend</code> by nodes that don&#8217;t support SegWit, giving us yet more soft fork upgradability.
These opcodes could in theory be used for anything, for example if there was ever a need to have a new consensus rule on 64 bit numbers we could use one of these opcodes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fork_wish_lists"><a class="link" href="#_fork_wish_lists">Fork wish lists</a></h3>
<div class="paragraph">
<p>There are a number of items that developers have had on their wish lists to tidy up in future fork events.</p>
</div>
<div class="paragraph">
<p>An <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016714.html" target="_blank" rel="noopener">email</a> from Matt Corallo with the subject "The Great Consensus Cleanup" described a "wish list" of items developers were keen to tidy up in a future soft fork.</p>
</div>
<div class="paragraph">
<p>The Hard Fork Wishlist is described on this en.bitcoin.it/wiki <a href="https://en.bitcoin.it/wiki/Hardfork_Wishlist" target="_blank" rel="noopener">page</a>.
The rationale for collecting these changes together, is that if backwards-incompatible (hard forking) changes are being made, then we "might as well" try and get a few in at once, as these events are so rare.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_core_consensus_specification"><a class="link" href="#_bitcoin_core_consensus_specification">Bitcoin core consensus specification</a></h3>
<div class="paragraph">
<p>A common question is where the bitcoin protocol is documented, i.e. specified.
However bitcoin does not have a formal specification, even though many ideas have some specification (in <a href="#_bips">BIPs</a>) to aid re-implementation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The requirements to be compliant with "the bitcoin spec" are to be bug-for-bug compatible with the Bitcoin Core implementation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The reasons for Bitcoin not having a codified specification are historical; Satoshi never released one.
Instead, in true "Cypherpunks write code" style and after releasing a general whitepaper, they simply released the first client.
This client existed on it&#8217;s own for the best part of two years before others sought to re-implement the rule-set in other clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/libbitcoin/libbitcoin-system/commit/9dea4682bf0e4247f3c4cb8a6c140ade61bf7df7" target="_blank" rel="noopener">libbitcoin</a></p>
</li>
<li>
<p><a href="https://github.com/bitcoinj/bitcoinj/commit/d1036b101f01b7ab79fc3e10e5199f80f478674d" target="_blank" rel="noopener">BitcoinJ</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A forum <a href="https://bitcointalk.org/index.php?topic=195.msg1611#msg1611" target="_blank" rel="noopener">post</a> from Satoshi in June 2010 had however previously discouraged alternative implementations with the rationale:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>I don&#8217;t believe a second, compatible implementation of Bitcoin will ever be a good idea.  So much of the design depends on all nodes getting exactly identical results in lockstep that a second implementation would be a menace to the network.  The MIT license is compatible with all other licenses and commercial uses, so there is no need to rewrite it from a licensing standpoint.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Satoshi Nakamoto
</div>
</div>
<div class="paragraph">
<p>It is still a point of contention amongst some developers in the community, however the fact remains that if you wish to remain in consensus with the majority of (Bitcoin Core) nodes on the network, you must be <em>exactly</em> bug-for-bug compatible with Bitcoin Core&#8217;s consensus code.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If Satoshi <em>had</em> launched Bitcoin by providing a specification, could it have ever been specified well-enough to enable us to have multiple node implementations?
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One mechanism often employed by those who want to run custom node software is to position an up-to-date Bitcoin Core node to act as a "gateway" to the network.
Internally your own node can then make a single connection to this Bitcoin Core node.
This means that your custom internal node will now only receive transactions and blocks which have passed Bitcoin Core&#8217;s consensus (or policy) checks, allowing you to be sure that your custom node is not accepting objects which could cause you to split onto a different chain tip.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_libbitcoinconsensus"><a class="link" href="#_libbitcoinconsensus">libbitcoinconsensus</a></h3>
<div class="paragraph">
<p>The libbitcoinconsensus library is described in the 0.10.0 release notes:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Consensus library</p>
</div>
<div class="paragraph">
<p>Starting from 0.10.0, the Bitcoin Core distribution includes a consensus library.</p>
</div>
<div class="paragraph">
<p>The purpose of this library is to make the verification functionality that is
critical to Bitcoin&#8217;s consensus available to other applications, e.g. to language
bindings such as [python-bitcoinlib](<a href="https://pypi.python.org/pypi/python-bitcoinlib" class="bare">https://pypi.python.org/pypi/python-bitcoinlib</a>) or
alternative node implementations.</p>
</div>
<div class="paragraph">
<p>This library is called <code>libbitcoinconsensus.so</code> (or, <code>.dll</code> for Windows).
Its interface is defined in the C header [bitcoinconsensus.h](<a href="https://github.com/bitcoin/bitcoin/blob/0.10/src/script/bitcoinconsensus.h" class="bare">https://github.com/bitcoin/bitcoin/blob/0.10/src/script/bitcoinconsensus.h</a>).</p>
</div>
<div class="paragraph">
<p>In its initial version the API includes two functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bitcoinconsensus_verify_script</code> verifies a script. It returns whether the indicated input of the provided serialized transaction
correctly spends the passed scriptPubKey under additional constraints indicated by flags</p>
</li>
<li>
<p><code>bitcoinconsensus_version</code> returns the API version, currently at an experimental <code>0</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The functionality is planned to be extended to e.g. UTXO management in upcoming releases, but the interface
for existing methods should remain stable.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_libbitcoinkernel"><a class="link" href="#_libbitcoinkernel">libbitcoinkernel</a></h3>
<div class="paragraph">
<p>The <a href="https://github.com/bitcoin/bitcoin/issues/24303" target="_blank" rel="noopener">libbitcoinkernel</a> project seeks to modularise Bitcoin Cores' consensus engine and make it easier for developers to reason about when they are modifying code which could be consensus-critical.</p>
</div>
<div class="paragraph">
<p>This project differs from <code>libbitcoinconsensus</code> in that it is designed to be a stateful engine, with a view to eventually: being able to spawn its own threads, do caching (e.g. of script and signature verification), do its own I/O, and manage dynamic objects like a mempool.
Another benefit of fully extracting the consensus engine in this way may be that it becomes easier to write and reason about consensus test cases.</p>
</div>
<div class="paragraph">
<p>In the future, if a full de-coupling is successfully completed, other Bitcoin applications might be able to use <code>libbitcoinkernel</code> as their own consensus engine permitting multiple full node implementations to operate on the network in a somewhat safer manner than many of them operate under today.
The initial objective of this library however is to actually have it used by Bitcoin Core internally, something which is not possible with libbitcoinconsensus due to it&#8217;s lack of caching and state (making it too slow to use).</p>
</div>
<div class="paragraph">
<p>Some examples have surfaced recently where script validation in the BTCD code (used internally by LND) has diverged from the results from Bitcoin Core:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://twitter.com/brqgoo/status/1579216353780957185" target="_blank" rel="noopener">Witness size check</a>: <a href="https://github.com/lightningnetwork/lnd/issues/7002" target="_blank" rel="noopener">issue</a> and <a href="https://github.com/btcsuite/btcd/pull/1896" target="_blank" rel="noopener">fix</a></p>
</li>
<li>
<p><a href="https://twitter.com/brqgoo/status/1587397646125260802" target="_blank" rel="noopener">Max witness items check</a>: <a href="https://github.com/btcsuite/btcd/issues/1906" target="_blank" rel="noopener">issue</a> and <a href="https://github.com/btcsuite/btcd/pull/1907" target="_blank" rel="noopener">fix</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The implementation approaches of libbitcoinconsensus and libbitcoinkernel also differ; with lb-consensus parts of consensus were moved into the library piece by piece, with the eventual goal that it would be encapsulated.
lb-kernel takes a different approach&#8201;&#8212;&#8201;first cast a super wide net around everything needed to run a consensus engine, and then gradually strip pieces out where they can be.
In theory this should get us something which Bitcoin Core can use much faster (in fact, you can build the optional <code>bitcoin-chainstate</code> binary which already has some functionality).</p>
</div>
<div class="paragraph">
<p>Part of libbitcoinkernel has been merged in via Carl Dong&#8217;s <a href="https://github.com/bitcoin/bitcoin/pull/24304" target="_blank" rel="noopener"><code>bitcoin-chainstate</code> PR</a>.
It also has its own project <a href="https://github.com/bitcoin/bitcoin/projects/18" target="_blank" rel="noopener">board</a> to track progress.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hardcoded_consensus_values"><a class="link" href="#_hardcoded_consensus_values">Hardcoded consensus values</a></h3>
<div class="paragraph">
<p><em>consensus/consensus.h</em> contains a number of <code>static const</code> values relating to consensus rules.
These are globally shared between files such as <em>validation.cpp</em>, <em>rpc_mining.cpp</em> and <em>rpc/mining.cpp</em>.
These consensus-critical values are marked as <code>const</code> so that there is no possibility that they can be changed at any point during program execution.</p>
</div>
<div class="paragraph">
<p>One example of this would be the maximum block weight which should not ever be exceeded:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">static const unsigned int MAX_BLOCK_WEIGHT = 4000000;</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>consensus/amount.h</em> contains the conversion rate between satoshis and one "bitcoin", as well as a <code>MAX_MONEY</code> constant.
These are marked as <code>constexpr</code> to indicate that they should be evaluated at compile time and then remain as <code>const</code> during execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">/** The amount of satoshis in one BTC. */
static constexpr CAmount COIN = 100000000;

/** No amount larger than this (in satoshi) is valid.
 *
 * Note that this constant is *not* the total money supply, which in Bitcoin
 * currently happens to be less than 21,000,000 BTC for various reasons, but
 * rather a sanity check. As this sanity check is used by consensus-critical
 * validation code, the exact value of the MAX_MONEY constant is consensus
 * critical; in unusual circumstances like a(nother) overflow bug that allowed
 * for the creation of coins out of thin air modification could lead to a fork.
 * */
static constexpr CAmount MAX_MONEY = 21000000 * COIN;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Do you think that the <code>COIN</code> constant is necessary at a consensus level, or is it a Bitcoin Core-specific abstraction?</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_validation"><a class="link" href="#_transaction_validation">Transaction validation</a></h3>
<div class="paragraph">
<p>Transactions can originate from the P2P network, the wallet, RPCs or from tests.</p>
</div>
<div class="paragraph">
<p>Transactions which originate from the wallet, RPCs or individually from the P2P network (from a <code>NetMsgType::TX</code> message) will follow a validation pathway which includes adding them to the mempool.
This implies passing both consensus and policy checks.
See the sections on <a href="#_single_transactions">Single transactions</a> and <a href="#multiple_transactions">Multiple transactions</a> to learn more about transaction validation via the mempool.</p>
</div>
<div class="paragraph">
<p>Transactions which are learned about in a new block from the P2P network (from a <code>NetMsgType::BLOCK</code> or <code>NetMsgType::BLOCKTXN</code> message) do not have to be added to the mempool and so do not have to pass policy checks.
See the section <a href="#_transactions_from_blocks">Transactions from blocks</a> to learn more about transaction validation bypassing the mempool.</p>
</div>
<div id="tx-origination" class="literalblock">
<div class="title">Transaction origination (excluding tests)</div>
<div class="content">
<pre>flowchart LR
    process_tx["ChainstateManager::ProcessTransaction()"]
    process_msg["PeerManagerImpl::ProcessMessage()"]
    process_block["ProcessBlock()"]
    check_block["CheckBlock()"]
    connect_block["ConnectBlock()"]
    process_orphan["PeerManagerImpl::ProcessOrphanTx()"]
    broadcast_tx["BroadcastTransaction()"]
    srt["sendrawtransaction()"]
    tmpa["testmempoolaccept()"]
    submit_relay["CWallet::SubmitTxMemoryPoolAndRelay()"]
    atmp["AcceptToMemoryPool()"]
    accept_single["AcceptSingleTransaction()"]
    process_package["ProcessNewPackage()"]
    accept_package["AcceptPackage()"]
    accept_multiple["AcceptMultipleTransactions()"]

    subgraph net_processing.cpp
        process_msg
        process_orphan
    end
    subgraph 2 ["rpc/rawtransaction.cpp"]
        srt
        tmpa
    end
    subgraph 3 [wallet/wallet.cpp]
        submit_relay
    end
    process_msg -. Packages ..-&gt; process_package
    process_msg ---&gt; process_block --&gt; check_block --&gt; connect_block
    process_msg -- NetMessage::TX --&gt; process_tx
    process_orphan ---&gt; process_tx
    tmpa --&gt; process_tx
    submit_relay --&gt; broadcast_tx
    srt --&gt; broadcast_tx
    broadcast_tx --&gt; process_tx
    process_tx --&gt; atmp --&gt; accept_single
    srt -- Packages --&gt; process_package
    process_package --&gt; accept_package
    accept_package --&gt; accept_multiple

    classDef P2P fill:red,color:white,stroke:red;
    classDef Wallet fill:green,color:white,stroke:green;
    classDef RPC fill:blue,color:white,stroke:blue;
    class process_msg,process_orphan P2P
    class submit_relay Wallet
    class tmpa,srt RPC</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Dotted lines represent potential future upgrades
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>P2P network = <span class="red">Red</span><br>
Wallet = <span class="green">Green</span><br>
RPCs = <span class="blue">Blue</span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For more information on <code>PeerManagerImpl</code> see <a href="#pimpl-technique">PIMPL technique</a> in the appendix.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Transactions are internally represented as either a <code>CTransaction</code>, a <code>CTransactionRef</code> (a shared pointer to a <code>CTransaction</code>) or in the case of packages a <code>Package</code> which is a <code>std::vector&lt;CTransactionRef&gt;</code>.</p>
</div>
<div id="glozow-tx-mempool-validation" class="paragraph">
<p>We can follow the journey of a transaction through the Bitcoin Core mempool by following glozow&#8217;s <a href="https://github.com/glozow/bitcoin-notes/tree/e9855dc377811b6d77bb75d8606c776cc26c1860/transaction-lifecycle.md#Validation-and-Submission-to-Mempool" target="_blank" rel="noopener">notes</a> on transaction "Validation and Submission to the Mempool".
glozow details the different types of checks that are run on a new transaction before it&#8217;s accepted into the mempool, as well as breaking down how these checks are different from each other: consensus vs policy, script vs non-script, contextual vs context-free.</p>
</div>
<div class="paragraph">
<p>The section on block validation <a href="https://github.com/glozow/bitcoin-notes/tree/e9855dc377811b6d77bb75d8606c776cc26c1860/transaction-lifecycle.md#block-validation" target="_blank" rel="noopener">describes</a> the consensus checks performed on newly-learned blocks, specifically:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Since v0.8, Bitcoin Core nodes have used a <a href="https://github.com/bitcoin/bitcoin/pull/1677" target="_blank" rel="noopener">UTXO set</a> rather than blockchain lookups to represent state and validate transactions.
To fully validate new blocks nodes only need to consult their UTXO set and knowledge of the current consensus rules.
Since consensus rules depend on block height and time (both of which can <strong>decrease</strong> during a reorg), they are recalculated for each block prior to validation.</p>
</div>
<div class="paragraph">
<p>Regardless of whether or not transactions have already been previously validated and accepted to the mempool, nodes check block-wide consensus rules (e.g. <a href="https://github.com/bitcoin/bitcoin/tree/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L1935" target="_blank" rel="noopener">total sigop cost</a>, <a href="https://github.com/bitcoin/bitcoin/blob/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L1778-L1866" target="_blank" rel="noopener">duplicate transactions</a>, <a href="https://github.com/bitcoin/bitcoin/blob/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L3172-L3179" target="_blank" rel="noopener">timestamps</a>, <a href="https://github.com/bitcoin/bitcoin/blob/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L3229-L3255" target="_blank" rel="noopener">witness commitments</a> <a href="https://github.com/bitcoin/bitcoin/blob/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L1965-L1969" target="_blank" rel="noopener">block subsidy amount</a>) and transaction-wide consensus rules (e.g. availability of inputs, locktimes, and <a href="https://github.com/bitcoin/bitcoin/blob/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L1946" target="_blank" rel="noopener">input scripts</a>) for each block.</p>
</div>
<div class="paragraph">
<p>Script checking is parallelized in block validation. Block transactions are checked in order (and coins set updated which allows for dependencies within the block), but input script checks are parallelizable. They are added to a <a href="https://github.com/bitcoin/bitcoin/tree/9df1906091f84d9a3a2e953a0424a88e0931ea33/src/validation.cpp#L1887" target="_blank" rel="noopener">work queue</a> delegated to a set of threads while the main validation thread is working on other things.
While failures should be rare - creating a valid proof of work for an invalid block is quite expensive - any consensus failure on a transaction invalidates the entire block, so no state changes are saved until these threads successfully complete.</p>
</div>
<div class="paragraph">
<p>If the node already validated a transaction before it was included in a block, no consensus rules have changed, and the script cache has not evicted this transaction&#8217;s entry, it doesn&#8217;t need to run script checks again - it just <a href="https://github.com/bitcoin/bitcoin/tree/1a369f006fd0bec373b95001ed84b480e852f191/src/validation.cpp#L1419-L1430" target="_blank" rel="noopener">uses the script cache</a>!</p>
</div>
</blockquote>
<div class="attribution">
&#8212; glozow
</div>
</div>
<div class="paragraph">
<p>The section from bitcoin-core-architecture on script verification also <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/tree/main/1.0_bitcoin_core_architecture.asciidoc#script-verification" target="_blank" rel="noopener">highlights</a> how the script interpreter is called from at least 3 distinct sites within the codebase:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="ulist">
<ul>
<li>
<p>when the node <a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/net_processing.cpp#L3001" target="_blank" rel="noopener">receives a new transaction</a>.</p>
</li>
<li>
<p>when the <a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/node/transaction.cpp#L29" target="_blank" rel="noopener">node wants to broadcast a new transaction</a>.</p>
</li>
<li>
<p>when <a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/net_processing.cpp#L3529" target="_blank" rel="noopener">receiving a new block</a></p>
</li>
</ul>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Having considered both transactions that have entered into the mempool and transactions that were learned about in a new block we now understand both ways a transaction can be considered for validation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As you read through the following sub-sections, consider whether making changes to them could affect policy or consensus.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_single_transactions"><a class="link" href="#_single_transactions">Single transactions</a></h4>
<div class="paragraph">
<p><code>AcceptToMemoryPool()</code> (ATMP) is where the checks on single transactions occur before they enter the mempool.</p>
</div>
<div id="ATMP-validation-flow" class="literalblock">
<div class="title">ATMP validation flow chart</div>
<div class="content">
<pre>flowchart TB
    success[MempoolAcceptResult::Success]
    failure[MempoolAcceptResult::Failure]
    process_tx["ChainstateManager::ProcessTransaction()"]
    maybe_update["CChainState::MaybeUpdateMempoolForReorg()"]
    load_mempool["LoadMempool()"]
    atmp["AcceptToMemoryPool()"]
    accept_single["AcceptSingleTransaction()"]
    finalise["Finalize()"]

    %% think this is too much detail
    %% process_msg["PeerManagerImpl::ProcessMessage()"]
    %% process_orphan["PeerManagerImpl::ProcessOrphanTx()"]
    %% broadcast_tx["BroadcastTransaction()"]
    %% process_msg --&gt; process_tx
    %% process_orphan --&gt; process_tx
    %% broadcast_tx --&gt; process_tx

    maybe_update --&gt; atmp
    process_tx --&gt; atmp
    load_mempool --&gt; atmp

    atmp --&gt; accept_single
    accept_single --&gt; PreChecks
    PreChecks --&gt; ReplacementChecks
    PreChecks -- fail --&gt; failure
    ReplacementChecks --&gt; PolicyScriptChecks
    ReplacementChecks -- fail --&gt; failure
    PolicyScriptChecks --&gt; ConsensusScriptChecks
    PolicyScriptChecks -- fail --&gt; failure
    ConsensusScriptChecks -- if test_accept --&gt; success
    ConsensusScriptChecks -- fail ---&gt; failure
    ConsensusScriptChecks --&gt; finalise
    finalise --&gt; success

    classDef green fill:#00A000,color:white,stroke:green;
    classDef red fill:#BA3925,color:white,stroke:red;
    class AcceptToMemoryPool,success green
    class failure, red</pre>
</div>
</div>
<div class="paragraph">
<p>You can see the calls to the various <code>*Checks()</code> functions in the <a href="#ATMP-validation-flow">call graph</a>, and the order in which they are run.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look inside <code>AcceptToMemoryPool()</code>'s inner function <code>AcceptSingleTransaction()</code> which handles running the checks:</p>
</div>
<div id="accept_single_transaction" class="listingblock">
<div class="title">src/validation.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef&amp; ptx, ATMPArgs&amp; args)
{
    AssertLockHeld(cs_main);
    LOCK(m_pool.cs); // mempool "read lock" (held through GetMainSignals().TransactionAddedToMempool())

    Workspace ws(ptx);

    if (!PreChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);

    if (m_rbf &amp;&amp; !ReplacementChecks(ws)) return MempoolAcceptResult::Failure(ws.m_state);

    // Perform the inexpensive checks first and avoid hashing and signature verification unless
    // those checks pass, to mitigate CPU exhaustion denial-of-service attacks.
    if (!PolicyScriptChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);

    if (!ConsensusScriptChecks(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);

    // Tx was accepted, but not added
    if (args.m_test_accept) {
        return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_vsize, ws.m_base_fees);
    }

    if (!Finalize(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);

    GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());

    return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_vsize, ws.m_base_fees);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We purposefully run checks in this order so that the least computationally-expensive checks are run first.
This means that we can hopefully fail early and minimise CPU cycles used on invalid transactions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If an attacker could force us to perform many expensive computations simply by sending us many invalid transactions then it would be inexpensive to bring our node to a halt.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once <code>AcceptSingleTransaction</code> has acquired the <code>cs_main</code> and <code>m_pool.cs</code> locks it initializes a <code>Workspace</code> struct&#8201;&#8212;&#8201;a storage area for (validation status) state which can be shared by the different validation checks.
Caching this state avoids performing the same computations multiple times and is important for performance.
It will pass this workspace, along with the struct of <code>ATMPArgs</code> it received as argument, to the checks.</p>
</div>
<details id="multiple_locks">
<summary class="title">Click to see the code comments on why we hold <em>two</em> locks before performing consensus checks on transactions</summary>
<div class="content">
<div class="listingblock">
<div class="title">src/txmempool.h#CTxMemPool</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/**
 * This mutex needs to be locked when accessing `mapTx` or other members
 * that are guarded by it.
 *
 * @par Consistency guarantees
 *
 * By design, it is guaranteed that:
 *
 * 1. Locking both `cs_main` and `mempool.cs` will give a view of mempool
 *    that is consistent with current chain tip (`::ChainActive()` and
 *    `CoinsTip()`) and is fully populated. Fully populated means that if the
 *    current active chain is missing transactions that were present in a
 *    previously active chain, all the missing transactions will have been
 *    re-added to the mempool and should be present if they meet size and
 *    consistency constraints.
 *
 * 2. Locking `mempool.cs` without `cs_main` will give a view of a mempool
 *    consistent with some chain that was active since `cs_main` was last
 *    locked, and that is fully populated as described above. It is ok for
 *    code that only needs to query or remove transactions from the mempool
 *    to lock just `mempool.cs` without `cs_main`.
 *
 * To provide these guarantees, it is necessary to lock both `cs_main` and
 * `mempool.cs` whenever adding transactions to the mempool and whenever
 * changing the chain tip. It's necessary to keep both mutexes locked until
 * the mempool is consistent with the new chain tip and fully populated.
 */
mutable RecursiveMutex cs;</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>The <code>Workspace</code> is initialized with a pointer to the transaction (as a <code>CTransactionRef</code>) and holds some <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L553-L593" target="_blank" rel="noopener">additional</a> information related to intermediate state.</p>
</div>
<div class="paragraph">
<p>We can look at the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L469-L534" target="_blank" rel="noopener"><code>ATMPArgs</code> struct</a> to see what other information our mempool wants to know about in addition to transaction information.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">ATMPArgs</div>
<div class="paragraph">
<p><code>m_accept_time</code> is the local time when the transaction entered the mempool.
It&#8217;s used during the mempool transaction eviction selection process as part of <code>CTxMemPool::Expire()</code> where it is referenced by the name <code>entry_time</code>:</p>
</div>
<details>
<summary class="title">Click to see <code>entry_time</code> being used in <code>Expire()</code></summary>
<div class="content">
<div class="listingblock">
<div class="title">src/txmempool.cpp#CTXMemPool::Expire()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">int CTxMemPool::Expire(std::chrono::seconds time)
{
    AssertLockHeld(cs);
    indexed_transaction_set::index&lt;entry_time&gt;::type::iterator it = mapTx.get&lt;entry_time&gt;().begin();
    setEntries toremove;
    while (it != mapTx.get&lt;entry_time&gt;().end() &amp;&amp; it-&gt;GetTime() &lt; time) {
        toremove.insert(mapTx.project&lt;0&gt;(it));
        it++;
    }
    setEntries stage;
    for (txiter removeit : toremove) {
        CalculateDescendants(removeit, stage);
    }
    RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY);
    return stage.size();
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p><code>m_bypass_limits</code> is used to determine whether we should enforce mempool fee limits for this transaction.
If we are a miner we may want to ensure <em>our own</em> transactions would pass mempool checks, even if we don&#8217;t attach a fee to them.</p>
</div>
<div class="paragraph">
<p><code>m_test_accept</code> is used if we just want to run mempool checks to test validity, but not actually add the transaction into the mempool yet.
This happens when we want to broadcast one of our own transactions, done by calling <code>BroadcastTransaction</code> from <code>node/transaction.cpp#BroadcastTransaction()</code> or from the <code>testmempoolaccept()</code> RPC.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If all the checks pass and this was not a <code>test_accept</code> submission then we will <code>MemPoolAccept::Finalize</code> the transaction, adding it to the mempool, before trimming the mempool size and updating any affected RBF transactions as required.</p>
</div>
</div>
<div class="sect3">
<h4 id="multiple_transactions"><a class="link" href="#multiple_transactions">Multiple transactions (and packages)</a></h4>
<div class="paragraph">
<p>TODO: This section should start from <code>AcceptPackage()</code> and flow through from there, including <code>AcceptMultipleTransactions()</code> as a sub-section.</p>
</div>
<div class="paragraph">
<p>It&#8217;s possible to consider multiple transactions for validation together, via <code>AcceptMultipleTransactions()</code> found in <em>src/net_processing.cpp</em>.
It&#8217;s currently only available from tests (<code>test/tx_package_tests.cpp</code>) and the <code>testmempoolaccept</code> RPC (via <code>ProcessNewPackage()</code>), but the intention is for it to be available to packages received from the P2P network in the future.</p>
</div>
<div class="paragraph">
<p>This validation flow has been created for usage with Package Mempool Accept, which glozow has written up in a <a href="https://gist.github.com/glozow/dc4e9d5c5b14ade7cdfac40f43adb18a" target="_blank" rel="noopener">gist</a> (<a href="https://archive.ph/Uhewe" target="_blank" rel="noopener">archive</a>).</p>
</div>
<div class="paragraph">
<p>The flow here is similar to <a href="#accept_single_transaction"><code>AcceptSingleTransaction()</code></a> in that we start by grabbing <code>cs_main</code> before initializing validation state and workspaces, however this time we use <code>PackageValidationState</code> and a vector of workspaces, <code>std::vector&lt;Workspace&gt;</code>.
Each transaction therefore has it&#8217;s own workspace but all transactions in the package share a single validation state.
This aligns with the goal of either accepting or rejecting the entire package as a single entity.</p>
</div>
<div class="paragraph">
<p>Next come two <code>for</code> loops over the vector of workspaces (i.e. transactions).
The first performs the <a href="#_prechecks"><code>PreChecks()</code></a>, but this time also freeing up coins to be spent by other transactions in this package.
This would not usually be possible (nor make sense) <em>within</em> an <code>AcceptTransaction()</code> flow, but within a package we want to be able to validate transactions who use as inputs, other transactions not yet added to our mempool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    // Make the coins created by this transaction available for subsequent transactions in the
    // package to spend. Since we already checked conflicts in the package and we don't allow
    // replacements, we don't need to track the coins spent. Note that this logic will need to be
    // updated if package replace-by-fee is allowed in the future.
    assert(!args.m_allow_bip125_replacement);
    m_viewmempool.PackageAddTransaction(ws.m_ptx);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>PreChecks</code> do not fail, we call <code>m_viewmempool.PackageAddTransaction()</code> passing in the workspace.
This adds the transaction to a map in our Mempool called <code>std::unordered_map&lt;COutPoint, Coin, SaltedOutpointHasher&gt; m_temp_added;</code>, which is essentially a temporary cache somewhere in-between being validated and being fully added to the mempool.</p>
</div>
<div class="paragraph">
<p>TODO: Fix after adding section on <code>AcceptPackage</code></p>
</div>
<div class="paragraph">
<p>After this first loop we perform <code>PackageMempoolChecks()</code> which first asserts that transactions are not already in the mempool, before checking the "PackageLimits".</p>
</div>
</div>
<div class="sect3">
<h4 id="_prechecks"><a class="link" href="#_prechecks">PreChecks</a></h4>
<div class="paragraph">
<p>The code comments for <code>PreChecks</code> give a clear description of what the PreChecks are for:</p>
</div>
<div class="listingblock">
<div class="title">src/validation.cpp#MemPoolAccept::PreChecks()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// Run the policy checks on a given transaction, excluding any script checks.
// Looks up inputs, calculates feerate, considers replacement, evaluates
// package limits, etc. As this function can be invoked for "free" by a peer,
// only tests that are fast should be done here (to avoid CPU DoS).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PreChecks</code> function is very <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L668-L906" target="_blank" rel="noopener">long</a> but is worth examining to understand better which checks are undertaken as part of this first stage.</p>
</div>
</div>
<div class="sect3">
<h4 id="_replacementchecks"><a class="link" href="#_replacementchecks">ReplacementChecks</a></h4>
<div class="paragraph">
<p>During <code>PreChecks</code> the <code>m_rbf</code> bool will have been set to <code>true</code> if it is determined that this transaction would have to replace an existing transaction from our mempool.
If this bool is set, then <code>ReplacementChecks</code> will be run.
These checks are designed to check that BIP125 RBF rules are being adhered to.</p>
</div>
</div>
<div class="sect3">
<h4 id="_policyscriptchecks"><a class="link" href="#_policyscriptchecks">PolicyScriptChecks</a></h4>
<div class="paragraph">
<p>Following <code>ReplacementChecks</code> we initialise a <code>PrecomputedTransactionData</code> struct in the <code>Workspace</code> which will hold expensive-to-compute data that we might want to use again in subsequent validation steps.</p>
</div>
<details>
<summary class="title">Click to show the <code>PrecomputedTransactionData</code> struct</summary>
<div class="content">
<div class="listingblock">
<div class="title">script/interpreter.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">struct PrecomputedTransactionData
{
    // BIP341 precomputed data.
    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.
    uint256 m_prevouts_single_hash;
    uint256 m_sequences_single_hash;
    uint256 m_outputs_single_hash;
    uint256 m_spent_amounts_single_hash;
    uint256 m_spent_scripts_single_hash;
    //! Whether the 5 fields above are initialized.
    bool m_bip341_taproot_ready = false;

    // BIP143 precomputed data (double-SHA256).
    uint256 hashPrevouts, hashSequence, hashOutputs;
    //! Whether the 3 fields above are initialized.
    bool m_bip143_segwit_ready = false;

    std::vector&lt;CTxOut&gt; m_spent_outputs;
    //! Whether m_spent_outputs is initialized.
    bool m_spent_outputs_ready = false;

    PrecomputedTransactionData() = default;

    template &lt;class T&gt;
    void Init(const T&amp; tx, std::vector&lt;CTxOut&gt;&amp;&amp; spent_outputs);

    template &lt;class T&gt;
    explicit PrecomputedTransactionData(const T&amp; tx);
};</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>Next we call <code>PolicyScriptChecks()</code> passing in the same <code>ATMPArgs</code> and <code>Workspace</code> that we used with PreChecks.
This is going to check the transaction against our individual node&#8217;s policies.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that local node policies are not necessarily consensus-binding, but are designed to help prevent resource exhaustion (e.g. DoS) on our node.</p>
</div>
<div class="paragraph">
<p>See the <a href="#_transaction_validation">Transaction validation</a> and <a href="#_consensus_in_bitcoin_core">Consensus in Bitcoin Core</a> sections for more information on the differences between policy and consensus.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>PolicyScriptChecks()</code> starts with initialisation of the transaction into a <code>CTransaction</code>, before beginning to <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L973-L999" target="_blank" rel="noopener">check</a> the input scripts against the script flags.</p>
</div>
<div class="listingblock">
<div class="title">src/validation.cpp#PolicyScriptChecks</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs&amp; args, Workspace&amp; ws, PrecomputedTransactionData&amp; txdata)
{
    const CTransaction&amp; tx = *ws.m_ptx;
    TxValidationState&amp; state = ws.m_state;

    constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;

    // Check input scripts and signatures.
    // This is done last to help prevent CPU exhaustion denial-of-service attacks.
    if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, txdata)) { <i class="conum" data-value="1"></i><b>(1)</b>
        // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we
        // need to turn both off, and compare against just turning off CLEANSTACK
        // to see if the failure is specifically due to witness validation.
        TxValidationState state_dummy; // Want reported failures to be from first CheckInputScripts
        if (!tx.HasWitness() &amp;&amp; CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags &amp; ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &amp;&amp;
                !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags &amp; ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {
            // Only the witness is missing, so the transaction itself may be fine.
            state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED,
                    state.GetRejectReason(), state.GetDebugMessage());
        }
        return false; // state filled in by CheckInputScripts
    }

    return true;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Calling <code>CheckInputScripts()</code> involves ECDSA signature verification and is therefore computationally expensive.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the script type is SegWit an additional round of checking is performed, this time including the <code>CLEANSTACK</code> rule.
The call(s) flag <code>cacheSigStore</code> as <code>true</code>, and <code>cacheFullScriptStore</code> as <code>false</code>, which means that matched signatures will be persisted in the cache, but matched full scripts will be removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consensusscriptchecks"><a class="link" href="#_consensusscriptchecks">ConsensusScriptChecks</a></h4>
<div class="paragraph">
<p>If the <code>PolicyScriptChecks</code> return <code>true</code> we will move on to consensus script checks, again passing in the same <code>ATMPArgs</code>, <code>Workspace</code> and now <code>PrecomputedTransactionData</code> that we used previously with <code>PolicyScriptChecks</code>.</p>
</div>
<div class="paragraph">
<p>The main check in here is <code>CheckInputsFromMempoolAndCache()</code> which is going to compare all the transaction inputs to our mempool, checking that they have not already been marked as spent.
If the coin is not already spent, we reference it from either the UTXO set or our mempool, and finally submit it through <code>CheckInputScripts()</code> once more, this time caching both the signatures and the full scripts.</p>
</div>
<details>
<summary class="title">Click to show <code>CheckInputsFromMempoolAndCache()</code></summary>
<div class="content">
<div class="listingblock">
<div class="title">src/validation.cpp#CheckInputsFromMempoolAndCache</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/**
* Checks to avoid mempool polluting consensus critical paths since cached
* signature and script validity results will be reused if we validate this
* transaction again during block validation.
* */
static bool CheckInputsFromMempoolAndCache(const CTransaction&amp; tx, TxValidationState&amp; state,
                const CCoinsViewCache&amp; view, const CTxMemPool&amp; pool,
                unsigned int flags, PrecomputedTransactionData&amp; txdata, CCoinsViewCache&amp; coins_tip)
                EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)
{
    AssertLockHeld(cs_main);
    AssertLockHeld(pool.cs);

    assert(!tx.IsCoinBase());
    for (const CTxIn&amp; txin : tx.vin) {
        const Coin&amp; coin = view.AccessCoin(txin.prevout);

        // This coin was checked in PreChecks and MemPoolAccept
        // has been holding cs_main since then.
        Assume(!coin.IsSpent());
        if (coin.IsSpent()) return false;

        // If the Coin is available, there are 2 possibilities:
        // it is available in our current ChainstateActive UTXO set,
        // or it's a UTXO provided by a transaction in our mempool.
        // Ensure the scriptPubKeys in Coins from CoinsView are correct.
        const CTransactionRef&amp; txFrom = pool.get(txin.prevout.hash);
        if (txFrom) {
            assert(txFrom-&gt;GetHash() == txin.prevout.hash);
            assert(txFrom-&gt;vout.size() &gt; txin.prevout.n);
            assert(txFrom-&gt;vout[txin.prevout.n] == coin.out);
        } else {
            assert(std::addressof(::ChainstateActive().CoinsTip()) == std::addressof(coins_tip));
            const Coin&amp; coinFromUTXOSet = coins_tip.AccessCoin(txin.prevout);
            assert(!coinFromUTXOSet.IsSpent());
            assert(coinFromUTXOSet.out == coin.out);
        }
    }

    // Call CheckInputScripts() to cache signature and script validity against current tip consensus rules.
    return CheckInputScripts(tx, state, view, flags, /* cacheSigStore = */ true, /* cacheFullSciptStore = */ true, txdata);
}</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_packagemempoolchecks"><a class="link" href="#_packagemempoolchecks">PackageMempoolChecks</a></h4>
<div class="paragraph">
<p><code>PackageMempoolChecks</code> are designed to "Enforce package mempool ancestor/descendant limits (distinct from individual ancestor/descendant limits done in PreChecks)".
They take a vector of <code>CTransactionRef</code>s and a <code>PackageValidationState</code>.</p>
</div>
<div class="paragraph">
<p>Again we take <a href="#multiple_locks">two locks</a> before checking that the transactions are not in the mempool.
Any transactions which are part of the package and were in the mempool will have already been removed by <code>MemPoolAccept::AcceptPackage()</code>.</p>
</div>
<div class="paragraph">
<p>Finally we check the package limits, which consists of checking the {ancestor|descendant} {count|size}.
This check is unique to packages because we can now add descendants whose ancestors would not otherwise qualify for entry into our mempool with their low effective fee rate.</p>
</div>
</div>
<div class="sect3">
<h4 id="_finalize"><a class="link" href="#_finalize">Finalize</a></h4>
<div class="paragraph">
<p>Provided that consensus script checks pass and this was not a test ATMP call, we will call <code>Finalize()</code> on the transaction.
This will remove any conflicting (lower fee) transactions from the mempool before adding this one, finishing by trimming the mempool to the configured size (default: <code>static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;</code> MB).
In the event that <strong>this</strong> transaction got trimmed, we ensure that we return a <code>TxValidationResult::TX_MEMPOOL_POLICY, "mempool full"</code> result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_transactions_from_blocks"><a class="link" href="#_transactions_from_blocks">Transactions from blocks</a></h4>
<div class="paragraph">
<p>Transactions learned about from blocks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Might not be present in our mempool</p>
</li>
<li>
<p>Are not being considered for entry into our mempool and therefore do not have to pass policy checks</p>
</li>
<li>
<p>Are only subject to consensus checks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This means that we can validate these transactions based only on our copy of the UTXO set and the data contained within the block itself.
We call <code>ProcessBlock()</code> when processing new blocks received from the P2P network (in <em>net_processing.cpp</em>) from net message types: <code>NetMsgType::CMPCTBLOCK</code>, <code>NetMsgType::BLOCKTXN</code> and <code>NetMsgType::BLOCK</code>.</p>
</div>
<div id="block-tx-validation" class="literalblock">
<div class="title">Abbreviated block transaction validation</div>
<div class="content">
<pre>flowchart LR
    process_block["ProcessBlock()"]
    process_new_block["ProcessNewBlock()"]
    check_block_header["CheckBlockHeader()"]
    block_merkle["BlockMerkleRoot()"]
    check_transaction["CheckTransaction()"]
    subgraph sub_check_block ["CheckBlock()"]
        direction TB
        check_block_header --&gt; block_merkle
        block_merkle --&gt; check_transaction
    end

    accept_block_header["AcceptBlockHeader()"]
    check_block_index["CheckBlockIndex()"]
    check_block["CheckBlock()"]
    contextual_check_block["ContextualCheckBlock()"]
    save_block_disk["SaveBlockToDisk()"]
    recv_block_tx["ReceivedBlockTransactions()"]
    subgraph sub_accept_block["AcceptBlock()"]
        direction TB
        accept_block_header --&gt; check_block_index
        check_block_index --&gt; check_block
        check_block --&gt; contextual_check_block
        contextual_check_block --&gt; save_block_disk
        save_block_disk --&gt; recv_block_tx
    end

    activate_best_chain_step["ActivateBestChainStep()"]
    connect_tip["ConnectTip()"]
    connect_block["ConnectBlock()"]

    subgraph activate_chain["ActivateBestChain()"]
        direction TB
        activate_best_chain_step --&gt; connect_tip
        connect_tip --&gt; connect_block
    end

    process_block --&gt; process_new_block
    process_new_block --&gt; sub_check_block
    sub_check_block --&gt; sub_accept_block
    sub_accept_block --&gt; activate_chain</pre>
</div>
</div>
<div class="paragraph">
<p>The general flow of <code>ProcessBlock()</code> is that will call <code>CheckBlock()</code>, <code>AcceptBlock()</code> and then <code>ActivateBestChain()</code>.
A block which has passed successfully through <code>CheckBlock()</code> and <code>AcceptBlock()</code> has <strong>not</strong> passed full consensus validation.</p>
</div>
<div class="paragraph">
<p><code>CheckBlock()</code> does some cheap, context-independent structural validity <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L3242-L3314" target="_blank" rel="noopener">checks</a>, along with (re-)checking the proof of work in the header, however these checks just determine that the block is "valid-enough" to proceed to <code>AcceptBlock()</code>.</p>
</div>
<div class="paragraph">
<p>Once the checks have been completed, the <code>block.fChecked</code> value is set to <code>true</code>.
This will enable any subsequent calls to this function <em>with this block</em> to be skipped.</p>
</div>
<div class="paragraph">
<p><code>AcceptBlock()</code> is used to persist the block to disk so that we can (validate it and) add it to our chain immediately, use it later, or discard it later.
<code>AcceptBlock()</code> makes a second call to <code>CheckBlock()</code> but because <code>block.fChecked</code> was set to <code>true</code> on the first pass this second check will be skipped.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>AcceptBlock()</code> contains an inner call to <code>CheckBlock()</code> because it can also be called directly by <code>CChainState::LoadExternalBlockFile()</code> where <code>CheckBlock()</code> will not have been previously called.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It also now runs some <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L3662-L3663" target="_blank" rel="noopener">contextual checks</a> such as checking the block time, transaction lock times (transaction are "finalized") and witness commitments are either non-existent or valid (<a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L3412-L3492" target="_blank" rel="noopener">link</a>).
After this the block will be serialized to disk.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>At this stage we might still be writing blocks to disk that will fail full consensus checks.
However, if they have reached here they have passed proof of work and structural checks, so consensus failures may be due to us missing intermediate blocks, or that there are competing chain tips.
In these cases this block may still be useful to us in the future.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the block has been written to disk by <code>AcceptBlock()</code> full validation of the block and its transactions begins via <code>CChainState::ActivateBestChain()</code> and its inner call to <code>ActivateBestChainStep()</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_chains"><a class="link" href="#_multiple_chains">Multiple chains</a></h3>
<div class="paragraph">
<p>TODO: Reorgs, undo data, <code>DisconnectBlock</code></p>
</div>
<div class="paragraph">
<p>Bitcoin nodes should ultimately converge in consensus on the most-work chain.
Being able to track and monitor multiple chain (tips) concurrently is a key requirement for this to take place.
There are a number of different states which the client must be able to handle:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A single, most-work chain being followed</p>
</li>
<li>
<p>Stale blocks learned about but not used</p>
</li>
<li>
<p>Full reorganisation from one chain tip to another</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>BlockManager</code> is tasked with maintaining a tree of all blocks learned about, along with their total work so that the most-work chain can be quickly determined.</p>
</div>
<div class="paragraph">
<p><code>CChainstate</code> (<a href="https://github.com/bitcoin/bitcoin/pull/24513" target="_blank" rel="noopener">renamed</a> to <code>Chainstate</code> in v24.0) is responsible for updating our local view of the best tip, including reading and writing blocks to disk, and updating the UTXO set.
A single <code>BlockManager</code> is shared between all instances of <code>CChainState</code>.</p>
</div>
<div class="paragraph">
<p><code>ChainstateManager</code> is tasked with managing multiple <code>CChainState</code>s.
Currently just a "regular" IBD chainstate and an optional snapshot chainstate, which might in the future be used as part of the <a href="https://bitcoinops.org/en/topics/assumeutxo/" target="_blank" rel="noopener">assumeUTXO</a> project.</p>
</div>
<div class="paragraph">
<p>When a new block is learned about (from <code>src/net_processing.cpp</code>) it will call into <code>ChainstateManager</code>s <code>ProcessNewBlockHeaders</code> method to validate it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_responsible_disclosure"><a class="link" href="#_responsible_disclosure">Responsible Disclosure</a></h3>
<div class="paragraph">
<p>Bitcoin Core has a defined process for reporting security vulnerabilities via it&#8217;s responsible disclosure process.
This is detailed in <a href="https://github.com/bitcoin/bitcoin/blob/master/SECURITY.md" target="_blank" rel="noopener">SECURITY.md</a>.</p>
</div>
<div class="paragraph">
<p>Bugs which would need to be disclosed by following this process are generally those which could result in a consensus-failure, theft of funds, or creation of additional supply tokens (new coin issuance).
If bugs of this nature are posted publicly then inevitably one or more persons will try to enact them, possibly causing severe harm or loss to one or many people.</p>
</div>
<div class="paragraph">
<p>If you would like to learn more about the responsible disclosure process and why it&#8217;s so important for Bitcoin Core, you can read the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://medium.com/mit-media-lab-digital-currency-initiative/http-coryfields-com-cash-48a99b85aad4" target="_blank" rel="noopener">Responsible disclosure in the era of cryptocurrencies</a></p>
</li>
<li>
<p><a href="https://cacm.acm.org/magazines/2020/10/247597-responsible-vulnerability-disclosure-in-cryptocurrencies/fulltext" target="_blank" rel="noopener">Responsible Vulnerability Disclosure in Cryptocurrencies</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_2"><a class="link" href="#_exercises_2">Exercises</a></h3>
<div class="qlist qanda">
<ol>
<li>
<p><em>What is the difference between contextual and context-free validation checks?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>Contextual checks require some knowledge of the current "state", e.g. ChainState, chain tip or UTXO set.</p>
</div>
<div class="paragraph">
<p>Context-free checks only require the information required in the transaction itself.</p>
</div>
<div class="paragraph">
<p>For more info, see <a href="#glozow-tx-mempool-validation">glozow&#8217;s notes</a> on transaction "Validation and Submission to the Mempool".</p>
</div>
</div>
</details>
</li>
<li>
<p><em>What are some examples of each?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>context-free:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>tx.isCoinbase()</code></p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/consensus/tx_check.cpp#L25-L28" target="_blank" rel="noopener">0 &#8804; tx_value &#8804; MAX_MONEY</a></p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/policy/policy.cpp#L88" target="_blank" rel="noopener">tx not overweight</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>contextual:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/validation.cpp#L671-L692" target="_blank" rel="noopener">check inputs are available</a></p>
</li>
</ol>
</div>
</div>
</details>
</li>
<li>
<p><em>In which function(s) do UTXO-related validity checks happen?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>ConnectBlock()</code></p>
</div>
</div>
</details>
</li>
<li>
<p><em>What type of validation checks are <code>CheckBlockHeader()</code> and <code>CheckBlock()</code> performing?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>context-free</p>
</div>
</div>
</details>
</li>
<li>
<p><em>Which class is in charge of managing the current blockchain?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>ChainstateManager()</code></p>
</div>
</div>
</details>
</li>
<li>
<p><em>Which class is in charge of managing the UTXO set?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>CCoinsViews()</code></p>
</div>
</div>
</details>
</li>
<li>
<p><em>Which functions are called when a longer chain is found that we need to re-org onto?</em></p>
<p>TODO</p>
</li>
<li>
<p><em>Are there any areas of the codebase where the same consensus or validation checks are performed twice?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>Again see <a href="https://github.com/glozow/bitcoin-notes/tree/e9855dc377811b6d77bb75d8606c776cc26c1860/transaction-lifecycle.md#Validation-and-Submission-to-Mempool" target="_blank" rel="noopener">glozow&#8217;s notes</a> for examples</p>
</div>
</div>
</details>
</li>
<li>
<p><em>Why does <code>CheckInputsFromMempoolAndCache</code> exist?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>To prevent us from re-checking the scripts of transactions already in our mempool during consensus validation on learning about a new block</p>
</div>
</div>
</details>
</li>
<li>
<p><em>Which function(s) are in charge of validating the merkle root of a block?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>BlockMerkleRoot()</code> and <code>BlockWitnessMerkleRoot()</code> construct a vector of merkle leaves, which is then passed to <code>ComputeMerkleRoot()</code> for calculation.</p>
</div>
</div>
</details>
</li>
<li>
<p><em>Can you find any evidence (e.g. PRs) which have been made in an effort to modularize consensus code?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>A few examples: <a href="https://github.com/bitcoin/bitcoin/pull/10279" target="_blank" rel="noopener">PR#10279</a>, <a href="https://github.com/bitcoin/bitcoin/pull/20158" target="_blank" rel="noopener">PR#20158</a></p>
</div>
</div>
</details>
</li>
<li>
<p><em>What is the function of <code>BlockManager()</code>?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>It manages the current most-work chaintip and pruning of unneeded blocks (<code>*.blk</code>) and associated undo (<code>*.rev</code>) files</p>
</div>
</div>
</details>
</li>
<li>
<p><em>What stops a malicious node from sending multiple invalid headers to try and use up a nodes' disk space? (hint: these might be stored in <code>BlockManager.m_failed_blocks</code>)</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p>Even invalid headers would need a valid proof of work which would be too costly to construct for a spammer</p>
</div>
</div>
</details>
</li>
<li>
<p><em>Which functions are responsible for writing consensus-valid blocks to disk?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>src/node/blockstorage.h#SaveBlockToDisk</code></p>
</div>
</div>
</details>
</li>
<li>
<p><em>Are there any other components to Bitcoin Core which, similarly to the block storage database, are not themselves performing validation but can still be consensus-critical?</em></p>
<p>Not sure myself, sounds like an interesting question though!</p>
</li>
<li>
<p><em>In which module (and class) is signature verification handled?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>src/script/interpreter.cpp#BaseSignatureChecker</code></p>
</div>
</div>
</details>
</li>
<li>
<p><em>Which function is used to calculate the Merkle root of a block, and from where is it called?</em></p>
<details>
<summary class="title">Click for answer</summary>
<div class="content">
<div class="paragraph">
<p><code>src/consensus/merkle.cpp#ComputeMerkleRoot</code> is used to compute the merkle root.</p>
</div>
<div class="paragraph">
<p>It is called from <code>src/chainparams.cpp#CreateGenesisBlock</code>, <code>src/miner.cpp#IncrementExtraNonce</code> &amp; <code>src/miner.cpp#RegenerateCommitments</code> and from <code>src/validation.cpp#CheckBlock</code> to validate incoming blocks.</p>
</div>
</div>
</details>
</li>
<li>
<p><em>Practical question on Merkle root calculation</em></p>
<p>TODO, add more Exercises</p>
<div class="ulist">
<ul>
<li>
<p>Modify the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/script.h#L444-L450" target="_blank" rel="noopener">code</a> which is used to add new opcodes to a <code>CScript</code> without breaking consensus.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wallet"><a class="link" href="#_wallet">Wallet</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bitcoin Core includes an optional wallet component.
The wallet allows users to make and receive transactions using their own node, so that they can validate incoming payment against their own node.</p>
</div>
<div class="paragraph">
<p>The wallet component has the following general aims:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Have best-in-class security</p>
<div class="ulist">
<ul>
<li>
<p>Be extremely well tested</p>
</li>
<li>
<p>Be reviewed by competent developers</p>
</li>
</ul>
</div>
</li>
<li>
<p>Have good privacy by default</p>
</li>
<li>
<p>Be smart about coin selection with respect to:</p>
<div class="ulist">
<ul>
<li>
<p>Transaction fees</p>
</li>
<li>
<p>Privacy</p>
</li>
</ul>
</div>
</li>
<li>
<p>Implement state-of-the-art features:</p>
<div class="ulist">
<ul>
<li>
<p>Taproot</p>
</li>
<li>
<p>Wallet descriptors</p>
</li>
<li>
<p>Miniscript</p>
</li>
</ul>
</div>
</li>
<li>
<p>Be backwards compatible with old (Bitcoin Core) wallet files where possible</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Wallets can be one of two types, "legacy" or <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/doc/descriptors.md" target="_blank" rel="noopener">"descriptor"</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bitcoin Core moved to descriptor wallets as they are unambiguous as to which public keys and scripts should be used.</p>
</div>
<div class="paragraph">
<p>They also simplify backups and make im/ex-porting wallet keys into other software less error-prone.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_wallet_overview"><a class="link" href="#_wallet_overview">Wallet overview</a></h3>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Blockchain Commons provides some examples of <a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/03_3_Setting_Up_Your_Wallet.md">Setting up a wallet</a> using the `bitcoin-cli tool.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wallet_database"><a class="link" href="#_wallet_database">Wallet Database</a></h4>
<div class="paragraph">
<p>Wallets are stored on disk as databases, either using Berkeley Database (BDB) or sqlite format.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The version of BDB we used for the wallet is unmaintained, so new wallets should prefer sqlite format
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The wallet is stored on disk as a Key Value store.</p>
</div>
<div class="literalblock">
<div class="title">Wallet database</div>
<div class="content">
<pre>flowchart BT
   database["database\n(KV store)"]

    Transactions --&gt; database
    Keys --&gt; database
    Key_metadata --&gt; database
    wallet_metadata --&gt; database
    database -- load db --&gt; CWallet</pre>
</div>
</div>
<div class="paragraph">
<p>These are some of the <a href="https://github.com/bitcoin/bitcoin/blob/master/src/wallet/walletdb.cpp#L30-L62" target="_blank" rel="noopener">records</a> which help us regenerate a descriptor wallet (populating a <code>DescriptorScriptPubKeyMan</code> (DSPKM)) from the database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// walletdb.cpp
const std::string WALLETDESCRIPTOR{"walletdescriptor"};
const std::string WALLETDESCRIPTORCACHE{"walletdescriptorcache"};
const std::string WALLETDESCRIPTORLHCACHE{"walletdescriptorlhcache"};
const std::string WALLETDESCRIPTORCKEY{"walletdescriptorckey"};
const std::string WALLETDESCRIPTORKEY{"walletdescriptorkey"};</code></pre>
</div>
</div>
<div class="paragraph">
<p>For Legacy wallets (populating a <code>LegacyScriptPubKeyMan</code> (LSPKM)) we use the records with <code>*.KEY</code> &amp; <code>SCRIPT</code>.</p>
</div>
<div class="paragraph">
<p>Wallet metadata may include a <code>tipLocator</code>&#8201;&#8212;&#8201;the most recent tip&#8201;&#8212;&#8201;and a wallet <code>version</code> which is used in database upgrades.</p>
</div>
<div class="paragraph">
<p>To load the wallet we read the database by iterating the records and loading them to <code>CWallet</code>, using <code>ReadKeyValue()</code> to deserialize.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Loading wallet records from the database</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Record</th>
<th class="tableblock halign-left valign-top">Load point</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DBKeys::TX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Bitcoin) transactions end up in <code>mapWallet</code> via the call to <code>pwallet&#8594;LoadToWallet(hash, fill_wtx)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DBKeys::KEY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys for legacy wallets are loaded into <code>CKey</code> or <code>Key</code>, then read into the appropriate SPKM (or one is created and keys added to it) using <code>pwallet&#8594;GetOrCreateLegacyScriptPubKeyMan()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DBKeys::WALLETDESCRIPTOR</code><br>
<code>DBKeys::WALLETDESCRIPTORCACHE</code><br>
<code>DBKeys::WALLETDESCRIPTORLHCACHE</code><br>
<code>DBKeys::WALLETDESCRIPTORKEY</code><br>
<code>DBKeys::WALLETDESCRIPTORCKEY</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descriptor wallet information generally goes into <code>DescriptorScriptPubKeyMan</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DBKeys::NAME</code><br>
<code>DBKeys::PURPOSE</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Addresses go into <code>m_address_book</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can see where all the other DB records are deserialized to by examining the <code>ReadKeyValue()</code> <a href="https://github.com/bitcoin/bitcoin/blob/master/src/wallet/walletdb.cpp#L321-L746">function</a>.</p>
</div>
<div class="paragraph">
<p>The various <code>*ScriptPubkeyMan</code> objects are all owned by the <code>CWallet</code> instance eventually, however <code>LegacyScriptPubKeyMan</code> is both created and owned by <code>CWallet</code>, whereas <code>DescriptorScriptPubKeyMan</code> is created externally to <code>CWallet</code> and only after loading exists in the <code>CWallet</code> context.</p>
</div>
<div class="paragraph">
<p>Note that <code>TxSpends</code> is <strong>not</strong> tracked in the wallet database (and loaded at startup), but instead is rebuilt from scratch because it&#8217;s fast to do so and we must reload every transaction anyway, so it&#8217;s not much more work to regenerate <code>TxSpends</code> at the same time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_key_type_classes_in_the_wallet"><a class="link" href="#_key_type_classes_in_the_wallet">Key-type classes in the wallet</a></h4>
<div class="paragraph">
<p>There are a number of <code>Key</code> classes in the wallet code and keeping track of their functions can be confusing at times due to naming similarities.
Below are listed some of these classes along with some primary functions.</p>
</div>
<div id="wallet-key-types" class="sidebarblock">
<div class="content">
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>CKey</code>
</td>
<td class="hdlist2">
<p>An encapsulated private key. Used for signing and deriving child keys.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CKeyID</code>
</td>
<td class="hdlist2">
<p>A <em>reference</em> to a <code>CKey</code> by the hash160 of its pubkey. Used for key lookups when fetching keys e.g. for signing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CPrivKey</code>
</td>
<td class="hdlist2">
<p>A serialized (OpenSSL format) private key with associated parameters. Used to read/write private keys to/from the database.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CPubKey</code>
</td>
<td class="hdlist2">
<p>A public key. Used in many places.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CExtKey</code>
</td>
<td class="hdlist2">
<p>An extended public key (includes private key and chaincode). Used for deriving BIP32 child keys.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CMasterKey</code>
</td>
<td class="hdlist2">
<p>Contains an encryption salt <code>vchSalt</code> and a randomly generated encryption key <code>vchCryptedKey</code>. The <code>CMasterKey</code> object itself is what is encrypted by the user&#8217;s passphrase and the inner <code>vchCryptedKey</code> is what is used to en/de-crypt the wallet keys.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CKeyingMaterial</code>
</td>
<td class="hdlist2">
<p>Plain text which is to be encrypted or has been decrypted using the <code>CMasterKey</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CKeyPool</code>
</td>
<td class="hdlist2">
<p>A single key which has been taken from a <code>CWallet</code>'s keypool for use. <code>CKeyPool</code> keys are stored in the wallet database.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>CryptedKeyMap</code>
</td>
<td class="hdlist2">
<p>A map of <code>CKeyID</code> to a pair of (<code>CPubKey</code> + an encrypted private key). Used to lookup keys (by <code>CKeyID</code>) when the wallet is encrypted.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_encryption"><a class="link" href="#_encryption">Encryption</a></h4>
<div class="paragraph">
<p>There is encryption in the wallet code, but it is found within both <code>CWallet</code> and <code>*ScriptPubKeyMan</code> so is not yet well encapsulated.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When encryption is enabled secret data must only ever reside in memory and should <strong>never</strong> be written to disk.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you unlock an encrypted wallet you can set a <code>timeout</code>.
When the timeout expires secret data is deleted from memory, and the wallet "re-locked".</p>
</div>
<div class="sect4">
<h5 id="_decrypting_the_wallet"><a class="link" href="#_decrypting_the_wallet">Decrypting the wallet</a></h5>
<div class="paragraph">
<p>As detailed in <a href="#wallet-key-types">Key Types</a>, the <code>CMasterKey.vchCryptedKey</code> is the actual secret key used to en/de-crypt the keys in the wallet.</p>
</div>
<div class="paragraph">
<p><code>CWallet</code> stores a <code>CMasterKey</code>, which is <strong>not</strong> a <a href="https://github.com/bitcoinbook/bitcoinbook/blob/173974f69e263c7de536a334224d642e6dca7d71/ch05.asciidoc#HDWalletFromSeed" target="_blank" rel="noopener">master private key</a>.
The <code>CMasterKey</code> is encrypted by the user&#8217;s passphrase.</p>
</div>
<div class="paragraph">
<p>When the user changes their passphrase, they are only changing the encryption applied to the <code>CMasterKey</code>, the inner <code>vchCryptedKey</code> is not changed.
This means that we do not have to read all items in the wallet database, decrypt them with the old key, encrypt them with the new key, and then write them, back to the database again.
Instead, we only have to change the encryption applied to the <code>CMasterKey</code>, which is much less error-prone, and more secure.</p>
</div>
<div class="paragraph">
<p>Each <code>CWallet</code> has a map of <code>CMasterKey</code>s and when unlock is called it will try each one to see if it can decrypt and then unlock the wallet.</p>
</div>
</div>
<div class="sect4">
<h5 id="_encrypting_the_wallet"><a class="link" href="#_encrypting_the_wallet">Encrypting the wallet</a></h5>
<div class="paragraph">
<p>Only private keys are encrypted.
This allows us to watch for new transactions <em>without</em> having to decrypt the wallet as each new block|transaction arrives.</p>
</div>
<div class="paragraph">
<p>Decrypting the Bitcoin Core wallet requires the user to enter their passphrase, so is not convenient to do at every new block.</p>
</div>
<div class="paragraph">
<p>When encrypting a wallet, a <code>CMasterKey</code> encryption key is generated, which is then sent to the <code>ScriptPubKeyMan</code> to encrypt using its <code>.Encrypt()</code> method.</p>
</div>
<div class="paragraph">
<p>Once the wallet is encrypted for the first time, we re-generate all of our keys.
This is to avoid the wallet using things which were not "born encrypted" in the future.
For <code>LegacyScriptPubKeyMan</code> this means creating a new HD seed, and for <code>DescriptorScriptPubKeyMan</code> 8 new descriptors.</p>
</div>
<div class="paragraph">
<p>If the wallet has already been used before&#8201;&#8212;&#8201;while it existed in un-encrypted state&#8201;&#8212;&#8201;the old <code>ScriptPubKeyMan</code>'s are retained and so remain usable, but are not marked as <code>active</code>.
The wallet will switch to the new SPKM after encryption has completed by marking the new SPKM as <code>active</code>.</p>
</div>
<div class="paragraph">
<p>We take extra care during the encryption phase to either complete atomically or fail.
This includes database writes where we don&#8217;t want to write half and crash, for example.
Therefore we will throw an assertion if the write fails.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you instruct a BDB database to delete a record, they are actually kept but "marked as" deleted, and <em>might</em> be fully deleted some time in the future.</p>
</div>
<div class="paragraph">
<p>This is not appropriate for our use case, for example when asking the DB to delete private keys after the wallet is encrypted for the first time.
Therefore we use some <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L758-L765" target="_blank" rel="noopener">hacks</a> so that when we request deletion of unencrypted private keys from the DB, they are properly deleted immediately and not "marked as" deleted.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When encryption is enabled secret data must only ever exist in decrypted form in memory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>See <a href="https://github.com/bitcoin/bitcoin/pull/27080">#27080</a> for details on how the master key was not always cleared fully from memory after the wallet was locked.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_transaction_tracking"><a class="link" href="#_transaction_tracking">Transaction tracking</a></h4>
<div class="paragraph">
<p>When we learn about a new block the <code>BlockConnected</code> signal is <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L2940" target="_blank" rel="noopener">fired</a> after successful validation.
This prompts the wallet to <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1317-L1328" target="_blank" rel="noopener">iterate</a> all inputs and outputs, calling <code>IsMine()</code> on all of them.
As part of the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1100" target="_blank" rel="noopener">check</a>, we <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1394-L1396" target="_blank" rel="noopener">loop</a> over the wallet&#8217;s <code>scriptPubkeyMan</code>s to check if any of the scripts belong to us.</p>
</div>
<div class="paragraph">
<p>If a script does belong to us, it will be inserted into <code>mapWallet</code> along with some metadata related to the time.
<code>mapWallet</code> contains all the transactions the wallet is interested in, including received and sent transactions.</p>
</div>
<div class="paragraph">
<p>When we <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L237" target="_blank" rel="noopener">load</a> a wallet into memory, we iterate all <code>TxSpends</code>.
<code>TxSpends</code> stores wallet transactions which were already spent and confirmed.</p>
</div>
<div class="paragraph">
<p>Therefore, when the wallet needs to select coins to spend, it can select from the coins:</p>
</div>
<div class="paragraph">
<p><code>mapWallet - TxSpends - notMine</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_calculating_a_balance"><a class="link" href="#_calculating_a_balance">Calculating a balance</a></h4>
<div class="paragraph">
<p>For balance calculation we <a href="https://github.com/bitcoin/bitcoin/blob/master/src/wallet/receive.cpp#L293-L320" target="_blank" rel="noopener">iterate</a> <code>mapWallet</code> and add values to a <code>Balance</code> struct.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">struct Balance {
    CAmount m_mine_trusted{0};           //!&lt; Trusted, at depth=GetBalance.min_depth or more
    CAmount m_mine_untrusted_pending{0}; //!&lt; Untrusted, but in mempool (pending)
    CAmount m_mine_immature{0};          //!&lt; Immature coinbases in the main chain
    CAmount m_watchonly_trusted{0};
    CAmount m_watchonly_untrusted_pending{0};
    CAmount m_watchonly_immature{0};
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>We do some caching during iteration so that we avoid re-calculating the same values for multiple transactions.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Wallet balance terminology</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>debit</code>
</td>
<td class="hdlist2">
<p>amount out</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>credit</code>
</td>
<td class="hdlist2">
<p>amount in</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>availableCredit</code>
</td>
<td class="hdlist2">
<p>amount available to send out (not dirty or immature)</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Calculating the above requires using <code>TxSpends</code> and <code>IsMine</code>.</p>
</div>
<div class="paragraph">
<p>When a new transaction involving the wallet takes place, really what happens is that it&#8217;s marked as <code>DIRTY</code>, which deletes the cached entry for the parent transaction.
This means that the next time <code>GetBalance()</code> is called, <code>debit</code> is recalculated correctly.
<a href="https://bitcoincore.reviews/18113" target="_blank" rel="noopener">This</a> Bitcoin Core PR review club goes into more detail on coins being marked as <code>DIRTY</code> and <code>FRESH</code> in the cache.</p>
</div>
<div class="paragraph">
<p><code>TxSpends</code> is calculated by looking at the outpoints in the transaction itself.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title"><code>COutput</code> vs <code>COutPoint</code></div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>COutPoint</code>
</td>
<td class="hdlist2">
<p>a pair of <code>txid : index</code>, useful when you want to know which UTXO an input spends.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>COutput</code>
</td>
<td class="hdlist2">
<p>created for coin selection and contains the entire previous UTXO (script, amount), along with helpers for calculating fees and effective value.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>COutput</code>s are ephemeral&#8201;&#8212;&#8201;we create them, perform another operation with them and discard them.
They are stored in <code>availableCoins</code> which is recreated when calling functions such as <code>GetAvailableBalance()</code>, <code>ListCoins()</code> and <code>CreateTransactionInternal()</code>.</p>
</div>
<div class="paragraph">
<p>In a spending transaction all inputs have their corresponding <code>OutPoints</code>, and we map these to spending transactions in <code>TxSpends</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
We assume anything (i.e. transactions) that reach the wallet have already been validated by the node and we therefore blindly assume that it is valid in wallet code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a transaction is our own we check for validity with <code>testMempoolAccept</code> before submitting to the P2P network.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ismine"><a class="link" href="#_ismine">IsMine</a></h4>
<div class="paragraph">
<p>For DSPKM running <code>IsMine()</code> is really simple: descriptors generate a list of ScriptPubKeys, and, if the SPK we are interested in is in the list, then it&#8217;s ours.</p>
</div>
<div class="paragraph">
<p><code>IsMine</code> returns an <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/ismine.h#L20-L49" target="_blank" rel="noopener">enum</a>.
This is used as a return value, a filter and set of flags simultaneously.
There is more background on the general <code>IsMine</code> semantics in the v0.21.0 <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.21.0.md#ismine-semantics" target="_blank" rel="noopener">release notes</a>.</p>
</div>
<div class="paragraph">
<p>LSPKM can have watch-only and spendable flags set at the same time, but DSPKM is either or, because descriptor wallets do not allow mixtures of spendable and watch-only keys in the same SPKM.
Because Legacy wallets are all key-based, we will need to see if a script <em>could have been generated by one of our keys</em>; what type of script it is; and if we have a (private) key for it.</p>
</div>
<div class="paragraph">
<p>For Legacy watch-only wallets we simply check "do we have this script stored as a script?" (where <code>CScripts</code> in the database are our watch-only scripts)".
If we don&#8217;t have a <code>CKey</code> for a script but it exists in <code>mapScripts</code> then it&#8217;s implicitly watch-only.</p>
</div>
<div class="paragraph">
<p>A problem with this current method of <code>IsMine</code> for legacy wallets is that it&#8217;s tough to figure out what your wallet considers "Mine"&#8201;&#8212;&#8201;it&#8217;s probably a finite set, but maybe not&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Another consideration is that the LSPKM <code>IsMine</code> includes P2PK outputs&#8201;&#8212;&#8201;which don&#8217;t have addresses!
This un-enumerability can be an issue in migration of Legacy to Descriptor wallets.</p>
</div>
<div class="paragraph">
<p>There is also the possibility that someone can mutate address to different address type and you will still see it as <code>IsMine</code>. E.g. mutate P2PK into P2PKH address and wallet will still detect.</p>
</div>
<div class="paragraph">
<p>With descriptors we only look for scripts explicitly.
With descriptor wallets <code>IsMine</code> might not recognise script hashes from scripts, because it was not told to watch for them and consider them as belonging to it.</p>
</div>
<div class="paragraph">
<p>We use the <code>IsMine</code> filters in many places, primarily to distinguish between spendable and watch-only:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>IsMine::All</code></dt>
<dd>
<p>spendable and watch-only (use for legacy wallet)</p>
</dd>
<dt class="hdlist1"><code>IsMine::Used</code></dt>
<dd>
<p>not used by <code>IsMine</code>, but instead used as a filter for tracking when addresses have been reused.</p>
</dd>
</dl>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>PR <a href="https://github.com/bitcoin/bitcoin/pull/19602" target="_blank" rel="noopener">19602</a> enables migration of legacy wallets &#8594; descriptor wallets from Bitcoin Core version 24.0.
Although legacy wallets are now effectively end of life it&#8217;s still relevant to have documentation for legacy wallets.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>See the section on how wallets determine whether transactions belong to them using the <a href="#ismine-enum">IsMine</a> enum for more in-depth information.</p>
</div>
</div>
<div class="sect3">
<h4 id="_conflict_tracking"><a class="link" href="#_conflict_tracking">Conflict tracking</a></h4>
<div class="paragraph">
<p>Conflict tracking is related to changing the state as the mempool tells us about conflicting transactions.</p>
</div>
<div class="paragraph">
<p><code>mapTxSpends</code> is a multimap which permits having the same <code>COutPoint</code> mapping to <em>two</em> transactions. (i.e. two transactions spending the same input)
This is how we can tell if things are conflicted: look up an outpoint and check to see how many transactions are there, if &gt; 1 then we know that there was a conflict.</p>
</div>
<div class="paragraph">
<p>If there is a conflict we can look up the wallet transaction and see what state it&#8217;s in, and we can be sure about whether it is currently or previously conflicted.</p>
</div>
<div class="paragraph">
<p>Conflict tracking is particularly relevant for coin selection&#8230;&#8203;</p>
</div>
</div>
<div class="sect3">
<h4 id="coin-selection-overview"><a class="link" href="#coin-selection-overview">Coin selection</a></h4>
<div class="paragraph">
<p>See <a href="https://bitcoinops.org/en/topics/coin-selection/" target="_blank" rel="noopener">Bitcoin Optech</a> for more information on coin selection.
There is a section digging deeper into the coin selection code found <a href="#coin-selection">below</a>.
To select inputs to a transaction our primary considerations are privacy and fees.</p>
</div>
<div class="paragraph">
<p>The below sections form an overview of creating a transaction via <code>CreateTransactionInternal()</code>.</p>
</div>
<div class="sect4">
<h5 id="_availablecoins"><a class="link" href="#_availablecoins"><code>AvailableCoins()</code></a></h5>
<div class="paragraph">
<p>The gist of how we generate a list of coins available to spend (via <code>AvailableCoins()</code>) is that we iterate <code>mapWallet</code> and check for coins that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Are not immature coinbase outputs</p>
</li>
<li>
<p>Are not conflicted</p>
</li>
<li>
<p>Must be at least in our mempool</p>
</li>
<li>
<p>Not currently replacing or being replaced by another transaction</p>
</li>
<li>
<p>Are not locked</p>
</li>
<li>
<p>Are <code>IsMine</code></p>
</li>
<li>
<p>Are <code>spendable</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and return them as a <code>std::vector&lt;COutput&gt;</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="GroupOutputs"><a class="link" href="#GroupOutputs"><code>GroupOutputs()</code></a></h5>
<div class="paragraph">
<p>Once we have this vector of coins <code>GroupOutputs()</code> will turn them into <code>OutputGroup</code>s.
An <code>OutputGroup</code> consists of outputs with the same script, i.e. "coins sent to the same address".</p>
</div>
</div>
<div class="sect4">
<h5 id="selectCoins"><a class="link" href="#selectCoins"><code>selectCoins()</code></a></h5>
<div class="paragraph">
<p>If you manually choose inputs, it will add outputs to the transaction automatically.
It tries first to make sure that all outputs selected have 6 confirmations, if unsuccessful it then tries again with 1 confirmation as the lower bound.</p>
</div>
<div class="paragraph">
<p>For change outputs it starts with 1 confirmation and then again with 0.
If this is still unsuccessful it increases the number of ancestors and descendants that unconfirmed change can have.</p>
</div>
</div>
<div class="sect4">
<h5 id="_attemptselection"><a class="link" href="#_attemptselection"><code>AttemptSelection()</code></a></h5>
<div class="paragraph">
<p>This function is orchestrating the <a href="#GroupOutputs">Output group</a> creation, and then the <a href="#selectCoins">coin selection</a>.
Currently, this is always based on the <a href="#coin-selection">waste metric</a>.</p>
</div>
<div class="paragraph">
<p>It is using 3 algorithms and then selecting the "best" of the three (based on the waste metric):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Branch n bound (bnb)</p>
</li>
<li>
<p>Knapsack</p>
</li>
<li>
<p>Single Random Draw (SRD)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There is currently an idea that a limited SRD could replace Knapsack in the future.
Due to this plan for removal, it would not make sense to focus development effort on improving the Knapsack algorithm at this time.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_transaction_creation"><a class="link" href="#_transaction_creation">Transaction creation</a></h4>
<div class="paragraph">
<p>Once the coins have been selected they are returned back to <code>CreateTransactionInternal()</code>, which will create the final transaction.</p>
</div>
<div class="paragraph">
<p>Right now when we determine the change output, we don&#8217;t use what <code>selectionResult</code> says the change output should be.
What we actually do is make the tx with in? outputs and set the change amount to be the sum inputs-outputs, so the change amount includes the transaction fee.
To get the correct change amount we now calculate the size of this after signing, we use dummysigner to add a dummy signature (74 0&#8217;s and the correct script), and now we can calculate the correct fee.
We reduce that fee from the change output amount, and if this now goes below <strong>some threshold?</strong> (the "cost of change" thing from BnB) or if it is dust we drop the change output and add it&#8217;s value to the fee.</p>
</div>
<div class="paragraph">
<p>So now we have an unsigned tx which we need to sign.</p>
</div>
</div>
<div class="sect3">
<h4 id="_signing"><a class="link" href="#_signing">Signing</a></h4>
<div class="paragraph">
<p>We pass the tx to <code>CWallet::SignTransaction()</code> which will call <code>IsMine()</code> on each input to figure out which ScriptPubKeyMan (spkman) owns that input, then ask the spkman to fetch its <code>SigningProviders</code> to provide the signer which can sign the transaction, and return that to us.</p>
</div>
<div class="paragraph">
<p>With PSBTs we have the <code>fillPSBT()</code> method in <code>CWallet</code> which calls <code>*ScriptPubKeyMan::fillPSBT()</code>.
We do this because we can add previous UTXOs due to transaction tracking; the SPKM adds the scripts and key derivation paths and will then optionally sign.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_separation_of_wallet_and_node"><a class="link" href="#_separation_of_wallet_and_node">Separation of wallet and node</a></h3>
<div class="paragraph">
<p>Both the <code>bitcoind</code> and <code>bitcoin-qt</code> programs use the same source code for the wallet component.
<code>bitcoin-qt</code> is not therefore a gui frontend for <code>bitcoind</code> but a stand-alone binary which happens to share much of the same code.
There has been discussion since at least as early as 2014 about <a href="https://github.com/bitcoin/bitcoin/issues/3882" target="_blank" rel="noopener">splitting wallet code</a> out from the rest of the codebase, however this has not been completed yet.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki//Process-Separation" target="_blank" rel="noopener">Process Separation</a> project is tracking development working towards separating out node, wallet and GUI code even further.
In the mean time developers have preferred to focus on improving the organisation of the (wallet) source code within the project and to focus on making wallet code more asynchronous and independent of node code, to avoid locking the node while wallet code-paths are executing.</p>
</div>
<div class="sect3">
<h4 id="_wallet_interfaces"><a class="link" href="#_wallet_interfaces">Wallet interfaces</a></h4>
<div class="paragraph">
<p>In order to facilitate code separation, distinct interfaces between the node and the wallet have been created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The node holds a <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/interfaces.cpp#L114" target="_blank" rel="noopener"><code>WalletImpl</code></a> interface to call functions on the wallet.</p>
</li>
<li>
<p>The wallet holds a <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/node/interfaces.cpp#L452" target="_blank" rel="noopener"><code>ChainImpl</code></a> interface to call functions on the node.</p>
</li>
<li>
<p>The node notifies the wallet about new transactions and blocks through the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/node/interfaces.cpp#L364" target="_blank" rel="noopener"><code>CValidationInterface</code></a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For more information on <code>*Impl</code> classes see <a href="#pimpl-technique">PIMPL technique</a> in the appendix.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wallet_component_initialisation"><a class="link" href="#_wallet_component_initialisation">Wallet component initialisation</a></h3>
<div class="paragraph">
<p>The wallet component is initialized via the <code>WalletInitInterface</code> class as specified in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/walletinitinterface.h#L14-L26" target="_blank" rel="noopener"><em>src/walletinitinterface.h</em></a>.
The member functions are marked as virtual in the <code>WalletInitInterface</code> definition, indicating that they are going to be overridden later by a derived class.</p>
</div>
<div class="paragraph">
<p>Both <em>wallet/init.cpp</em> and <em>dummywallet.cpp</em> include derived classes which override the member functions of <code>WalletInitInterface</code>, depending on whether the wallet is being compiled in or not.</p>
</div>
<div class="paragraph">
<p>The primary <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/Makefile.am#L389-L394" target="_blank" rel="noopener"><em>src/Makefile.am</em></a> describes which of these modules is chosen to override: if <code>./configure</code> has been run with the wallet feature enabled (default), then <em>wallet/init.cpp</em> is added to the sources, otherwise (<code>./configure --disable-wallet</code>) <em>dummywallet.cpp</em> is added:</p>
</div>
<div class="listingblock">
<div class="title">src/Makefile.am</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="sh">if ENABLE_WALLET
libbitcoin_server_a_SOURCES += wallet/init.cpp
endif
if !ENABLE_WALLET
libbitcoin_server_a_SOURCES += dummywallet.cpp
endif</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>src/walletinitinterface.h</em> declares the global <code>g_wallet_init_interface</code>  which will handle the configured <code>WalletInitInterface</code>.</p>
</div>
<div class="paragraph">
<p>The wallet interface is created when the <code>Construct()</code> method is called on the <code>g_wallet_init_interface</code> object by <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1179-L1184" target="_blank" rel="noopener"><code>AppInitMain()</code></a> in <em>init.cpp</em>.
<code>Construct</code> takes a reference to a <code>NodeContext</code> as argument, and then checks that the wallet has not been disabled by a runtime argument before calling <code>interfaces::MakeWalletLoader()</code> on the node.
This initialises a new <code>WalletLoader</code> object which is then added to the <code>node</code> object, both to the general list of <code>node.chain_clients</code> (wallet processes or other clients which want chain information from the node) in addition to being assigned as the unique <code>node.wallet_client</code> role, which specifies the particular <code>node.chain_client</code> that should be used to load or create wallets.</p>
</div>
<div class="paragraph">
<p>The <code>NodeContext</code> struct is defined as the following:</p>
</div>
<div class="quoteblock">
<div class="title">src/node/context.h</div>
<blockquote>
<div class="paragraph">
<p>&#8230;&#8203;contains references to chain state and connection state.</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;used by init, rpc, and test code to pass object references around without needing to declare the same variables and parameters repeatedly, or to use globals&#8230;&#8203;
The struct isn&#8217;t intended to have any member functions.
It should just be a collection of references that can be used without pulling in unwanted dependencies or functionality.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_wallets_and_program_initialisation"><a class="link" href="#_wallets_and_program_initialisation">Wallets and program initialisation</a></h3>
<div class="paragraph">
<p>Wallets can optionally be loaded as part of main program startup (i.e. from <em>src/init.cpp</em>).
Any wallets loaded during the life cycle of the main program are also unloaded as part of program shutdown.</p>
</div>
<div class="sect3">
<h4 id="_specifying_wallets_loaded_at_startup"><a class="link" href="#_specifying_wallets_loaded_at_startup">Specifying wallets loaded at startup</a></h4>
<div class="paragraph">
<p>Wallet(s) to be loaded as part of program startup can be specified by passing <code>-wallet=</code> or <code>-walletdir=</code> arguments to <code>bitcoind</code>/<code>bitcoin-qt</code>.
If the wallet has been compiled in but no <code>-wallet*=</code> arguments have been passed, then the default wallet directory (<em>$datadir/wallets</em>) will be checked as per <code>GetWalletDir()</code>:</p>
</div>
<div class="paragraph">
<p>Wallets can also be loaded after program startup via the <code>loadwallet</code> RPC.</p>
</div>
</div>
<div class="sect3">
<h4 id="_verifywallets"><a class="link" href="#_verifywallets">VerifyWallets</a></h4>
<div class="paragraph">
<p>Wallet verification refers to verification of the <code>-wallet</code> arguments as well as the underlying wallet database(s) on disk.</p>
</div>
<div class="paragraph">
<p>Wallets loaded via program arguments are first verified as part of <code>AppInitMain()</code> which first <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1209-L1213" target="_blank" rel="noopener">verifies wallet database integrity</a> by calling <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/load.cpp#L25-L101" target="_blank" rel="noopener"><code>VerifyWallets()</code></a> via the <code>WalletClientImpl</code> override of <code>client&#8594;verify()</code>.</p>
</div>
<div class="paragraph">
<p><code>VerifyWallets()</code> takes an <code>interfaces::Chain</code> object as argument, which is currently used to send init and error messages (about wallet verification) back to the GUI.
<code>VerifyWallets()</code> starts by checking that the <code>walletdir</code> supplied by argument, or default of <code>""</code>, is valid.
Next it loops through all wallets it finds in the <code>walletdir</code> and adds them to an <code>std::set</code> called <code>wallet_paths</code>, first de-duplicating them by tracking their absolute paths, and then checking that  the <code>WalletDatabase</code> for each wallet exists (or is otherwise constructed successfully) and can be verified.</p>
</div>
<div class="paragraph">
<p>If this check passes for all wallets, then <code>VerifyWallets()</code> is complete and will return <code>true</code> to calling function <code>AppInitMain</code>, otherwise <code>false</code> will be returned.
If <code>VerifyWallets()</code> fails and returns <code>false</code> (due to a corrupted wallet database, but notably not due to an incorrect wallet path), the main program process <code>AppInit()</code> will be immediately interrupted and shutdown.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Program shutdown on a potentially-corrupt wallet database is a deliberate design decision.
This is so that the wallet cannot display information to the user which is not guaranteed by the database.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_loadwallets"><a class="link" href="#_loadwallets">LoadWallets</a></h4>
<div class="paragraph">
<p>"Startup" wallet(s) are loaded  when <code>client&#8594;load()</code> is called on each <code>node.chain_client</code> as part of <a href="https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1728-L1732" target="_blank" rel="noopener">init.cpp</a>.</p>
</div>
<div class="listingblock">
<div class="title">src/init.cpp#AppInitMain()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">for (const auto&amp; client : node.chain_clients) {
    if (!client-&gt;load()) {
        return false;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to  <code>load()</code> on the wallet <code>chain_clients</code> has again been overridden, this time by <code>WalletClientImpl</code>'s <code>LoadWallets()</code> <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/load.cpp#L103-L139" target="_blank" rel="noopener">method</a>.
This function works similarly to <code>VerifyWallets()</code>, first creating the <code>WalletDatabase</code> (memory) object for each wallet, although this time skipping the verify step, before creating a <code>CWallet</code> object from the database and adding it to the global list of wallets, the vector <code>vpwallets</code>, by calling <code>AddWallet()</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are a number of steps in <code>init.cpp</code> that happen before the wallet is loaded, notably the blockchain is synced first.
This is a safeguard which means that wallet operations cannot be called on a wallet which has been loaded against stale blockchain data.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>init.cpp</em> is run on a single thread.
This means that calls to wallet code block further initialisation of the node.</p>
</div>
<div class="paragraph">
<p>The <code>interfaces::Chain</code> object taken as argument by <code>LoadWallets()</code> is used to pass back any error messages, exactly as it was in <a href="#_verifywallets"><code>VerifyWallets()</code></a>.
More information on <code>AddWallet()</code> can be <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L110-L120">found in <em>src/wallet.cpp</em></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_startwallets"><a class="link" href="#_startwallets">StartWallets</a></h4>
<div class="paragraph">
<p>The wallet is finally ready when (all) <code>chain_clients</code> have been started in <em>init.cpp</em> which calls the overridden <code>client&#8594;start()</code> method from the <code>WalletClientImpl</code> class, resulting in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/load.cpp#L141-L152" target="_blank" rel="noopener">src/wallet/load.cpp#StartWallets()</a> being called.</p>
</div>
<div class="paragraph">
<p>This calls the <code>GetWallets()</code> function which returns a vector of pointers to the interfaces for all loaded <code>CWallet</code> objects, called <code>vpwallets</code>.
As part of startup <code>PostInitProcess()</code> is called on each wallet which, after grabbing the main wallet lock <code>cs_wallet</code>, synchronises the wallet and mempool by adding wallet transactions not yet in a block to our mempool, and updating the wallet with any relevant transactions from the mempool.</p>
</div>
<div class="paragraph">
<p>Also, as part of <code>StartWallets</code>, <code>flushwallet</code> <em>might</em> be scheduled (if configured by argument) scheduling wallet transactions to be re-broadcast every second, although this interval is <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1869-L1912" target="_blank" rel="noopener">delayed</a> upstream with a random timer.</p>
</div>
</div>
<div class="sect3">
<h4 id="_flushwallets"><a class="link" href="#_flushwallets">FlushWallets</a></h4>
<div class="paragraph">
<p>All wallets loaded into the program are "flushed" (to disk) before shutdown.
As part of <code>init.cpp#Shutdown()</code> the <code>flush()</code> method is called on each member of <code>node.chain_clients</code> in sequence.
<code>WalletClientImpl</code> again overrides this method to call <code>wallet/load.cpp#FlushWallets()</code> which makes sure all wallet changes have been successfully flushed to the wallet database.</p>
</div>
<div class="paragraph">
<p>Finally the <code>stop()</code> method is called on each member of <code>node.chain_clients</code> which is overridden by <code>StopWallets()</code>, flushing again and this time calling <code>close()</code> on the database file.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wallet_locks"><a class="link" href="#_wallet_locks">Wallet Locks</a></h3>
<div class="paragraph">
<p>Grepping the <em>src/wallet</em> directory for locks, conventionally of the form <code>cs_*</code>, yields ~500 matches.
For comparison the entire remainder of the codebase excluding <em>src/wallet/*</em> yields almost 1000 matches.
Many of these matches are asserts and declarations, however this still illustrates that the wallet code is highly reliant on locks to perform atomic operations with respect to the current chain state.</p>
</div>
<div class="sect3">
<h4 id="_the_cs_wallet_lock"><a class="link" href="#_the_cs_wallet_lock">The <code>cs_wallet</code> lock</a></h4>
<div class="paragraph">
<p>In order to not block the rest of the program during wallet operations, each <code>CWallet</code> has its own recursive mutex <code>cs_wallet</code>:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is currently an <a href="https://github.com/bitcoin/bitcoin/issues/19303" target="_blank" rel="noopener">issue</a> tracking replacement of Recursive Mutexes with Mutexes, to make locking logic easier to follow in the codebase.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">src/wallet/wallet.h</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/*
 * Main wallet lock.
 * This lock protects all the fields added by CWallet.
 */
mutable RecursiveMutex cs_wallet;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most wallet operations whether reading or writing data require the use of the lock so that atomicity can be guaranteed.
Some examples of wallet operations requiring the lock include:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creating transactions</p>
</li>
<li>
<p>Signing transactions</p>
</li>
<li>
<p>Broadcasting/committing transactions</p>
</li>
<li>
<p>Abandoning transactions</p>
</li>
<li>
<p>Bumping transaction (fees)</p>
</li>
<li>
<p>Checking <code>IsMine</code></p>
</li>
<li>
<p>Creating new addresses</p>
</li>
<li>
<p>Calculating balances</p>
</li>
<li>
<p>Creating new wallets</p>
</li>
<li>
<p>Importing new {priv|pub}keys/addresses</p>
</li>
<li>
<p>Importing/dumping wallets</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In addition to these higher level functions, most of <code>CWallet</code>'s private member functions also require a hold on <code>cs_wallet</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_other_wallet_locks"><a class="link" href="#_other_wallet_locks">Other wallet locks</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>src/wallet/bdb.cpp</em>, which is responsible for managing BDB wallet databases on disk, has its own mutex <code>cs_db</code>.</p>
</li>
<li>
<p>If external signers have been enabled (via <code>./configure --enable-external-signer</code>) then they too have their own mutex <code>cs_desc_man</code> which is acquired when descriptors are being setup.</p>
</li>
<li>
<p><code>BlockUntilSyncedToCurrentChain()</code> has a unique lock exclude placed on it to prevent the caller from holding <code>cs_main</code> during its execution, and therefore prevent a possible deadlock:</p>
<div class="listingblock">
<div class="title">src/wallet/wallet.h</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/**
 * Blocks until the wallet state is up-to-date to /at least/ the current
 * chain at the time this function is entered
 * Obviously holding cs_main/cs_wallet when going into this call may cause
 * deadlock
 */
void BlockUntilSyncedToCurrentChain() const LOCKS_EXCLUDED(::cs_main) EXCLUSIVE_LOCKS_REQUIRED(!cs_wallet);</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_controlling_the_wallet"><a class="link" href="#_controlling_the_wallet">Controlling the wallet</a></h3>
<div class="paragraph">
<p>As we can see wallet component startup and shutdown is largely driven from outside the wallet codebase from <em>src/init.cpp</em>.</p>
</div>
<div class="paragraph">
<p>Once the wallet component is started and any wallets supplied via argument have been verified and loaded, wallet functionality ceases to be called from <em>init.cpp</em> and instead is controlled using external programs in a number of ways.
The wallet can be controlled using <code>bitcoin-cli</code> or <code>bitcoin-qt</code> GUI, and wallet files can be interacted with using the stand-alone <code>bitcoin-wallet</code> tool.</p>
</div>
<div class="paragraph">
<p>Both <code>bitcoind</code> and <code>bitcoin-qt</code> run a (JSON) RPC server which is ready to service, amongst other things, commands to interact with wallets.
The command line tool <code>bitcoin-cli</code> will allow interaction of any RPC server started by either <code>bitcoind</code> or <code>bitcoin-qt</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If using <code>bitcoin-qt</code> there is also an RPC console built into the GUI or you can run with <code>-server=1</code> to allow access via <code>bitcoin-cli</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If using the <code>bitcoin-qt</code> GUI itself then communication with the wallet is done directly via qt&#8217;s <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/qt/walletmodel.h#L51-L52" target="_blank" rel="noopener"><code>WalletModel</code> interface</a>.</p>
</div>
<div class="paragraph">
<p>Commands which can be used to control the wallet via RPC are listed in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/rpc/wallet.cpp#L662-L731" target="_blank" rel="noopener"><em>rpcwallet.cpp</em></a>.</p>
</div>
<div class="sect3">
<h4 id="_wallet_via_rpc"><a class="link" href="#_wallet_via_rpc">Wallet via RPC</a></h4>
<div class="paragraph">
<p>If we take a look at the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/rpc/wallet.cpp#L195-L238" target="_blank" rel="noopener"><code>loadwallet</code> RPC</a> we can see similarities to <code>WalletClientImpl</code>'s <code>LoadWallets()</code> function.</p>
</div>
<div class="paragraph">
<p>However this time the function will check the <code>WalletContext</code> to check that we have a wallet context (in this case a reference to a chain interface) loaded.
Next it will call <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L260-L271" target="_blank" rel="noopener"><code>wallet.cpp#LoadWallet</code></a> which starts by grabbing <code>g_loading_wallet_mutex</code> and adding the wallet to <code>g_loading_wallet_set</code>, before calling <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L227-L257" target="_blank" rel="noopener"><code>LoadWalletInternal</code></a> which adds the wallet to <code>vpwallets</code> and sets up various event notifications.</p>
</div>
<div class="paragraph">
<p>Further operation of the wallet RPCs are detailed in their man pages, but one thing to take note of is that whilst <code>loadwallet()</code> (and <code>unloadwallet()</code>) both take a <code>wallet_name</code> argument, the other wallet RPCs do not.
Therefore in order to control a specific wallet from an instance of <code>bitcoin{d|-qt}</code> that has multiple wallets loaded, bitcoin-cli must be called with the <code>-rpcwallet</code> argument, to specify the wallet which the action should be performed against, e.g. <code>bitcoin-cli --rpcwallet=your_wallet_name getbalance</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_via_bitcoin_cli_tool"><a class="link" href="#_via_bitcoin_cli_tool">Via <code>bitcoin-cli</code> tool</a></h4>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Blockchain Commons contains numerous guides and examples of controlling the wallet using <code>bitcoin-cli</code>, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/04_0_Sending_Bitcoin_Transactions.md" target="_blank" rel="noopener">Sending Bitcoin Transactions</a> including using raw transactions</p>
</li>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/05_0_Controlling_Bitcoin_Transactions.md" target="_blank" rel="noopener">Controlling Bitcoin Transactions</a> using RBF and CPFP</p>
</li>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/06_0_Expanding_Bitcoin_Transactions_Multisigs.md" target="_blank" rel="noopener">Using multisig</a> to send and receive</p>
</li>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/07_0_Expanding_Bitcoin_Transactions_PSBTs.md" target="_blank" rel="noopener">Creating and using PSBTs</a> and integrating them with hardware wallets</p>
</li>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/08_0_Expanding_Bitcoin_Transactions_Other.md" target="_blank" rel="noopener">Adding locktimes and OP_RETURN data</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cwallet"><a class="link" href="#_cwallet">CWallet</a></h3>
<div class="paragraph">
<p>The <code>CWallet</code> object is the fundamental wallet representation inside Bitcoin Core.
<code>CWallet</code> stores transactions and balances and has the ability to create new transactions.
<code>CWallet</code> also contains references to the chain interface for the wallet along with storing wallet metadata such as <code>nWalletVersion</code>, wallet flags, wallet name and address book.</p>
</div>
<div class="sect3">
<h4 id="_cwallet_creation"><a class="link" href="#_cwallet_creation">CWallet creation</a></h4>
<div class="paragraph">
<p>The <code>CWallet</code> constructor takes a pointer to the chain interface for the wallet, a wallet name and a pointer to the underlying <code>WalletDatabase</code>:</p>
</div>
<div class="paragraph">
<p>The constructor is not called directly, but instead from the public function <code>CWallet::Create()</code>, which is itself called from <code>CreateWallet()</code>, <code>LoadWallets()</code> (or <code>TestLoadWallet()</code>).
In addition to the arguments required by the constructor, <code>CWallet::Create()</code> also has a <code>wallet_flags</code> argument.
Wallet flags are represented as a single <code>unit64_t</code> bit field which encode certain wallet properties:</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/walletutil.h</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">enum WalletFlags : uint64_t {
    WALLET_FLAG_AVOID_REUSE = (1ULL &lt;&lt; 0),
    WALLET_FLAG_KEY_ORIGIN_METADATA = (1ULL &lt;&lt; 1),
    WALLET_FLAG_DISABLE_PRIVATE_KEYS = (1ULL &lt;&lt; 32),
    WALLET_FLAG_BLANK_WALLET = (1ULL &lt;&lt; 33),
    WALLET_FLAG_DESCRIPTORS = (1ULL &lt;&lt; 34),
    WALLET_FLAG_EXTERNAL_SIGNER = (1ULL &lt;&lt; 35),
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/walletutil.h#L36-L70" target="_blank" rel="noopener"><em>src/wallet/walletutil.h</em></a> for additional information on the meanings of the wallet flags.</p>
</div>
<div class="paragraph">
<p><code>CWallet::Create()</code> will first attempt to create the <code>CWallet</code> object and load it, returning if any errors are encountered.</p>
</div>
<div class="paragraph">
<p>If <code>CWallet::Create</code> is creating a new wallet&#8201;&#8212;&#8201;on its 'first run'&#8201;&#8212;&#8201;the wallet version and wallet flags will be set, before either <code>LegacyScriptPubKeyMan</code> or <code>DescriptorScriptPubKeyMan</code>'s are setup, depending on whether the <code>WALLET_FLAG_DESCRIPTORS</code> flag was set on the wallet.</p>
</div>
<div class="paragraph">
<p>Following successful creation, various program arguments are checked and applied to the wallet.
These include options such as <code>-addresstype</code>, <code>-changetype</code>, <code>-mintxfee</code> and <code>-maxtxfee</code> amongst others.
It is at this stage that warnings for unusual or unsafe values of these arguments are generated to be returned to the user.</p>
</div>
<div class="paragraph">
<p>After the wallet is fully initialized and setup, its keypool will be topped up before the wallet is locked and registered with the Validation interface, which will handle callback notifications generated during the (optional) upcoming chain rescan.
The rescan is smart in detecting the wallet "birthday" using metadata stored in the <a href="#scriptpubkeymanagers">SPKM</a> and won&#8217;t scan blocks produced before this date.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>walletinterface</code> is setup for the wallet before the <code>WalletInstance</code> is returned to the caller.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scriptpubkeymanagers"><a class="link" href="#scriptpubkeymanagers">ScriptPubKeyManagers (SPKM)</a></h3>
<div class="paragraph">
<p>Each wallet contains one or more <code>ScriptPubKeyManager</code>s which are derived from the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/scriptpubkeyman.h#L166" target="_blank" rel="noopener">base</a> SPKM class and are in control of storing the <code>scriptPubkey</code>s managed by that wallet.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>"A wallet" in the general sense therefore becomes "a collection of <code>ScriptPubKeyManager</code>s", which are each managing an address type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In the current implementation, this means that a default (descriptor) wallet consists of 8 <code>ScriptPubKeyManager</code>s, one SPKM for each combination shown in the table <a href="#descriptor-spkmans">below</a>.</p>
</div>
<table id="descriptor-spkmans" class="tableblock frame-all grid-all fit-content stretch">
<caption class="title">Table 12. Descriptor wallet SPKMans</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#160;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LEGACY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">P2SH-SEGWIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BECH32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BECH32M</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here is the <em>descriptor</em> wallet code fragment which sets up an SPKM for each <code>OUTPUT_TYPE</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/wallet.cpp#SetupDescriptorScriptPubKeyMans()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// ...

for (bool internal : {false, true}) {
    for (OutputType t : OUTPUT_TYPES) {
        auto spk_manager = std::unique_ptr&lt;DescriptorScriptPubKeyMan&gt;(new DescriptorScriptPubKeyMan(*this));
        if (IsCrypted()) {
            if (IsLocked()) {
                throw std::runtime_error(std::string(__func__) + ": Wallet is locked, cannot setup new descriptors");
            }
            if (!spk_manager-&gt;CheckDecryptionKey(vMasterKey) &amp;&amp; !spk_manager-&gt;Encrypt(vMasterKey, nullptr)) {
                throw std::runtime_error(std::string(__func__) + ": Could not encrypt new descriptors");
            }
        }
        spk_manager-&gt;SetupDescriptorGeneration(master_key, t, internal);
        uint256 id = spk_manager-&gt;GetID();
        m_spk_managers[id] = std::move(spk_manager);
        AddActiveScriptPubKeyMan(id, t, internal);
    }
}

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>By contrast a Legacy wallet will set up a <strong>single</strong> SPKM which will then be <em>aliased</em> to a SPKM for each of the 6 <code>LEGACY_OUTPUT_TYPES</code>: <code>LEGACY</code>, <code>P2SH-SEGWIT</code> and <code>BECH32</code>.
This gives it the external appearance of 6 distinct SPKMans, when really it only has 1:</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/wallet.cpp#SetupLegacyScriptPubKeyMan()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// ...

auto spk_manager = std::unique_ptr&lt;ScriptPubKeyMan&gt;(new LegacyScriptPubKeyMan(*this));
for (const auto&amp; type : LEGACY_OUTPUT_TYPES) {
    m_internal_spk_managers[type] = spk_manager.get();
    m_external_spk_managers[type] = spk_manager.get();
}
m_spk_managers[spk_manager-&gt;GetID()] = std::move(spk_manager);

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>SPKMans are stored in maps inside a <code>CWallet</code> according to output type.
"External" and "Internal" (SPKMans) refer to whether the addresses generated are designated for giving out "externally", i.e. for receiving new payments to, or for "internal", i.e. change addresses.</p>
</div>
<div class="paragraph">
<p>Prior to <a href="https://github.com/bitcoin/bitcoin/commit/c729afd0a3b74a3943e4c359270beaf3e6ff8a7b" target="_blank" rel="noopener">c729afd0</a> the equivalent SPKM functionality (fetching new addresses and signing transactions) was contained within <code>CWallet</code> itself, now however is split out for better maintainability and upgradability properties as brought about by the <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Class-Structure-Changes" target="_blank" rel="noopener">wallet box class structure changes</a>.
Therefore <code>CWallet</code> objects no longer handle keys and addresses.</p>
</div>
<div class="paragraph">
<p>The change to a <code>CWallet</code> made up of (multiple) <code>{Descriptor|Legacy}ScriptPubKeyMan</code>'s is also sometimes referred to as the "Wallet Box model", where each SPKM is thought of as a distinct "box" within the wallet, which can be called upon to perform new address generation and signing functions.</p>
</div>
<div class="sect3">
<h4 id="_keys_in_the_wallet"><a class="link" href="#_keys_in_the_wallet">Keys in the wallet</a></h4>
<div class="sect4">
<h5 id="_legacy_wallet_keys"><a class="link" href="#_legacy_wallet_keys">Legacy wallet keys</a></h5>
<div class="paragraph">
<p>Legacy wallets used the "keypool" model which stored a bunch of keys.
See <a href="https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/scriptpubkeyman.h#L52-L100" target="_blank" rel="noopener"><em>src/wallet/scriptbpubkeyman.h</em>#L52-L100</a> for historical context on the "keypool" model.</p>
</div>
<div class="paragraph">
<p>The wallet would then simply iterate over each public key and generate a scriptPubKey (a.k.a. PubKey script) and address for each type of script the wallet supported.
However this approach has a number of shortcomings (from least to most important):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>One key could have multiple addresses</p>
</li>
<li>
<p>It was difficult to sign for multisig</p>
</li>
<li>
<p>Adding new script functionality required adding new hardcoded script types into the wallet code <em>for each new type of script</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Such an approach was not scalable in the long term and so a new format of wallet needed to be introduced.</p>
</div>
</div>
<div class="sect4">
<h5 id="_descriptor_wallet_keys"><a class="link" href="#_descriptor_wallet_keys">Descriptor wallet keys</a></h5>
<div class="paragraph">
<p>Descriptor wallets instead store output script "descriptors".
These descriptors can be of <strong>any</strong> valid script type, including arbitrary scripts which might be "unknown" to the wallet software, and this means that wallets can deterministically generate addresses for any type of valid descriptor provided by the user.</p>
</div>
<div class="paragraph">
<p>Descriptors not only contain what is needed to generate an address, they also include all the script template data needed to "solve" (i.e. spend) outputs received at them.
In other words they permit a valid <code>scriptSig</code> (<code>redeemScript</code> or <code>witnessScript</code>) to be generated.
The document <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/doc/descriptors.md" target="_blank" rel="noopener">Support for Output Descriptors in Bitcoin Core</a> provides more details and examples of these output descriptors.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_how_wallets_identify_relevant_transactions"><a class="link" href="#_how_wallets_identify_relevant_transactions">How wallets identify relevant transactions</a></h4>
<div class="sect4">
<h5 id="_1_receiving_notifications_about_new_transactions_or_new_blocks"><a class="link" href="#_1_receiving_notifications_about_new_transactions_or_new_blocks">1. Receiving notifications about new transactions or new blocks</a></h5>
<div class="paragraph">
<p>When a Bitcoin Core node learns about a new transaction, the wallet component needs to determine whether it&#8217;s related to one of it&#8217;s loaded <code>CWallet</code>s.
The first thing to notice is that <code>CWallet</code> implements the <code>interfaces::Chain::Notifications</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">class CWallet final : public WalletStorage, public interfaces::Chain::Notifications</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interface gives the wallet the ability to receive notifications such as <code>transactionAddedToMempool</code>, <code>transactionRemovedFromMempool</code>, <code>blockConnected</code> and so on.
The names of these methods are self-explanatory.</p>
</div>
<div class="paragraph">
<p>To register itself as notification client, the wallet has the <code>std::unique_ptr&lt;interfaces::Handler&gt; m_chain_notifications_handler</code> attribute and it is initialized in <code>CWallet::AttachChain(&#8230;&#8203;)</code> method.</p>
</div>
<div class="paragraph">
<p>This method updates the wallet according to the current chain, scanning new blocks, updating the best block locator, and registering for notifications about new blocks and transactions. This is called when the wallet is created or loaded (<code>CWallet::Create(&#8230;&#8203;)</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">bool CWallet::AttachChain(const std::shared_ptr&lt;CWallet&gt;&amp; walletInstance, interfaces::Chain&amp; chain, const bool rescan_required, bilingual_str&amp; error, std::vector&lt;bilingual_str&gt;&amp; warnings)
{
    LOCK(walletInstance-&gt;cs_wallet);
    // allow setting the chain if it hasn't been set already but prevent changing it
    assert(!walletInstance-&gt;m_chain || walletInstance-&gt;m_chain == &amp;chain);
    walletInstance-&gt;m_chain = &amp;chain;

    walletInstance-&gt;m_chain_notifications_handler = walletInstance-&gt;chain().handleNotifications(walletInstance);
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This briefly explains how the wallet is able to listen to new transactions or blocks.
More information about the notification mechanism can be seen in the <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc#notifications-mechanism-validationinterface" target="_blank" rel="noopener">Notifications Mechanism (ValidationInterface)</a> section of <a href="https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc" target="_blank" rel="noopener">Bitcoin Architecture</a> article.</p>
</div>
</div>
<div class="sect4">
<h5 id="_2_notification_handlers"><a class="link" href="#_2_notification_handlers">2. Notification Handlers</a></h5>
<div class="paragraph">
<p>The next step is to filter which transactions interest the wallet.</p>
</div>
<div class="paragraph">
<p>Four of these notification handlers are the ones that are relevant to filter transactions.
All of them call <code>CWallet::SyncTransaction(&#8230;&#8203;)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// src/wallet/wallet.h
void SyncTransaction(const CTransactionRef&amp; tx, const SyncTxState&amp; state, bool update_tx = true, bool rescanning_old_block = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);

// src/wallet/wallet.cpp
void CWallet::SyncTransaction(const CTransactionRef&amp; ptx, const SyncTxState&amp; state, bool update_tx, bool rescanning_old_block)
{
    if (!AddToWalletIfInvolvingMe(ptx, state, update_tx, rescanning_old_block))
        return; // Not one of ours

    // If a transaction changes 'conflicted' state, that changes the balance
    // available of the outputs it spends. So force those to be
    // recomputed, also:
    MarkInputsDirty(ptx);
}

void CWallet::transactionAddedToMempool(const CTransactionRef&amp; tx, uint64_t mempool_sequence) {
    LOCK(cs_wallet);
    SyncTransaction(tx, TxStateInMempool{});
    // ...
}

void CWallet::transactionRemovedFromMempool(const CTransactionRef&amp; tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {
    // ...
    if (reason == MemPoolRemovalReason::CONFLICT) {
        // ...
        SyncTransaction(tx, TxStateInactive{});
    }
}

void CWallet::blockConnected(const CBlock&amp; block, int height)
{
    // ...
    for (size_t index = 0; index &lt; block.vtx.size(); index++) {
        SyncTransaction(block.vtx[index], TxStateConfirmed{block_hash, height, static_cast&lt;int&gt;(index)});
        transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);
    }
}

void CWallet::blockDisconnected(const CBlock&amp; block, int height)
{
    // ...
    for (const CTransactionRef&amp; ptx : block.vtx) {
        SyncTransaction(ptx, TxStateInactive{});
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>CWallet::SyncTransaction(&#8230;&#8203;)</code> adds the transaction(s) to wallet if it is relevant and then marks each input of the transaction (<code>const std::vector&lt;CTxIn&gt; CTransaction::vin</code>) as dirty so the balance can be recalculated correctly.</p>
</div>
</div>
<div class="sect4">
<h5 id="_3_scanning_the_block_chain"><a class="link" href="#_3_scanning_the_block_chain">3. Scanning the block chain</a></h5>
<div class="paragraph">
<p>Another method that calls <code>CWallet::SyncTransaction(&#8230;&#8203;)</code> is the <code>CWallet::ScanForWalletTransactions(&#8230;&#8203;)</code>, which scans the block chain (starting in <code>start_block</code> parameter) for transactions relevant to the wallet.</p>
</div>
<div class="paragraph">
<p>This method is called when manually requesting a rescan (<code>rescanblockchain</code> RPC), when adding a new descriptor or when a new key is added to the wallet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256&amp; start_block, int start_height, std::optional&lt;int&gt; max_height, const WalletRescanReserver&amp; reserver, bool fUpdate)
{
    // ...
    for (size_t posInBlock = 0; posInBlock &lt; block.vtx.size(); ++posInBlock) {
        SyncTransaction(block.vtx[posInBlock], TxStateConfirmed{block_hash, block_height, static_cast&lt;int&gt;(posInBlock)}, fUpdate, /*rescanning_old_block=*/true);
    }
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_4_addtowalletifinvolvingme"><a class="link" href="#_4_addtowalletifinvolvingme">4. <code>AddToWalletIfInvolvingMe(&#8230;&#8203;)</code></a></h5>
<div class="paragraph">
<p><code>CWallet::AddToWalletIfInvolvingMe</code> performs the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the transaction is confirmed, it checks if it conflicts with another.
If so, marks the transaction (and its in-wallet descendants) as conflicting with a particular block (<code>if (auto* conf = std::get_if&lt;TxStateConfirmed&gt;(&amp;state))</code>).</p>
</li>
<li>
<p>It checks if the wallet already contains the transaction.
If so, updates if requested in the <code>fUpdate</code> parameter or finishes the execution (<code>if (fExisted &amp;&amp; !fUpdate) return false;</code>).</p>
</li>
<li>
<p>It checks if the transaction interests the wallet (<code>if (fExisted || IsMine(tx) || IsFromMe(tx))</code>)</p>
<div class="ulist">
<ul>
<li>
<p>If so, it checks if any keys in the wallet keypool that were supposed to be unused have appeared in a new transaction.</p>
<div class="ulist">
<ul>
<li>
<p>If so, removes those keys from the keypool (<code>for (auto &amp;dest : spk_man&#8594;MarkUnusedAddresses(txout.scriptPubKey))</code>).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Finally, it adds the transaction to the wallet (<code>AddToWallet(&#8230;&#8203;)</code>).
This function inserts the new transaction in <code>CWallet::mapWallet</code>, updates it with relevant information such as <code>CWalletTx::nTimeReceived</code> (time it was received by the node), <code>CWalletTx::nOrderPos</code> (position in ordered transaction list) and so on.</p>
<div class="paragraph">
<p>This function also writes the transaction to database (<code>batch.WriteTx(wtx)</code>) and mark the transaction as dirty to recalculate balance.</p>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title"><em>src/wallet/wallet.cpp</em></div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef&amp; ptx, const SyncTxState&amp; state, bool fUpdate, bool rescanning_old_block)
{
    const CTransaction&amp; tx = *ptx;
    {
        AssertLockHeld(cs_wallet);

        if (auto* conf = std::get_if&lt;TxStateConfirmed&gt;(&amp;state)) {
            // ...
        }

        bool fExisted = mapWallet.count(tx.GetHash()) != 0;
        if (fExisted &amp;&amp; !fUpdate) return false;
        if (fExisted || IsMine(tx) || IsFromMe(tx))
        {
            for (const CTxOut&amp; txout: tx.vout) {
                for (const auto&amp; spk_man : GetScriptPubKeyMans(txout.scriptPubKey)) {
                    for (auto &amp;dest : spk_man-&gt;MarkUnusedAddresses(txout.scriptPubKey)) {
                        // ...
                    }
                }
            }

            TxState tx_state = std::visit([](auto&amp;&amp; s) -&gt; TxState { return s; }, state);
            return AddToWallet(MakeTransactionRef(tx), tx_state, /*update_wtx=*/nullptr, /*fFlushOnClose=*/false, rescanning_old_block);
        }
    }
    return false;
}

CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const TxState&amp; state, const UpdateWalletTxFn&amp; update_wtx, bool fFlushOnClose, bool rescanning_old_block)
{
    LOCK(cs_wallet);

    WalletBatch batch(GetDatabase(), fFlushOnClose);

    uint256 hash = tx-&gt;GetHash();

    // ...

    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(tx, state));
    CWalletTx&amp; wtx = (*ret.first).second;
    // ...
    if (fInsertedNew) {
        wtx.nTimeReceived = GetTime();
        wtx.nOrderPos = IncOrderPosNext(&amp;batch);
        // ...
    }

    // ...

    // Write to disk
    if (fInsertedNew || fUpdated)
        if (!batch.WriteTx(wtx))
            return nullptr;

    // Break debit/credit balance caches:
    wtx.MarkDirty();

    // ...

    return &amp;wtx;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_5_cwalletismine"><a class="link" href="#_5_cwalletismine">5. <code>CWallet::IsMine(&#8230;&#8203;)</code></a></h5>
<div class="paragraph">
<p>As the name implies, the method that actually identifies which transactions belong to the wallet is <code>IsMine()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">isminetype CWallet::IsMine(const CScript&amp; script) const
{
    AssertLockHeld(cs_wallet);
    isminetype result = ISMINE_NO;
    for (const auto&amp; spk_man_pair : m_spk_managers) {
        result = std::max(result, spk_man_pair.second-&gt;IsMine(script));
    }
    return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the <code>CWallet::IsMine(const CScript&amp; script)</code> is just a proxy to the <code>ScriptPubKeyMan::IsMine(const CScript &amp;script)</code>.
This is an important distinction, because in Bitcoin Core the class <code>CWallet</code> does not manage the keys.
This work is done by <code>ScriptPubKeyMan</code> subclasses: <code>DescriptorScriptPubKeyMan</code> and <code>LegacyScriptPubKeyMan</code>.
All <code>ScriptPubKeyMan</code> instances belonging to the wallet are stored in <code>CWallet::m_spk_managers</code>.</p>
</div>
<div class="paragraph">
<p>Another important aspect of that method is the return type, the <code>enum isminetype</code>.
This type is defined in <code>src/wallet/ismine.h</code>.</p>
</div>
<div id="ismine-enum" class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">enum isminetype : unsigned int {
    ISMINE_NO         = 0,
    ISMINE_WATCH_ONLY = 1 &lt;&lt; 0,
    ISMINE_SPENDABLE  = 1 &lt;&lt; 1,
    ISMINE_USED       = 1 &lt;&lt; 2,
    ISMINE_ALL        = ISMINE_WATCH_ONLY | ISMINE_SPENDABLE,
    ISMINE_ALL_USED   = ISMINE_ALL | ISMINE_USED,
    ISMINE_ENUM_ELEMENTS,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>LegacyScriptPubKeyMan</code>:
* <code>ISMINE_NO</code>: the scriptPubKey is not in the wallet;
* <code>ISMINE_WATCH_ONLY</code>: the scriptPubKey has been imported into the wallet;
* <code>ISMINE_SPENDABLE</code>: the scriptPubKey corresponds to an address owned by the wallet user (who can spend with the private key);
* <code>ISMINE_USED</code>: the scriptPubKey corresponds to a used address owned by the wallet user;
* <code>ISMINE_ALL</code>: all ISMINE flags except for USED;
* <code>ISMINE_ALL_USED</code>: all ISMINE flags including USED;
* <code>ISMINE_ENUM_ELEMENTS</code>: the number of isminetype enum elements.</p>
</div>
<div class="paragraph">
<p>For <code>DescriptorScriptPubKeyMan</code> and future <code>ScriptPubKeyMan</code>:
* <code>ISMINE_NO</code>: the scriptPubKey is not in the wallet;
* <code>ISMINE_SPENDABLE</code>: the scriptPubKey matches a scriptPubKey in the wallet.
* <code>ISMINE_USED</code>: the scriptPubKey corresponds to a used address owned by the wallet user.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>IsMine</code> historically was located outside of the wallet code, but now takes a more logical position as a member function of <code>CWallet</code> which returns an <code>isminetype</code> value from an enum.</p>
</div>
<div class="paragraph">
<p>More information on the <code>IsMine</code> semantics can be found in <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.21.0.md#ismine-semantics" target="_blank" rel="noopener">release-notes-0.21.0.md#ismine-semantics</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_6_descriptorscriptpubkeymanismine"><a class="link" href="#_6_descriptorscriptpubkeymanismine">6. <code>DescriptorScriptPubKeyMan::IsMine(&#8230;&#8203;)</code></a></h5>
<div class="paragraph">
<p><code>DescriptorScriptPubKeyMan::IsMine(&#8230;&#8203;)</code> basically checks if <code>DescriptorScriptPubKeyMan::m_map_script_pub_keys</code> contains the <code>CScript scriptPubKey</code> passed in parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">isminetype DescriptorScriptPubKeyMan::IsMine(const CScript&amp; script) const
{
    LOCK(cs_desc_man);
    if (m_map_script_pub_keys.count(script) &gt; 0) {
        return ISMINE_SPENDABLE;
    }
    return ISMINE_NO;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DescriptorScriptPubKeyMan::m_map_script_pub_keys</code> is a <code>std::map&lt;CScript, int32_t&gt;</code> type (a map of scripts to the descriptor range index).</p>
</div>
</div>
<div class="sect4">
<h5 id="_7_legacyscriptpubkeymanismine"><a class="link" href="#_7_legacyscriptpubkeymanismine">7. <code>LegacyScriptPubKeyMan::IsMine(&#8230;&#8203;)</code></a></h5>
<div class="paragraph">
<p><code>LegacyScriptPubKeyMan::IsMine(&#8230;&#8203;)</code> is only a proxy for <code>IsMineResult IsMineInner(&#8230;&#8203;)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">isminetype LegacyScriptPubKeyMan::IsMine(const CScript&amp; script) const
{
    switch (IsMineInner(*this, script, IsMineSigVersion::TOP)) {
    case IsMineResult::INVALID:
    case IsMineResult::NO:
        return ISMINE_NO;
    case IsMineResult::WATCH_ONLY:
        return ISMINE_WATCH_ONLY;
    case IsMineResult::SPENDABLE:
        return ISMINE_SPENDABLE;
    }
    assert(false);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>IsMineResult IsMineInner(&#8230;&#8203;)</code> is only used by <code>LegacyScriptPubKeyMan</code> (which should be deprecated at some point) and is considerably more complex than its equivalent in the more modern <code>DescriptorScriptPubKeyMan</code>.</p>
</div>
<div class="paragraph">
<p>The first step is to call <code>Solver(scriptPubKey, vSolutions)</code> method, which parses a scriptPubKey and identifies the script type for standard scripts. If successful, returns the script type and parsed pubkeys or hashes, depending on the type. For example, for a P2SH script, <code>vSolutionsRet</code> will contain the script hash, for P2PKH it will contain the key hash, an so on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(const LegacyScriptPubKeyMan&amp; keystore, const CScript&amp; scriptPubKey, IsMineSigVersion sigversion, bool recurse_scripthash=true)
{
    IsMineResult ret = IsMineResult::NO;

    std::vector&lt;valtype&gt; vSolutions;
    TxoutType whichType = Solver(scriptPubKey, vSolutions);
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to handle each script type separately. Note that if it is a Taproot transaction, it will not be considered spendable by legacy wallets. They purposely do not support Taproot as they are marked for deprecation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    TxoutType whichType = Solver(scriptPubKey, vSolutions);

    CKeyID keyID;
    switch (whichType) {
    case TxoutType::NONSTANDARD:
    case TxoutType::NULL_DATA:
    case TxoutType::WITNESS_UNKNOWN:
    case TxoutType::WITNESS_V1_TAPROOT:
        break;
    case TxoutType::PUBKEY:
        // ...
    case TxoutType::WITNESS_V0_KEYHASH:
        // ...
    case TxoutType::PUBKEYHASH:
        // ...
    case TxoutType::SCRIPTHASH:
        // ...
    case TxoutType::WITNESS_V0_SCRIPTHASH:
        // ...
    case TxoutType::MULTISIG:
        // ...
    }
    } // no default case, so the compiler can warn about missing cases

    if (ret == IsMineResult::NO &amp;&amp; keystore.HaveWatchOnly(scriptPubKey)) {
        ret = std::max(ret, IsMineResult::WATCH_ONLY);
    }
    return ret;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no script type conditions are met for a <code>scriptPubKey</code>, the function checks at the end if it is a watch-only script in the wallet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    switch (whichType) {
        // ...
        case TxoutType::PUBKEY:
        keyID = CPubKey(vSolutions[0]).GetID();
        if (!PermitsUncompressed(sigversion) &amp;&amp; vSolutions[0].size() != 33) {
            return IsMineResult::INVALID;
        }
        if (keystore.HaveKey(keyID)) {
            ret = std::max(ret, IsMineResult::SPENDABLE);
        }
        break;
        // ...
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the script type is a public key, the function first checks if it is a <code>P2PK</code> (uncompressed public key), otherwise it must be 33 bytes (compressed format).</p>
</div>
<div class="paragraph">
<p>It then checks if the wallet keystore has the key. In this case, it means the script can be spent by the wallet.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In the early days of Bitcoin, the transactions were of type <code>P2PK</code>, which were specified in uncompressed format.
However using this format turned out to be both wasteful for storing unspent transaction outputs (UTXOs) and a compressed format was adopted for <code>P2PKH</code> and <code>P2WPKH</code>.</p>
</div>
<div class="paragraph">
<p>Uncompressed format has:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>04</code> - Marker</p>
</li>
<li>
<p>x coordinate - 32 bytes, big endian</p>
</li>
<li>
<p>y coordinate - 32 bytes, big endian</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the compressed has:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>02</code> if y is even, <code>03</code> if odd - Marker</p>
</li>
<li>
<p>x coordinate - 32 bytes, big endian</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that the compressed format has a total of 33 bytes (x coordinate + marker).</p>
</div>
<div class="paragraph">
<p>More recently, taproot address <code>P2TR</code> was introduced and it uses a format called <code>x-only</code>, with only x coordinate - 32 bytes, big endian.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next step is the SegWit format (<code>P2WPKH</code>).
First the function invalidates the script if this has a <code>P2WPKH</code> nested inside <code>P2WSH</code>.
It then checks that the script is in the expected format with the <code>OP_0</code> before the witness output.</p>
</div>
<div class="paragraph">
<p>If these two validations pass, the script will be recreated as Public Key Hash and the function will be called recursively.
Note that in this second call, the script will be handled as <code>TxoutType::PUBKEYHASH</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::WITNESS_V0_KEYHASH:
    {
        if (sigversion == IsMineSigVersion::WITNESS_V0) {
            // P2WPKH inside P2WSH is invalid.
            return IsMineResult::INVALID;
        }
        if (sigversion == IsMineSigVersion::TOP &amp;&amp; !keystore.HaveCScript(CScriptID(CScript() &lt;&lt; OP_0 &lt;&lt; vSolutions[0]))) {
            // We do not support bare witness outputs unless the P2SH version of it would be
            // acceptable as well. This protects against matching before segwit activates.
            // This also applies to the P2WSH case.
            break;
        }
        ret = std::max(ret, IsMineInner(keystore, GetScriptForDestination(PKHash(uint160(vSolutions[0]))), IsMineSigVersion::WITNESS_V0));
        break;
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TxoutType::PUBKEYHASH</code> logic is very similar to the <code>TxoutType::PUBKEY</code>: it checks if the wallet keystore has the key, which means the script can be spent by the wallet.</p>
</div>
<div class="paragraph">
<p>Before that, however, the function validates whether the key must be compressed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::PUBKEYHASH:
        keyID = CKeyID(uint160(vSolutions[0]));
        if (!PermitsUncompressed(sigversion)) {
            CPubKey pubkey;
            if (keystore.GetPubKey(keyID, pubkey) &amp;&amp; !pubkey.IsCompressed()) {
                return IsMineResult::INVALID;
            }
        }
        if (keystore.HaveKey(keyID)) {
            ret = std::max(ret, IsMineResult::SPENDABLE);
        }
        break;
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next item to be dealt with is <code>TxoutType::SCRIPTHASH</code>.
The logic is very similar to the one seen before.
First the script is validated (<code>P2SH</code> inside <code>P2WSH</code> or <code>P2SH</code> is invalid) and the function checks if the script exists in THE wallet keystore.
As with <code>TxoutType::WITNESS_V0_KEYHASH</code>, the function will recurse into nested p2sh and p2wsh scripts or will simply treat any script that has been stored in the keystore as spendable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::SCRIPTHASH:
    {
        if (sigversion != IsMineSigVersion::TOP) {
            // P2SH inside P2WSH or P2SH is invalid.
            return IsMineResult::INVALID;
        }
        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));
        CScript subscript;
        if (keystore.GetCScript(scriptID, subscript)) {
            ret = std::max(ret, recurse_scripthash ? IsMineInner(keystore, subscript, IsMineSigVersion::P2SH) : IsMineResult::SPENDABLE);
        }
        break;
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TxoutType::WITNESS_V0_SCRIPTHASH</code> has the same logic seen in the previous item.
The only difference is that the has <code>Hash160</code> is recreated with the solved script hash, since <code>P2SH-P2WSH</code> is allowed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::WITNESS_V0_SCRIPTHASH:
    {
        if (sigversion == IsMineSigVersion::WITNESS_V0) {
            // P2WSH inside P2WSH is invalid.
            return IsMineResult::INVALID;
        }
        if (sigversion == IsMineSigVersion::TOP &amp;&amp; !keystore.HaveCScript(CScriptID(CScript() &lt;&lt; OP_0 &lt;&lt; vSolutions[0]))) {
            break;
        }
        uint160 hash;
        CRIPEMD160().Write(vSolutions[0].data(), vSolutions[0].size()).Finalize(hash.begin());
        CScriptID scriptID = CScriptID(hash);
        CScript subscript;
        if (keystore.GetCScript(scriptID, subscript)) {
            ret = std::max(ret, recurse_scripthash ? IsMineInner(keystore, subscript, IsMineSigVersion::WITNESS_V0) : IsMineResult::SPENDABLE);
        }
        break;
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last type of script is <code>TxoutType ::MULTISIG</code>, whose logic is straightforward.
<code>Solver (&#8230;&#8203;)</code> returns all the keys of the script and then they are validated in the same way as the previous scripts.
Transactions are only considered <code>ISMINE_SPENDABLE</code> if the node has all keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::MULTISIG:
    {
        if (sigversion == IsMineSigVersion::TOP) {
            break;
        }

        std::vector&lt;valtype&gt; keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);
        if (!PermitsUncompressed(sigversion)) {
            for (size_t i = 0; i &lt; keys.size(); i++) {
                if (keys[i].size() != 33) {
                    return IsMineResult::INVALID;
                }
            }
        }
        if (HaveKeys(keys, keystore)) {
            ret = std::max(ret, IsMineResult::SPENDABLE);
        }
        break;
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, we cover most of the code responsible for identifying which transactions belong to the wallet.
The code related to <code>IsMine(&#8230;&#8203;)</code> or <code>IsMineInner(&#8230;&#8203;)</code> is used either when the transactions arrive through the mempool or by blocks.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constructing_transactions"><a class="link" href="#_constructing_transactions">Constructing transactions</a></h3>
<div class="paragraph">
<p>In order to construct a transaction the wallet will validate the outputs, before selecting some coins to use in the transaction.
This involves multiple steps and we can follow an outline of the process by walking through the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/rpc/spend.cpp#L125-L223" target="_blank" rel="noopener"><code>sendtoaddress</code> RPC command</a>, which returns by calling <code>SendMoney()</code>.</p>
</div>
<div class="paragraph">
<p>After initialisation <code>SendMoney()</code> will call <code>wallet.CreateTransaction()</code> (<code>CWallet::CreateTransaction()</code>) followed by <code>wallet.CommitTransaction()</code> if successful.
If we follow <code>wallet.CreateTransaction()</code> we see that it is a wrapper function which calls private member function <code>CWallet::CreateTransactionInternal()</code>.</p>
</div>
<div class="sect3">
<h4 id="_createtransactioninternal"><a class="link" href="#_createtransactioninternal">CreateTransactionInternal</a></h4>
<div class="paragraph">
<p>We fetch change addresses of an "appropriate type" here, where "appropriate" means that it should try to minimise revealing that it is a change address, for example by being a different <code>OUTPUT_TYPE</code> to the other outputs.
Once a suitable change address is selected A new <code>ReserveDestination</code> object is created which keeps track of reserved addresses to prevent address re-use.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The address is not "fully" reserved until <code>GetReservedDestination()</code> is called later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next some basic checks on the requested transaction parameters are carried out (e.g. sanity checking of amounts and recipients) by looping through each pair of (recipient, amount).
After initializing a new transaction (<code>txNew</code>), a fee calculation (<code>feeCalc</code>) and variables for the transaction size, we enter into a new code block where the <code>cs_wallet</code> lock is acquired and the <code>nLockTime</code> for the transaction is set:</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/wallet.cpp#CWallet::CreateTransactionInternal()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// ...

CMutableTransaction txNew;
FeeCalculation feeCalc;
CAmount nFeeNeeded;
std::pair&lt;int64_t, int64_t&gt; tx_sizes;
int nBytes;
{
    std::set&lt;CInputCoin&gt; setCoins;
    LOCK(cs_wallet);
    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());
        {
            std::vector&lt;COutput&gt; vAvailableCoins;
            AvailableCoins(vAvailableCoins, true, &amp;coin_control, 1, MAX_MONEY, MAX_MONEY, 0);

    // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bitcoin Core chooses to set <code>nLockTime</code> to the current block to discourage <a href="https://bitcoinops.org/en/topics/fee-sniping/" target="_blank" rel="noopener">fee sniping</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We must acquire the lock here because we are about to attempt to select coins for spending, and optionally reserve change addresses.</p>
</div>
<div class="paragraph">
<p>If we did not have the lock it might be possible for the wallet to construct two transactions which attempted to spend the same coins, or which used the same change address.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_availablecoins_2"><a class="link" href="#_availablecoins_2">AvailableCoins</a></h4>
<div class="paragraph">
<p>After this, a <em>second</em> new code block is entered where "available coins" are inserted into a vector of <code>COutput</code>s named <code>vAvailableCoins</code>.
The concept of an "available coin" is somewhat complex, but roughly it excludes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>"used" coins</p>
</li>
<li>
<p>coins which do not have enough confirmations (N.B. confirmations required differs for own change)</p>
</li>
<li>
<p>coins which are part of an immature coinbase (&lt; 100 confirmations)</p>
</li>
<li>
<p>coins which have not entered into our mempool</p>
</li>
<li>
<p>coins which are already being used to (attempt) replacement of other coins</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This call to <code>AvailableCoins()</code> is our first reference back to the underlying <code>ScriptPubKeyMan</code>s controlled by the wallet.
The function iterates over all coins belonging to us&#8201;&#8212;&#8201;found in the <code>CWallet.mapWallet</code> mapping&#8201;&#8212;&#8201;checking coin availability before querying for a <code>SolvingProvider</code> (ultimately calling <code>GetSigningProvider()</code>): essentially querying whether the active <code>CWallet</code> has a <code>ScriptPubKeyMan</code> which can sign for the given output.</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/wallet.cpp#CWallet::GetSolvingProvider()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">std::unique_ptr&lt;SigningProvider&gt; CWallet::GetSolvingProvider(const CScript&amp; script, SignatureData&amp; sigdata) const
{
    for (const auto&amp; spk_man_pair : m_spk_managers) {
        if (spk_man_pair.second-&gt;CanProvide(script, sigdata)) {
            return spk_man_pair.second-&gt;GetSolvingProvider(script);
        }
    }
    return nullptr;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is a section of the <code>AvailableCoins()</code> function which illustrates available coins being added to the <code>vAvailableCoins</code> vector, with the call to <code>GetSolvingProvider()</code> visible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a <code>SigningProvider</code> is found a second check is performed: to see if the coin is "solvable" by calling <code>IsSolvable()</code>.</p>
</div>
<div class="paragraph">
<p>Whilst <code>getSolvingProvider()</code> might return a <code>SigningProvider</code> (read: SPKM), not all SPKMs will be able to provide <strong>private</strong> key data needed for signing transactions, e.g. in the case of a watch-only wallet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After we have determined solvablility, "spendability" is calculated for each potential output along with any coin control limitations:</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/wallet.cpp#AvailableCoins()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    // ...

    for (unsigned int i = 0; i &lt; wtx.tx-&gt;vout.size(); i++) {

        // ...

        std::unique_ptr&lt;SigningProvider&gt; provider = GetSolvingProvider(wtx.tx-&gt;vout[i].scriptPubKey);

        bool solvable = provider ? IsSolvable(*provider, wtx.tx-&gt;vout[i].scriptPubKey) : false;
        bool spendable = ((mine &amp; ISMINE_SPENDABLE) != ISMINE_NO) || (((mine &amp; ISMINE_WATCH_ONLY) != ISMINE_NO) &amp;&amp; (coinControl &amp;&amp; coinControl-&gt;fAllowWatchOnly &amp;&amp; solvable));

        vCoins.push_back(COutput(&amp;wtx, i, nDepth, spendable, solvable, safeTx, (coinControl &amp;&amp; coinControl-&gt;fAllowWatchOnly)));

        // Checks the sum amount of all UTXO's.
        if (nMinimumSumAmount != MAX_MONEY) {
            nTotal += wtx.tx-&gt;vout[i].nValue;

            if (nTotal &gt;= nMinimumSumAmount) {
                return;
            }
        }

        // Checks the maximum number of UTXO's.
        if (nMaximumCount &gt; 0 &amp;&amp; vCoins.size() &gt;= nMaximumCount) {
            return;
        }

        // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the full <a href="https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L2209-L2334" target="_blank" rel="noopener"><code>CWallet::AvailableCoins()</code></a> implementation for additional details and caveats.</p>
</div>
</div>
<div class="sect3">
<h4 id="_createtransactioninternal_continued"><a class="link" href="#_createtransactioninternal_continued">CreateTransactionInternal continued</a></h4>
<div class="paragraph">
<p>After available coins have been determined, we check to see if the user has provided a custom change address (used coin control), or whether the earlier not-fully-reserved change address should finally be reserved and selected by calling <code>GetReservedDestination()</code>.
The change outputs' <code>size</code>, <code>discard_free_rate</code> and <code>effective_fee_rate</code> are then calculated.
The <code>discard_fee_rate</code> refers to any change output which would be dust at the <code>discard_rate</code>, and that you would be willing to discard completely and add to fee (as well as continuing to pay the fee that would have been needed for creating the change).</p>
</div>
</div>
<div class="sect3">
<h4 id="coin-selection"><a class="link" href="#coin-selection">Coin selection</a></h4>
<div class="paragraph">
<p>Now that we have a vector of available coins and our fee rate settings estimated, we are ready to start coin selection itself.
This is still an active area of research, with two possible coin selection solving algorithms currently implemented:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Branch and bound ("bnb")</p>
</li>
<li>
<p>Knapsack</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The branch and bound algorithm is well-documented in the codebase itself:</p>
</div>
<div class="listingblock">
<div class="title">src/wallet/coinselection.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/*
This is the Branch and Bound Coin Selection algorithm designed by Murch. It searches for an input
set that can pay for the spending target and does not exceed the spending target by more than the
cost of creating and spending a change output. The algorithm uses a depth-first search on a binary
tree. In the binary tree, each node corresponds to the inclusion or the omission of a UTXO. UTXOs
are sorted by their effective values and the trees is explored deterministically per the inclusion
branch first. At each node, the algorithm checks whether the selection is within the target range.
While the selection has not reached the target range, more UTXOs are included. When a selection's
value exceeds the target range, the complete subtree deriving from this selection can be omitted.
At that point, the last included UTXO is deselected and the corresponding omission branch explored
instead. The search ends after the complete tree has been searched or after a limited number of tries.

The search continues to search for better solutions after one solution has been found. The best
solution is chosen by minimizing the waste metric. The waste metric is defined as the cost to
spend the current inputs at the given fee rate minus the long term expected cost to spend the
inputs, plus the amount the selection exceeds the spending target:

waste = selectionTotal - target + inputs  (currentFeeRate - longTermFeeRate)

The algorithm uses two additional optimizations. A lookahead keeps track of the total value of
the unexplored UTXOs. A subtree is not explored if the lookahead indicates that the target range
cannot be reached. Further, it is unnecessary to test equivalent combinations. This allows us
to skip testing the inclusion of UTXOs that match the effective value and waste of an omitted
predecessor.

The Branch and Bound algorithm is described in detail in Murch's Master Thesis: https://murch.one/wp-content/uploads/2016/11/erhardt2016coinselection.pdf

@param const std::vector&lt;CInputCoin&gt;&amp; utxo_pool The set of UTXOs that we are choosing from.
       These UTXOs will be sorted in descending order by effective value and the CInputCoins'
       values are their effective values.
@param const CAmount&amp; target_value This is the value that we want to select. It is the lower
       bound of the range.
@param const CAmount&amp; cost_of_change This is the cost of creating and spending a change output.
       This plus target_value is the upper bound of the range.
@param std::set&lt;CInputCoin&gt;&amp; out_set -&gt; This is an output parameter for the set of CInputCoins
       that have been selected.
@param CAmount&amp; value_ret -&gt; This is an output parameter for the total value of the CInputCoins
       that were selected.
@param CAmount not_input_fees -&gt; The fees that need to be paid for the outputs and fixed size
       overhead (version, locktime, marker and flag)
*/</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can read a little more about the differences between these two coin selection algorithms in this <a href="https://bitcoin.stackexchange.com/questions/32145/what-are-the-trade-offs-between-the-different-algorithms-for-deciding-which-utxo/32445#32445" target="_blank" rel="noopener">StackExchange answer</a>.</p>
</div>
<div class="paragraph">
<p>You can read more about <code>waste</code> and the waste metric in this <a href="https://bitcoin.stackexchange.com/questions/113622/what-does-waste-metric-mean-in-the-context-of-coin-selection/113625#113625" target="_blank" rel="noopener">StackExchange answer</a>.</p>
</div>
<div class="paragraph">
<p>Coin selection is performed as a loop, as it may take multiple iterations to select the optimal coins for a given transaction.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiwallet"><a class="link" href="#_multiwallet">Multiwallet</a></h3>
<div class="paragraph">
<p>Work on the <a href="https://github.com/bitcoin/bitcoin/projects/2" target="_blank" rel="noopener">multiwallet project</a> means that Bitcoin Core can now handle dynamic loading and unloading of multiple wallets while running.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_3"><a class="link" href="#_exercises_3">Exercises</a></h3>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Using either <code>bitcoin-cli</code> in your terminal, or a <a href="#test_shell_nodes">Jupyter Notebook</a> in conjunction with the <code>TestShell</code> class from the Bitcoin Core Test Framework, try to complete the following exercises.</p>
</div>
<div class="paragraph">
<p>Changes to the codebase will require you to re-compile afterwards.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to use the compiled binaries found in your source directory, for example <code>/home/user/bitcoin/src/bitcoind</code>, otherwise your system might select a previously-installed (non-modified) version of bitcoind.</p>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Modify a wallet RPC</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Create a descriptor wallet</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Generate coins to yourself</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Remove the <code>"dummy"</code> parameter from the <code>getbalance</code> Wallet RPC</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Ensure that the <code>rpc_help.py</code> functional test passes (but ignore other test failures), fixing any errors</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
run <code>test/functional/rpc_help.py</code> to just run a single test
</td>
</tr>
</table>
</div>
</li>
<li>
<p><i class="fa fa-square-o"></i> Check that the rpc call <code>getbalance 3 true true</code> passes with the <code>dummy</code> parameter removed</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>IsMine</code></p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Create a descriptor wallet</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Generate coins to yourself</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Send coins to yourself in a transaction and generate a block to confirm</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Modify the wallet&#8217;s <code>IsMine()</code> logic to always return <code>false</code></p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Generate a new block and try to send coins to yourself in a transaction again</p>
</li>
<li>
<p>Observe the changes</p>
</li>
</ul>
</div>
</li>
<li>
<p>Coin Selection</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Create a descriptor wallet</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Generate 200 blocks to yourself</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Call <code>listunspent</code> and then <code>send</code> a large amount (e.g. 600 BTC) to yourself and observe how many inputs were used</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Add a new <span class="underline">preferred</span> coin selection algorithm to the wallet that uses <strong>all</strong> UTXOs in the wallet and optionally remove the other algorithms.</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Redo the send and confirm that this time it will select all inputs in the wallet for the transaction</p>
</li>
</ul>
</div>
</li>
<li>
<p>Adding a new RPC</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Add a new RPC which when called will simply return to the user a random UTXO from the wallet in the form</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="json">{
  "txid": &lt;txid&gt;,
  "vout": &lt;vout&gt;
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gui"><a class="link" href="#_gui">GUI</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The GUI has its own separate repo at <a href="https://github.com/bitcoin-core/gui" target="_blank" rel="noopener">bitcoin-core/gui</a>.
PRs which primarily target the GUI should be made here, and then they will get merged into the primary repo.
Developer Marco Falke created <a href="https://github.com/MarcoFalke/bitcoin-core/issues/26" target="_blank" rel="noopener">an issue</a> in his fork which detailed some of the rationale for the split, but essentially it came down to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Separate issue and patch management</p>
</li>
<li>
<p>More focused review and interests</p>
</li>
<li>
<p>Maintain high quality assurance</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>He also stated that:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Splitting up the GUI (and splitting out modules in general) has been brought up often in recent years. Now that the GUI is primarily connected through interfaces with a bitcoin node, it seems an appropriate time to revive this discussion.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Marco Falke
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/19071" target="_blank" rel="noopener">PR#19071</a> contained the documentation change now contained in the Bitcoin Core primary repository, along with details of the monotree approach that was ultimately taken.
The documentation change provides guidance on what a "GUI change" is:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>As a rule of thumb, everything that only modifies <code>src/qt</code> is a GUI-only pull
request. However:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For global refactoring or other transversal changes the node repository
should be used.</p>
</li>
<li>
<p>For GUI-related build system changes, the node repository should be used
because the change needs review by the build systems reviewers.</p>
</li>
<li>
<p>Changes in <code>src/interfaces</code> need to go to the node repository because they
might affect other components like the wallet.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For large GUI changes that include build system and interface changes, it is
recommended to first open a PR against the GUI repository. When there
is agreement to proceed with the changes, a PR with the build system
and interfaces changes can be submitted to the node repository.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; src/CONTRIBUTING.md
</div>
</div>
<div class="paragraph">
<p>On a related note, another <a href="https://github.com/bitcoin/bitcoin/issues/24045" target="_blank" rel="noopener">issue</a> was recently opened by Falke, to discuss the possibility of instituting the same monotree changes for wallet code.</p>
</div>
<div class="sect2">
<h3 id="_motivation_for_a_gui"><a class="link" href="#_motivation_for_a_gui">Motivation for a GUI</a></h3>
<div class="paragraph">
<p>Bitcoin Core has shipped with a GUI since the first version.
Originally this was a wxWidgets GUI, but in 2011 a move to QT was <a href="https://github.com/bitcoin/bitcoin/pull/521">completed</a>.
Satoshi originally had plans to have a decentralized market place and even poker game inside Bitcoin, so including a GUI, which also had wallet and address book functionality, made sense from the get-go.</p>
</div>
<div class="paragraph">
<p>The motivation to <em>continue</em> to include a GUI with Bitcoin Core today is for accessibility.
New users can access a best-in-class Bitcoin experience via a single software package.
It&#8217;s not safe or realistic to expect users to download multiple programs and connect them securely into a software suite, just to use bitcoin.</p>
</div>
<div class="paragraph">
<p>It does not have to be the prettiest UI, but needs to provide the functionality to use bitcoin.
It is possible to connect other frontends to Bitcoin Core, but they are connected via RPCs, and do not have the first-class interface (to the node component) that the bundled GUI has.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_the_gui"><a class="link" href="#_building_the_gui">Building the GUI</a></h3>
<div class="paragraph">
<p><code>bitcoin-qt</code>, which includes the QT GUI with the node, is built automatically when the build dependencies are met.
Required packages to meet dependencies can be found in the build instructions in <em>src/doc/build-*.md</em> as appropriate for your platform.
If you have the required packages installed but do not wish to build the <code>bitcoin-qt</code> then you must run <code>./configure</code> with the option <code>--with-gui=no</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the build is configured with <code>--enable-multiprocess</code> then additional binaries will be built:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>bitcoin-node</code></p>
</li>
<li>
<p><code>bitcoin-wallet</code></p>
</li>
<li>
<p><code>bitcoin-gui</code></p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_qt"><a class="link" href="#_qt">Qt</a></h3>
<div class="paragraph">
<p>QT is currently very intertwined with the rest of the codebase.
See the library <a href="#library-dependency-graph">depencency graph</a> for more context.</p>
</div>
<div class="paragraph">
<p>Developers would ideally like to reduce these dependencies in the future.</p>
</div>
</div>
<div class="sect2">
<h3 id="_qt_documentation"><a class="link" href="#_qt_documentation">Qt documentation</a></h3>
<div class="paragraph">
<p>There is useful documentation for developers looking to contribute to the Qt side of the codebase found at <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki//Developer-Notes-for-Qt-Code" target="_blank" rel="noopener">Developer Notes for Qt Code</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_gui_program"><a class="link" href="#_main_gui_program">Main GUI program</a></h3>
<div class="paragraph">
<p>The loading point for the GUI is <em>src/qt/main.cpp</em>.
<code>main()</code> calls <code>GuiMain()</code> from <em>src/qt/bitcoin.cpp</em>, passing along any program arguments with it.
<code>GuiMain</code> starts by calling <code>SetupEnvironment()</code> which amongst other things, configures the runtime locale and charset.</p>
</div>
<div class="paragraph">
<p>Next an empty <code>NodeContext</code> is set up, which is then populated into a fully-fledged node interface via being passed to <code>interfaces::MakeNode()</code>, which returns an <code>interfaces::Node</code>.
Recall that in <a href="#_wallet_component_initialisation">Wallet component initialisation</a> we also saw the wallet utilizing a <code>NodeContext</code> as part of its <code>WalletInitInterface</code>.
In both cases the <code>NodeContext</code> is being used to pass chain and network references around without needing to create globals.</p>
</div>
<div class="paragraph">
<p>After some QT setup, command-line and application arguments are parsed.
What follows can be outlined from the code comments:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Application identification</p>
</li>
<li>
<p>Initialization of translations, so that intro dialogue is in user&#8217;s language</p>
</li>
<li>
<p>Now that settings and translations are available, ask user for data directory</p>
</li>
<li>
<p>Determine availability of data directory and parse bitcoin.conf</p>
</li>
<li>
<p>Determine network (and switch to network specific options)</p>
</li>
<li>
<p>URI IPC sending</p>
</li>
<li>
<p>Main GUI initialization</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_gui_initialisation"><a class="link" href="#_gui_initialisation">GUI initialisation</a></h3>
<div class="paragraph">
<p>After configuration the GUI is initialized.
Here the <code>Node</code> object created earlier is passed to <code>app.SetNode()</code> before a window is created and the application executed.</p>
</div>
<div class="paragraph">
<p>The bulk of the Qt GUI classes are defined in <em>src/qt/bitcoingui.{h|cpp}</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_qml_gui"><a class="link" href="#_qml_gui">QML GUI</a></h3>
<div class="paragraph">
<p>Since writing this documentation focus has been directed towards re-writing the Qt code leveraging the <a href="https://doc.qt.io/qt-5/qtqml-index.html" target="_blank" rel="noopener">Qt QML</a> framework.
This will allow developers to create visually-superior, and easier to write and reason-about GUI code, whilst also lowering the barriers to entry for potential new developers who want to be able to focus on GUI code.</p>
</div>
<div class="paragraph">
<p>The recommendation therefore is to familiarise yourself with Qt QML and review the current codebase for the latest developments.
You can follow along with the latest QML work in the specific <a href="https://github.com/bitcoin-core/gui-qml/blob/main/src/qml/README.md" target="_blank" rel="noopener">bitcoin-core/qml-gui</a> repo.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_design"><a class="link" href="#_bitcoin_design">Bitcoin design</a></h3>
<div class="paragraph">
<p>The <a href="https://bitcoin.design/guide/" target="_blank" rel="noopener">Bitcoin design guide</a> provides some guidance on common pitfalls that Bitcoin GUI designers should look out for when designing apps (like <code>bitcoin-qt</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_qt"><a class="link" href="#_testing_qt">Testing QT</a></h3>
<div class="paragraph">
<p>Currently, although several QT tests exist in <em>src/qt/test</em>, there is no good way to test QT changes except by hand.
A good way to try and have QT code included in the test framework is to target having the RPC layer be a thin as possible, so more code can be re-used between RPC and GUI.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_p2p"><a class="link" href="#_p2p">P2P</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With bitcoin we are seeking to create a permissionless network in which anyone can make a bitcoin transaction.
Anybody should be free and able to run a node and join the network.</p>
</div>
<div class="paragraph">
<p>The Bitcoin P2P network serves 3 purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_address_relay">Gossiping addresses</a> of known reachable nodes on the network</p>
</li>
<li>
<p><a href="#_transaction_relay">Relaying unconfirmed transactions</a></p>
</li>
<li>
<p><a href="#_block_relay">Propagating blocks</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although these three purposes share the same network, they have different design goals and properties.
Transaction relay is optimized for a combination of redundancy/robustness to peer misbehaviour as well as bandwidth minimization, while block relay is optimized to minimize delay.</p>
</div>
<div class="sect2">
<h3 id="_design_philosophy"><a class="link" href="#_design_philosophy">Design philosophy</a></h3>
<div class="paragraph">
<p>The P2P design philosophy is outlined in the bitcoin devwiki article <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/P2P-Design-Philosophy" target="_blank" rel="noopener">P2P Design Philosophy</a>.
A synopsis of the ideas can be found in the first few paragraphs:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>For the Bitcoin network to remain in consensus, the network of nodes must not be partitioned.
So for an individual node to remain in consensus with the network, it must have at least one connection to that network of peers that share its consensus rules.</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>We can&#8217;t rely on inbound peers to be honest, because they are initiated by others.
It&#8217;s impossible for us to know, for example, whether all our inbound peers are controlled by the same adversary.</p>
</div>
<div class="paragraph">
<p>Therefore, in order to try to be connected to the honest network, we focus on having good outbound peers, as we get to choose who those are.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The document, which is worth reading in its entirely, continues by assuming the case that we don&#8217;t have any inbound peers but also considering that any inbound peers we <em>do</em> have shouldn&#8217;t be able to interfere with the P2P logic proposed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_design_goals"><a class="link" href="#_design_goals">Design goals</a></h3>
<div class="paragraph">
<p>Amiti Uttarwar created a framework of 5 goals she sees for the P2P network.</p>
</div>
<div class="paragraph">
<p>TLDR; We want valid messages to make it out to the network (<strong>reliable</strong>) in a reasonable amount of time (<strong>timely</strong>) and for nodes to be able to get onto the network and stay on the network of their own accord (<strong>accesible</strong>).
These three values seem quite important for any peer-to-peer network to be successful but in Bitcoin we have two additional.
<strong>Privacy</strong> because it is money and <strong>upgradeability</strong> because of the ethos of Bitcoin.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Reliable</strong>; if a node submits a valid message to the network it will eventually be delivered to all other nodes on the network.</p>
</li>
<li>
<p><strong>Timely</strong>; each of the messages have to make it out in a reasonable amount of time.</p>
<div class="ulist">
<ul>
<li>
<p>Reasonable amount of time for a transaction is different than for a block and reasonable amount of time for a block to be propagated for a normal user versus a miner is very different as well.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Accessible</strong>; the requirement to be able to participate must be low. Also an adversary shouldnt be able to keep a node off the network.</p>
<div class="ulist">
<ul>
<li>
<p>Currently it is still possible to run a full Bitcoin Core node on a Raspberry Pi which is a low barrier-to-entry.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Private</strong>; because it is money and fundamentally it comes down to the idea of not wanting to connect your real world identity with your onchain interactions.</p>
</li>
<li>
<p><strong>Upgradeable</strong>; stems from the ethos that if a user decides to buy into the rule set at a specific point in time they should always be able to transact with the rule set they initially bought into.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Reliability</strong> vs <strong>Privacy</strong> can seem at odds with one another as is really hard to design and achieve both of them at the same time.
For example, <strong>value long-lasting connections</strong>, can help for reliable delivery but <strong>comes against privacy</strong>.
<strong>Dynamic connections</strong> help maintain transaction privacy, but <strong>comes against reliability</strong>.
Reliability is you want to tell everyone your message, but privacy is you dont want them to know that it is your message.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://btctranscripts.com/la-bitdevs/2020-04-16-amiti-uttarwar-attacking-bitcoin-core/" target="_blank" rel="noopener">transcript</a> for more detail on each of those points.</p>
</div>
</div>
<div class="sect2">
<h3 id="_p2p_attacks"><a class="link" href="#_p2p_attacks">P2P attacks</a></h3>
<div class="paragraph">
<p>In a permissionless system two types of users are both <em>equally</em> free to access and attempt to use the network:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Honest users</p>
</li>
<li>
<p>Attackers/spammers</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Types of activities an attacker might attempt to perform on a target node which involve the P2P layer include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exhaust CPU/memory</p>
<div class="ulist">
<ul>
<li>
<p>Create infinite loops</p>
</li>
<li>
<p>Cause OOM (exhaust memory)</p>
</li>
<li>
<p>Clog up network traffic</p>
</li>
<li>
<p>Fill mempool with garbage</p>
</li>
<li>
<p>Temporarily stall the network</p>
</li>
</ul>
</div>
</li>
<li>
<p>Eclipse/sybil attacks</p>
<div class="ulist">
<ul>
<li>
<p>Reduce privacy</p>
</li>
<li>
<p>Cause network splits</p>
</li>
<li>
<p><a href="https://bitcoinops.org/en/topics/eclipse-attacks/" target="_blank" rel="noopener">Eclipse</a> attack</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Sybil_attack" target="_blank" rel="noopener">Sybil</a> attack</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Bitcoin protocol does not have a concept of node identifiers or other reputation system through which we can permanently block a node we identify as malicious from future communications.
If a node reconnects to us using a different IP address we will not be able to tell it was the same node we had seen before.
Make no mistake that this is a large win for the censorship-resistance of the network, but it makes P2P implementation more precarious.</p>
</div>
<div class="paragraph">
<p>Our program must contain logic to protect against the above attacks in a scenario where they may happen often and freely.
Bitcoin Core employs a number of techniques in the P2P domain to try and protect against these types of attacks including:</p>
</div>
<table class="tableblock frame-all grid-all fit-content stretch">
<caption class="title">Table 13. Protective counter-measures</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Technique</th>
<th class="tableblock halign-left valign-top">Protection</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Proof of Work*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exhaust CPU/memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mempool policy for transactions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exhaust CPU/memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Peer address bucketing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse/Sybil attacks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>block-relay-only</code> connections</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse attacks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ephemeral block-relay-only connections for headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse attacks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_p2p_violations">Disconnecting</a> "misbehaving" peers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exhaust CPU/memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Peer rotation/eviction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse/sybil attacks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Protected peers (from eviction)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse attacks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Anchor peers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse attacks</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
* If an "attacker" has sufficient hash power, then from a PoW perspective they are not really an attacker.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_eclipse_attacks"><a class="link" href="#_eclipse_attacks">Eclipse attacks</a></h4>
<div class="paragraph">
<p><a href="https://bitcoinops.org/en/topics/eclipse-attacks/" target="_blank" rel="noopener">Eclipse attacks</a> occur when an adversary is able to isolate a victim&#8217;s node from the rest of the network.</p>
</div>
<div class="paragraph">
<p>A <em>restart-based eclipse attack</em> occurs when the adversary is able to add its own addresses to the victim&#8217;s address manager and then force the victim to restart.
If the attack succeeds, the victim will make all of its connections to the adversary&#8217;s addresses when it restarts.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/issues/17326" target="_blank" rel="noopener">Issue 17326</a> proposed persisting the node&#8217;s outbound connection list to disk, and on restart reconnecting to the same peers.
It&#8217;s worth reading the full discussion in that issue, since there are a lot of subtle points around which peers should be persisted.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Addrman-and-eclipse-attacks" target="_blank" rel="noopener">Addrman and eclipse attacks(bitcoin-devwiki)</a> attempts to describe the mechanisms implemented in Bitcoin Core to mitigate eclipse attacks followed by open questions and areas of further research.</p>
</div>
</div>
<div class="sect3">
<h4 id="_identification_of_the_network_topology"><a class="link" href="#_identification_of_the_network_topology">Identification of the network topology</a></h4>
<div class="paragraph">
<p>If a malicious entity was able to identify the topography of the network then they could see that by taking specific nodes down, maybe via a DOS service or any attack that they can use, they can cause a partition in the entire network.</p>
</div>
<div class="paragraph">
<p>There are <a href="#_message_relay">three main messages that are gossiped around the network</a> and <strong>each message offers a unique set of information that allows an adversary to identify who your neighbors are</strong>.</p>
</div>
<div class="paragraph">
<p><a href="#_block_relay">Block relay</a> leaks the least information and we can leverage that for a feature called <code>block-relay-only</code> connections, a type of connection where nodes do not participate in transaction or address relay and only relay blocks.
An effective way for a spy node to infer the network topology is to observe the timing and details of transaction and address relay, so <strong>these block-relay-only connections obfuscate network topology and help to mitigate eclipse attacks</strong>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/15759" target="_blank" rel="noopener">PR#15759</a> introduced <code>block-relay-only</code> connections.
After these changes, nodes by default open two outbound block-relay-only connections on startup.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/17428" target="_blank" rel="noopener">PR#17428</a> introduced the idea of anchors, persist peers to reconnect after restart.
If you persist the connection to some peers is great for reliability but it would not be very good for privacy if we were to reconnect to the full relay connections.
So instead, we use the <code>block-relay-only</code> connections and reconnect to those.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/19858" target="_blank" rel="noopener">PR#19858</a> proposes a more advanced use of block-relay-only connections to further mitigate eclipse attacks.
The node will periodically initiate an <em>additional</em> block-relay-only connection which it uses only to sync headers in order to try and learn about new blocks.
If this reveals new blocks, the eviction logic will rotate out an existing block-relay-only connection.
If no new blocks are discovered, the connection is closed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_node_p2p_components"><a class="link" href="#_node_p2p_components">Node P2P components</a></h3>
<div class="literalblock">
<div class="title">Node P2P components</div>
<div class="content">
<pre>flowchart LR
    Addrman
    Banman
    CConnman
    CTxMempool
    ChainstateManager
    NetGroupManager
    Peerman
    Asmap{{Asmap}}
    peers.dat{{peers.dat}}
    anchors.dat{{anchors.dat}}
    banlist.dat{{banlist.dat}}
    mempool.dat{{mempool.dat}}

    subgraph node
        node.netgroupman
        node.addrman
        node.banman
        node.connman
        node.mempool
        node.chainman
        node.peerman
    end

    Asmap -.-&gt; NetGroupManager
    peers.dat -.-&gt; Addrman
    Addrman --&gt; node.addrman

    NetGroupManager --&gt; Addrman
    NetGroupManager --&gt; CConnman
    NetGroupManager --&gt; node.netgroupman

    banlist.dat -.-&gt; Banman
    Banman --&gt; Peerman
    Banman --&gt; node.banman

    Addrman --&gt; CConnman
    anchors.dat -.-&gt; CConnman
    CConnman --&gt; node.connman

    mempool.dat -.-&gt; CTxMempool
    CTxMempool --&gt; Peerman
    CTxMempool --&gt; node.mempool

    ChainstateManager --&gt; node.chainman

    Addrman --&gt; Peerman
    CConnman --&gt; Peerman
    Peerman --&gt; node.peerman</pre>
</div>
</div>
<div class="sect3">
<h4 id="_netgroupmanager"><a class="link" href="#_netgroupmanager">NetGroupManager</a></h4>
<div class="paragraph">
<p>NetGroupManager is used to encapsulate all <a href="https://blog.bitmex.com/call-to-action-testing-and-improving-asmap/" target="_blank" rel="noopener">asmap</a> data and logic.
It is setup by loading any provided asmap file passed during startup.</p>
</div>
<div class="sect4">
<h5 id="_history"><a class="link" href="#_history">History</a></h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://bitcoincore.reviews/16702">PR#16702</a> introduced asmap as part of Addrman.</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bitcoin/pull/22910" target="_blank" rel="noopener">PR#22910</a> introduced NetGroupManager as a better way to access asmap data by both Addrman and CConnman.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_addrman"><a class="link" href="#_addrman">Addrman</a></h4>
<div class="paragraph">
<p>Addrman is the in-memory database of peers and consists of the new and tried tables.
These tables are stored in <code>peers.dat</code> and serve as cache for network information that the node gathered from previous connections, so that if it is rebooted it can quickly reestablish connections with its former peer network and avoid performing <a href="#_bootstrapping">the seeding process</a> again.</p>
</div>
<div class="paragraph">
<p>Addrman is setup using <code>LoadAddrman</code> from <em>src/addrdb.cpp</em>, passing in the <code>NetGroupManager</code>, our global program <code>args</code> and a pointer to the (to be initialized) <code>Addrman</code>.
<code>args</code> are used to determine whether consistency checks should run and to pass on the <code>datadir</code> value in order to attempt deserialization on any addrman database (<code>peers.dat</code>) that is found.</p>
</div>
<div class="paragraph">
<p>Addresses are serialized back to disk both after the call to <code>CConnman::StopNodes()</code>, but also periodically (by default every 15 minutes) as scheduled by <code>CConnman::Start()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">    // Dump network addresses
    scheduler.scheduleEvery([this] { DumpAddresses(); }, DUMP_PEERS_INTERVAL);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_adding_addresses_to_addrman"><a class="link" href="#_adding_addresses_to_addrman">Adding addresses to addrman</a></h5>
<div class="paragraph">
<p>Addresses learned about over the wire will be <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net_processing.cpp#L2897-L2908" target="_blank" rel="noopener">deserialized</a> into a vector of <code>CAddress</code>-es.
After determining whether we should expend resources on processing these addresses&#8201;&#8212;&#8201;check that address relay with this peer is permitted <em>and</em> that peer is not marked as misbehaving&#8201;&#8212;&#8201;we shuffle the addresses and begin testing them as candidates for addition to our addrman.</p>
</div>
<div class="paragraph">
<p>Address candidate testing consists of checking:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we are not rate-limiting the peer who sent us the address</p>
</li>
<li>
<p>it is a full node (via service flag bits)</p>
</li>
<li>
<p>if we already know of the address</p>
</li>
<li>
<p>if they&#8217;re automatically discouraged or manually banned</p>
</li>
<li>
<p><code>IsReachable()</code> and <code>IsRoutable()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once these checks have finished we will add all the addresses we were happy with by calling <code>AddrMan::Add()</code> and passing the vector of good addresses in along with metadata on who sent us this address in the form of a <code>CNetAddr</code> (the source address).
The source address is notably used later in <code>Add()</code> (by <code>AddrmanImpl::AddSingle()</code>) to determine which new bucket this new address should be placed into as an anti-sybil measure.</p>
</div>
<div class="paragraph">
<p>Addresses are added into the appropriate bucket and position in <code>vvNew</code>.
If there <strong>is not</strong> an address in the corresponding bucket/position then the new address will be added there immediately.
If there <strong>is</strong> currently an address in the corresponding bucket/position then <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/addrman.cpp#L67-L85" target="_blank" rel="noopener"><code>IsTerrible()</code></a> is called to determine whether the old address should be evicted to make room for the new one or not, in which case the new address is simply dropped.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This eviction behaviour is distinct from test-before-evict described below in <a href="#_good">Good</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_good"><a class="link" href="#_good">Good</a></h5>
<div class="paragraph">
<p>New connections are initiated by <a href="#_connman">Connman</a>, in <code>CConnman::ThreadOpenConnections()</code>.
Addresses are considered "good" and will begin being processed by <code>Addrman::Good()</code> if:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>we have received a version message from them</p>
</li>
<li>
<p>it was an <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net_processing.cpp#L2732-L2747" target="_blank" rel="noopener">outbound</a> connection</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next we use the following process to determine whether the address should be added to one of the buckets in the <code>vvTried</code> set:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>we will first check that the address i) does not already exist in <code>vvTried</code>, and that ii) it <em>does</em> exist in <code>vvNew</code>.</p>
</li>
<li>
<p>if the address is not yet in <code>vvTried</code> we will determine its bucket and position and then check if there is already an address at that position.</p>
</li>
<li>
<p>if there is an address there, we will initiate a <code>FEELER</code> connection to the existing node.</p>
</li>
<li>
<p>if the feeler is successful then we drop the new address and keep what we have.</p>
</li>
<li>
<p>if the feeler is unsuccessful then we drop the old address and insert the new address at this location using <code>MakeTried()</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This process is called <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Addrman-and-eclipse-attacks#countermeasure-3-test-before-evict---9037" target="_blank" rel="noopener">test-before-evict</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_select"><a class="link" href="#_select">Select</a></h5>
<div class="paragraph">
<p><code>CConnman::ThreadOpenConnections()</code> also handles selection of new peers to connect to, via <code>Addrman::Select()</code>.</p>
</div>
<div class="paragraph">
<p>This first occurs when we want to try a new <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.cpp#L2114-L2125" target="_blank" rel="noopener">feeler</a>, but we will use the same approach for <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.cpp#L2128-L2129" target="_blank" rel="noopener">non-feeler</a> connections too.</p>
</div>
<div class="paragraph">
<p>The <code>Select()</code> function contains a lot of <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/addrman.cpp#L703-L770" target="_blank" rel="noopener">interesting</a> logic, specifically related to injecting randomness into the process of drawing a new address to connect to from our untried buckets.</p>
</div>
<div class="paragraph">
<p>It starts by using a 50% chance between selecting an address from our <code>tried</code> and <code>new</code> buckets, before using additional (non-cryptographic) randomness to select a bucket and position, before iterating over the bucket until it finds an address.
Once it has selected an address, it uses additional randomness via <code>GetChance()</code>, to determine whether it will actually <em>use</em> this address to connect to.</p>
</div>
<div class="paragraph">
<p>The purpose of the additional <code>chance</code> in address selection is that it helps to <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/addrman.cpp#L87-L100" target="_blank" rel="noopener">deprioritize</a> recently-tried and failed addresses.</p>
</div>
<div class="paragraph">
<p>The use of randomness like this in addrman is to combat types of attack where our addrman might become "poisoned" with a large number of sybil or otherwise-bad addresses.
The use of bucketing and randomness means that these types of attacks are much harder to pull off by an attacker, requiring for example a large number of nodes on different Autonomous Systems.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_banman"><a class="link" href="#_banman">Banman</a></h4>
<div class="paragraph">
<p>Banman is generally used as a filter to determine whether we should accept a new incoming connection from a certain IP address, or less-frequently to check whether we should make an out-bound connection to a certain IP address:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We do not accept connections from banned peers</p>
</li>
<li>
<p>We only accept connections from discouraged peers if our inbound slots aren&#8217;t (almost) full</p>
</li>
<li>
<p>We do not process (check <code>IsReachable()</code> and <code>IsRoutable()</code> and <code>RelayAddress()</code>) addresses received in an <code>ADDR</code> / <code>ADDRV2</code> which are banned, but do remember that we have received them</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Banman is setup with a simple call to its constructor, passing in a <code>banlist</code> and <code>bantime</code> argument.
<code>banlist</code> will store previously-banned peers from last shutdown, while <code>bantime</code> determines how long the node discourages "<a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net_processing.h#L72-L77" target="_blank" rel="noopener">misbehaving</a>" peers.</p>
</div>
<div class="paragraph">
<p>Banman operates primarily with bare IP addresses (<code>CNetAddr</code>) but can also, when initiated by the user, ban an entire subnet (as a <code>CSubNet</code>).</p>
</div>
<div class="paragraph">
<p>Note that banman handles <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/banman.h#L28-L56" target="_blank" rel="noopener">both</a> manual bans initiated by the user (with <code>setban</code>) and also automatic discouragement of peers based on P2P behaviour.</p>
</div>
<div class="paragraph">
<p>The banman header file <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/banman.h#L28-L56" target="_blank" rel="noopener">contains</a> some good background on what banning can and can&#8217;t protect against, as well as why we do not automatically ban peers in Bitcoin Core.</p>
</div>
</div>
<div class="sect3">
<h4 id="_connman"><a class="link" href="#_connman">Connman</a></h4>
<div class="paragraph">
<p>Connman is used to manage connections and maintain statistics on each node connected, as well as network totals.
There are many connection-related program options for it such as number of connections and whitebound ports/interfaces.
It takes an Addrman and a NetGroupManager to its constructor, along with two random seeds used to seed the SipHash randomizer.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The nonces generated by the randomizer are used to detect us making new connections to ourself, as the incoming nonce in the version message would match our <code>nLocalHostNonce</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Connman is started via <code>node.connman&#8594;Start()</code> in <em>init.cpp</em>.
This begins by calling <code>init()</code> which binds to any ports selected, before starting up an I2P session if the I2P proxy is found.
Next it schedules sending <code>GETADDR</code> to any seednodes provided (via <code>-seednodes</code>) using the <code>ThreadOpenConnections()</code> loop, and then continues by loading anchor connections from <em>anchors.dat</em>.
Following this the various <a href="#_net_threads">net threads</a> are started up.</p>
</div>
<div class="paragraph">
<p>As connman has a pointer to the node&#8217;s addrman it can directly fetch new addresses to serve via <code>CConnman:GetAddresses()</code>.
If new addresses are requested from a remote P2P node (via <code>GETADDR</code>), then it will use a <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.h#L1129-L1154" target="_blank" rel="noopener">cached</a> addr response to respond with.
This helps to defeat surveillance which is seeking to determine which other peers your node is connected to.</p>
</div>
<div class="paragraph">
<p>Within <code>CConnman</code> we maintain <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.h#L1123" target="_blank" rel="noopener"><code>m_nodes</code></a>, a vector of connections to other nodes.
That vector is updated and accessed by various threads, including:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.cpp#L1709-L1718" target="_blank" rel="noopener">socket handler thread</a>, which is responsible for reading data from the sockets into receive buffers, and also for accepting new incoming connections.</p>
</li>
<li>
<p>The <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.cpp#L1912" target="_blank" rel="noopener">open connections thread</a>, which is responsible for opening new connections to peers on the network.</p>
</li>
<li>
<p>The <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.cpp#L2313" target="_blank" rel="noopener">message handler thread</a>, which is responsible for reading messages from the receive buffer and passing them up to net_processing.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Since the vector can be updated by multiple threads, it is guarded by a mutex called <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.h#L1123-L1125" target="_blank" rel="noopener"><code>m_nodes_mutex</code></a>.</p>
</div>
<div class="sect4">
<h5 id="_cconnmanthreadopenconnections"><a class="link" href="#_cconnmanthreadopenconnections">CConnman::ThreadOpenConnections()</a></h5>
<div class="paragraph">
<p>This thread begins by making any manually-specified connections before entering a double-nested <code>while</code> loop.
The outer loop handles making a connection on each loop according certain priorities and the number of connections we currently have:</p>
</div>
<div class="listingblock">
<div class="title"><em>net.cpp#L2028</em></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">// Determine what type of connection to open. Opening
// BLOCK_RELAY connections to addresses from anchors.dat gets the highest
// priority. Then we open OUTBOUND_FULL_RELAY priority until we
// meet our full-relay capacity. Then we open BLOCK_RELAY connection
// until we hit our block-relay-only peer limit.
// GetTryNewOutboundPeer() gets set when a stale tip is detected, so we
// try opening an additional OUTBOUND_FULL_RELAY connection. If none of
// these conditions are met, check to see if it's time to try an extra
// block-relay-only peer (to confirm our tip is current, see below) or the next_feeler
// timer to decide if we should open a FEELER.</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to filling out connections up to full-relay and block-relay-only capacity it also periodically makes a feeler connection to a random node from addrman to sync headers and test that we haven&#8217;t been eclipsed.</p>
</div>
<div class="paragraph">
<p>After selecting which type of connection we are going to attempt on this iteration we enter the inner loop which attempts to make the connection itself.
We select the connection by assigning it to <code>addrconnect</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If it is trying to make an anchor connection then simply set <code>addrconnect</code> to the selected <code>addr</code> and break from the loop early</p>
</li>
<li>
<p>If it is trying to make a feeler connection then we request a collision address or if one is not available then select another <code>vvTried</code> table address using <code>addrman.Select()</code>.</p>
</li>
<li>
<p>If it is neither an anchor or a feeler just call <code>addrman.Select()</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A "collision address" means that another address had tried to evict this address from <code>vvTried</code> table, these addresses are marked in <code>Addrman.m_tried_collisions</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the various checks pass, then finish by calling <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.cpp#L2177" target="_blank" rel="noopener"><code>OpenNetworkConnection()</code></a>.
<code>OpenNetworkConnection()</code> makes the connection by calling <code>ConnectNode()</code>, which if successful creates a new <code>CNode</code> object for the connected node and returns it.
Next we initialize the <code>CNode</code> with cconnman&#8217;s pointer to <code>peerman</code>, via <code>m_msgproc&#8594;InitializeNode(pnode)</code>.
Finally we add the connected and initialized node to <code>CConnman.m_nodes</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bootstrapping"><a class="link" href="#_bootstrapping">Bootstrapping</a></h3>
<div class="paragraph">
<p>Bootstrapping is probably the most dangerous moment in a node&#8217;s life.
If the new node cannot make at least one connection to an honest node, from whom it can eventually learn more honest addresses, then it may not ever be able to join the most-work bitcoin chain without manual user intervention.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Manual intervention here would require the user to find the IP address of a known-honest node and connect to it either using <code>addnode</code> or <code>connect</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the node first starts up, and if no node addresses are manually specified, we have no choice but to fetch addresses from one (or more) hardcoded DNS seed(s) the list of which can be found in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/chainparams.cpp#L121-L129" target="_blank" rel="noopener"><em>src/chainparams.cpp</em></a>.</p>
</div>
<div class="paragraph">
<p>If the node is fed only attacker-controlled addresses by one or more dishonest DNS seed(s) then it has little opportunity to join the rest of the honest network.
However, if one or more of the addresses returned by the DNS query are honest then we want the node to be able to (eventually) find and connect to the honest network.</p>
</div>
<div class="paragraph">
<p>Note that if the DNS seed queries are unsuccessful, or the node is being run in a Tor-only mode (and currently the DNS seeds cannot support long Tor V3 addresses) then bitcoind will fall back to connecting to a hard-coded <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/chainparamsseeds.h" target="_blank" rel="noopener">list</a> of seed nodes.
This fall back functionality could help to protect against e.g. an attack on the DNS seed infrastructure.</p>
</div>
</div>
<div class="sect2">
<h3 id="_service_flags"><a class="link" href="#_service_flags">Service flags</a></h3>
<div class="paragraph">
<p>Nodes can advertise <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/protocol.h#L266-L296">service flags</a> (a.k.a. "service bits") indicating which services that node supports.</p>
</div>
</div>
<div class="sect2">
<h3 id="_managing_connections"><a class="link" href="#_managing_connections">Managing connections</a></h3>
<div class="paragraph">
<p>An enumeration of the different types of connections, along with detailed descriptions on their functions, can be found in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net.h#L117-L184">src/<em>net.h</em></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_message_relay"><a class="link" href="#_message_relay">Message relay</a></h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Relay policy of different messages</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 42.8571%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Message type</th>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Who</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Addresses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PeerManagerImpl::RelayAddress()</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Outbound peers &amp; inbound peers who send an addr-related message but not block-relay-only peers</p>
</div>
<div class="paragraph">
<p>Reachable addresses to 2 peers. Unreachable addresses randomly to 1 or 2 peers.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transactions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PeerManagerImpl::RelayTransaction()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All connected peers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Blocks</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>PeerManagerImpl::UpdatedBlockTip()</code></p>
</div>
<div class="paragraph">
<p><code>PeerManagerImpl::MaybeSendAddr()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All connected peers</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_address_relay"><a class="link" href="#_address_relay">Address relay</a></h4>
<div class="paragraph">
<p>The Bitcoin network uses <code>addr</code> messages to communicate (node) network addresses.
See the <a href="https://en.bitcoin.it/wiki/Protocol_documentation#addr" target="_blank" rel="noopener">Bitcoin wiki p2p documentation</a> for more details.
Good address propagation improves network connectivity and increases the difficulty of executing an eclipse attack.</p>
</div>
<div class="paragraph">
<p>Bitcoin Core nodes will periodically self-announce (also known as self-advertise) their own network address to peers.
When a Bitcoin Core node receives an <code>addr</code> message that contains 10 addresses or fewer, it forwards those addresses with a timestamp within 10 minutes of the current time to 1 or 2 peers, selected at random.
If we assume all nodes do this, then self-announcements should reach a large portion of the nodes on the network. The timestamp condition is there to ensure that the relay of a given address stops after some time.</p>
</div>
<div class="paragraph">
<p>Since <a href="https://github.com/bitcoin/bitcoin/pull/22387" target="_blank" rel="noopener">PR#22387</a>, there is a rate limit for address relay processing, so that addresses from peers that send too many of them are ignored which can help to prevent CPU/memory exhaustion attacks.</p>
</div>
<div class="sect4">
<h5 id="_addr_privacy"><a class="link" href="#_addr_privacy"><code>Addr</code> privacy</a></h5>
<div class="paragraph">
<p>For some time, it was possible for a spy node to easily scrape the full contents of any reachable node&#8217;s <code>AddrMan</code>.
The spy just had to connect to a victim node multiple times and execute <code>GETADDR</code>.
This scraped data could then be used to infer private information about the victim.</p>
</div>
<div class="paragraph">
<p>For example, a spy could monitor the victim&#8217;s <code>AddrMan</code> content in real time and figure out which peers a node is connected to.
A spy could also compare the <code>AddrMan</code> content from two different connections (e.g. one identified by Tor address and one identified by IPv4) and figure out that it&#8217;s actually the same physical node (<code>fingerprinting</code>).</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/18991" target="_blank" rel="noopener">PR#18991</a> was a first step towards fixing these privacy issues.
By limiting (caching) the leaked portion of <code>AddrMan</code>, these inference activities became much harder.
Caching in this context means that the <code>ADDR</code> response (which is only a small subset of a node&#8217;s <code>AddrMan</code> content) remains the same for every <code>GETADDR</code> call during (roughly) a day.</p>
</div>
</div>
<div class="sect4">
<h5 id="_addr_black_holes"><a class="link" href="#_addr_black_holes">Addr black holes</a></h5>
<div class="paragraph">
<p>We know that some nodes on the network do <em>not</em> relay <code>addr</code> messages that they receive.
Two known cases are block-relay-only connections from Bitcoin Core nodes, and connections from certain light clients.
We refer to these connections as <code>addr</code> black holes.
<code>addr</code> messages go in, but they never escape!</p>
</div>
<div class="paragraph">
<p>If a large portion of the connections on the network are <code>addr</code> black holes, then <code>addr</code> propagation may be negatively impacted: self-announcements might not reach a majority of nodes on the network in a timely fashion.
It&#8217;d be better if we could somehow avoid picking black holes as the 1 or 2 peers that we select for relaying <code>addr</code> messages to.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/21528" target="_blank" rel="noopener">PR#21528</a> defers initialization of <code>m_addr_known</code> of inbound peers until the peer sends an address related message (<code>addr</code>, <code>addrv2</code>, <code>getaddr</code> or <code>sendaddrv2</code>).
The node uses the presence of <code>m_addr_known</code> to decide whether the peer is a candidate for relaying <code>addr</code> messages received from the network.</p>
</div>
</div>
<div class="sect4">
<h5 id="_addrv2"><a class="link" href="#_addrv2">addrv2</a></h5>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/19031" target="_blank" rel="noopener">PR#19031</a> is a proposed implementation of the <a href="https://github.com/bitcoin/bips/blob/9286b5254317d9e73fb25c5f0acd2b2d9937843e/bip-0155.mediawiki" target="_blank" rel="noopener">BIP155</a> <code>addrv2</code> message, a new P2P message format proposed in early 2019 by Wladimir J. van der Laan to gossip longer node addresses.</p>
</div>
<div class="paragraph">
<p>The <code>addrv2</code> message is required to support <a href="https://trac.torproject.org/projects/tor/wiki/doc/NextGenOnions" target="_blank" rel="noopener">next-generation Tor v3 Onion addresses</a>, the <a href="https://geti2p.net" target="_blank" rel="noopener">Invisible Internet Project (I2P)</a>, and potentially other networks that have longer endpoint addresses than fit in the 128 bits/16 bytes of the current <code>addr</code> message.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_transaction_relay"><a class="link" href="#_transaction_relay">Transaction relay</a></h4>
<div class="paragraph">
<p>Relaying transactions is a core tenet of a Bitcoin node, along with <a href="#_address_relay">Address relay</a> and <a href="#_block_relay">Block relay</a>.
However, we don&#8217;t necessarily want to immediately relay transactions we accept into our mempool immediately for the following reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Privacy: Adding a small delay in transaction relay helps obscure the route transactions take, making it harder to use transaction timing to infer the structure of the network or the original source of the transaction.</p>
</li>
<li>
<p>Load balancing: Having a small delay in transaction relay helps avoid the possibility that all transactions will be requested from the peer with the lowest network latency simply because they announce the transaction first.</p>
</li>
<li>
<p>Saving bandwidth: Having a longer delay in transaction relay may allow some transactions to not be relayed at all, eg in the case where a low fee rate transaction is accepted into the mempool and then evicted due to being at the bottom of the mempool, or RBFed prior to being relayed.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_rejecting_incoming_transactions"><a class="link" href="#_rejecting_incoming_transactions">Rejecting incoming transactions</a></h5>
<div class="paragraph">
<p>In addition to being careful about transaction relay, we must also reject (some) incoming transactions before they enter our mempool, which acts as a DoS prevention measure for our node.
If we were to accept and blindly relay all transactions INVed to us by our peers, then an attacker could cheaply use (waste) a node&#8217;s system resources and bandwidth, and have their attack amplified by the transaction flooding mechanism.</p>
</div>
<div class="paragraph">
<p>How do we currently limit incoming transactions?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We reject transactions which don&#8217;t pass policy checks e.g.:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>We reject transactions that don&#8217;t pay the <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L833">mempool min fee</a> (set based on maximum mempool size)</p>
</li>
<li>
<p>We reject RBF transactions that don&#8217;t <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L927-L928">increase the fee rate</a> by more than <code>-incrementalrelayfee</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>We reject transactions which don&#8217;t pass replacement/package checks.</p>
</li>
<li>
<p>We reject transactions which don&#8217;t pass consensus checks.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>What other mechanisms <em>could</em> we consider using before the <a href="#_single_transactions">ATMP</a> checks are performed?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We <em>could</em> reject transactions from individual peers that send transactions at too high a rate, however this would just encourage attackers to make multiple connections, using up additional inbound slots</p>
</li>
<li>
<p>We <em>could</em> ignore transactions from any peer once some rate limit is hit, however this would drop high feerate transactions from innocent peers which would be doubly undesirable</p>
</li>
<li>
<p>We <em>could</em> artificially increase our mempool min fee when a rate limit is exceeded, even if the mempool is not full?</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_initial_broadcast"><a class="link" href="#_initial_broadcast">Initial broadcast</a></h5>
<div class="paragraph">
<p>If a spy is able to identify which node initially broadcast a transaction, there&#8217;s a high probability that that node is the source wallet for the transaction.
To avoid that privacy leak, we try to be intentional about how we relay and request transactions.
We don&#8217;t want to reveal the exact contents of our mempool or the precise timing when we received a transaction.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/18861" target="_blank" rel="noopener">PR#18861</a> improved transaction-origin privacy.
The idea is that if we haven&#8217;t yet announced a transaction to a peer, we shouldn&#8217;t fulfil any <code>GETDATA</code> requests for that transaction from that peer.
The implementation for that PR checks the list of transactions we are about to announce to the peer (<code>setInventoryTxToSend</code>), and if it finds the transaction that the peer has requested, then responds with a <code>NOTFOUND</code> instead of with the transaction.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While this helps in many cases, why is it still an imperfect heuristic?</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/19109" target="_blank" rel="noopener">PR#19109</a> further reduces the possible attack surface.
It introduces a per-peer rolling bloom filter (<code>m_recently_announced_invs</code>) to track which transactions were recently announced to the peer.
When the peer requests a transaction, we check the filter before fulfilling the request and relaying the transaction.</p>
</div>
</div>
<div class="sect4">
<h5 id="_rebroadcasting_transactions"><a class="link" href="#_rebroadcasting_transactions">Rebroadcasting transactions</a></h5>
<div class="paragraph">
<p>Hiding links between wallet addresses and IP addresses is a key part of Bitcoin privacy.
Many techniques exist to help users obfuscate their IP address when submitting their own transactions, and various P2P changes have been proposed with the goal of hiding transaction origins.</p>
</div>
<div class="paragraph">
<p>Beyond initial broadcast, <em>rebroadcast</em> behaviour can also leak information.
If a node rebroadcasts its own wallet transactions differently from transactions received from its peers, for example more frequently, then adversaries could use this information to infer transaction origins even if the initial broadcast revealed nothing.</p>
</div>
<div class="paragraph">
<p>The goal is to improve privacy by making node rebroadcast behaviour for wallet transactions indistinguishable from that of other peers' transactions.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/21061" target="_blank" rel="noopener">PR#21061</a> adds a <code>TxRebroadcast</code> module responsible for selecting transactions to be rebroadcast and keeping track of how many times each transaction has been rebroadcast.
After each block, the module uses the miner and other heuristics to select transactions from the mempool that it believes "should" have been included in the block and re-announces them (disabled by default for now).</p>
</div>
<div class="paragraph">
<p>Rebroadcasts happen once per new block.
The set of transactions to be rebroadcast is calculated as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The node regularly estimates the minimum feerate for transactions to be included in the next block, <code>m_cached_fee_rate</code>.</p>
</li>
<li>
<p>When a new block arrives, the transactions included in the block are removed from the mempool. The node then uses <code>BlockAssembler</code> to calculate which transactions (with a total weight up to 3/4 of the block maximum) from the mempool are more than 30 minutes old and have a minimum feerate of <code>m_cached_fee_rate</code>. This results in a set of transactions that our node would have included in the last block.</p>
</li>
<li>
<p>The rebroadcast attempt tracker, <code>m_attempt_tracker</code>, tracks how many times and how recently we&#8217;ve attempted to rebroadcast a transaction so that we don&#8217;t spam the network with re-announcements.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_block_relay"><a class="link" href="#_block_relay">Block relay</a></h4>
<div class="paragraph">
<p>After a block is mined it is broadcast to the P2P network where it will eventually be relayed to all nodes on the network.
There are two methods available for relaying blocks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Legacy Relay</strong></p>
<div class="ulist">
<ul>
<li>
<p>A node participating in legacy relaying will always send or request entire blocks.</p>
</li>
<li>
<p>For nodes that maintain a mempool this is quite bandwidth inefficient, since they probably already have most of the transactions from a new block in their mempool.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Compact Block Relay</strong></p>
<div class="ulist">
<ul>
<li>
<p>Specified in <a href="https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki" target="_blank" rel="noopener">BIP 152</a>.</p>
</li>
<li>
<p>The goal is to address the bandwidth inefficiencies of legacy relaying by only relaying the transactions of a new block that the requesting peer has not yet seen.</p>
</li>
<li>
<p>Check out this <a href="https://bitcoincore.org/en/2016/06/07/compact-blocks-faq/" target="_blank" rel="noopener">Compact Blocks FAQ</a> for benchmarks and more info.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_blocksonly_vs_block_relay_only"><a class="link" href="#_blocksonly_vs_block_relay_only">blocksonly vs block-relay-only</a></h4>
<div class="paragraph">
<p>Bitcoin Core 0.12 introduced a <code>-blocksonly</code> setting that can reduce a node&#8217;s bandwidth usage by 88%.
The reduction is achieved by not participating in transaction relay.
For more info check out <a href="https://bitcointalk.org/index.php?topic=1377345.0" target="_blank" rel="noopener">this post</a> on blocksonly mode by Gregory Maxwell.</p>
</div>
<div class="paragraph">
<p>Blocksonly nodes currently use compact block relaying to download blocks even though they don&#8217;t maintain a full mempool.
<a href="https://github.com/bitcoin/bitcoin/pull/22340" target="_blank" rel="noopener">PR#22340</a> makes blocksonly nodes use legacy relaying to download new blocks.
Because <code>-blocksonly</code> is a global startup option, it therefore applies to all connections</p>
</div>
<div class="paragraph">
<p>block-relay-only connections are a specific type of connection which is used by Bitcoin Core full nodes to only participate in block relay.</p>
</div>
<div class="paragraph">
<p>As currently implemented block-relay-only connections (introduced in <a href="https://github.com/bitcoin/bitcoin/pull/15759" target="_blank" rel="noopener">PR#15759</a>), disables both transaction and address relay.
Bitcoin Core nodes per default settings make two <strong>outbound</strong> block-relay-only connections in addition to 8 regular outbound connections (also see <a href="#_eclipse_attacks">Eclipse attacks</a> for more use cases of these connections).</p>
</div>
<table id="blocksonly-vs-block-relay-only" class="tableblock frame-all grid-all fit-content stretch">
<caption class="title">Table 15. blocksonly mode vs block-relay-only connections</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#160;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-blocksonly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">block-relay-only</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies to</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All node connections (global)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two randomly-chosen connections</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Does <code>Addr</code> relay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sends transactions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">May do in special cases (e.g. submitted via RPC)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receives transactions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Signals not to with <code>fRelay</code>, will disconnect if breached</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other connections</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">still makes two block-relay-only connections<br>
(for which block-relay-only rules apply)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_bloom_filters_and_spv"><a class="link" href="#_bloom_filters_and_spv">Bloom filters and SPV</a></h5>
<div class="paragraph">
<p>A <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">bloom filter</a> is a probabilistic data structure.
It supports two operations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>adding</em> an element to the filter</p>
</li>
<li>
<p><em>querying</em> an element from the filter</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If an element has been previously added, then querying for the element will return <em>true</em>.
If an element has not been added, then querying for the element may return <em>true</em> or <em>false</em>.
In other words, querying may return a <em>false positive</em>, but will never return a <em>false negative</em>.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">wikipedia page</a> for how a bloom filter is implemented with hash functions onto a bitfield.
Note that the false positive rate depends on the size of the filter and the number of hash functions.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki" target="_blank" rel="noopener">BIP 37</a> introduced a new method for <a href="https://developer.bitcoin.org/devguide/operating_modes.html#simplified-payment-verification-spv" target="_blank" rel="noopener">Simple Payment Verification (SPV)</a> clients to use bloom filters to track transactions that affect their addresses.
BIP 37 was implemented in Bitcoin Core in <a href="https://github.com/bitcoin/bitcoin/pull/1795" target="_blank" rel="noopener">PR#1795</a>.</p>
</div>
<div class="paragraph">
<p>Using the P2P messages defined in BIP 37, an SPV client can request that a full node send it transactions which match a bloom filter.
The full node will then relay unconfirmed transactions that match the filter, and the client can request <a href="https://github.com/bitcoin/bitcoin/blob/608359b071dac82a9cf33a6c9e01f87abfcb90eb/src/merkleblock.h#L127-L132" target="_blank" rel="noopener">merkle blocks</a>, which only contain the transactions that match the filter.</p>
</div>
<div class="paragraph">
<p>The SPV client chooses the bloom filter parameters (filter size, number of hashes and a 'tweak' for the hashes) and sends them to the node in a <code>filterload</code> message.</p>
</div>
<div class="paragraph">
<p>The original implementation contained a logic bug. If the client sent a <code>filterload</code> message with a zero-sized filter, then the serving node could later attempt a divide-by-zero and crash when querying an element from the filter. See <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-5700" target="_blank" rel="noopener">CVE-2013-5700</a> for further details.</p>
</div>
<div class="paragraph">
<p>This bug was quietly fixed in <a href="https://github.com/bitcoin/bitcoin/pull/2914" target="_blank" rel="noopener">PR#2914</a> without advertising the reason.
That fix added the <code>isFull</code> and <code>isEmpty</code> booleans, which have proven to be confusing for developers.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/18806" target="_blank" rel="noopener">PR#18806</a> removed those <code>isFull</code> and <code>isEmpty</code> booleans and adds a more straightforward fix for the issue.</p>
</div>
</div>
<div class="sect4">
<h5 id="_compact_block_filters_for_light_clients"><a class="link" href="#_compact_block_filters_for_light_clients">Compact Block Filters for Light Clients</a></h5>
<div class="paragraph">
<p>Compact Block Filters were introduced with BIP 157/158 as an improvement upon Bloom filters, as used in BIP 37.
<strong>Instead of the client sending a filter</strong> to a full node peer, <strong>full nodes generate deterministic filters on block data that are served to the client</strong>.
The light client gets these filters from the server and checks for itself if any of its objects match what is seen in the filter.
If it does match, then the light client asks for the full block.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki" target="_blank" rel="noopener">BIP 158</a> describes a structure for compact filters on block data.
It specifies one filter type called<strong>Basicblock filters</strong>, which encodes the scriptPubKeys of all the UTXOs spent in the block, and the scriptPubKeys of all the new UTXOs created in the block.
<strong>This is the only block filter currently supported</strong>.
<a href="https://github.com/bitcoin/bitcoin/pull/12254" target="_blank" rel="noopener">PR#12254</a> implemented compact block filters in Bitcoin Core, and <a href="https://github.com/bitcoin/bitcoin/pull/14121" target="_blank" rel="noopener">PR#14121</a> added a new index (<code>-blockfilterindex=1</code>), which stores the compact block filters for blocks that have been validated.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki" target="_blank" rel="noopener">BIP 157</a> is the proposed specification for requesting and sending compact filters between nodes on the p2p network.
It was implemented with a series of PRs, demonstrated in <a href="https://github.com/bitcoin/bitcoin/pull/18876" target="_blank" rel="noopener">PR#18876</a>.</p>
</div>
<div class="paragraph">
<p>Benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Less asymmetry in the client.
If light clients request a filter for a block, the server wont have to do any more work than the client had to do when making the request.</p>
</li>
<li>
<p>More privacy and less trust.
The light client no longer sends a fingerprint of the data it is interested in to the server, and so it becomes way more difficult to analyse the light clients activity.</p>
</li>
<li>
<p>Conceptually, BIP158&#8217;s Golomb-Coded Set (GCS) filter is similar to a Bloom filter (no false negatives, a controllable rate of false positives), but more compact.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Downsides:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They require more disk space because of the overhead that comes with the new index.</p>
</li>
<li>
<p>GCS filters are write-once (you can&#8217;t update them once created), and querying is much slower.</p>
<div class="ulist">
<ul>
<li>
<p>Bloom filters are effectively <code>O(n)</code> for finding <code>n</code> elements in them.
GCS are <code>O(m+n)</code> for finding <code>n</code> elements in a filter of size <code>m</code>.
So, Bloom filters are way faster if you&#8217;re only going to do one or a few queries.
But as you&#8217;re querying for larger and larger number of elements, the relative downside of a GCS&#8217;s performance goes down.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>glimpse of the future</strong>; <a href="https://github.com/bitcoin/bitcoin/pull/25957" target="_blank" rel="noopener">PR#25957</a> uses BIP 157 block filters for faster wallet rescans.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_notifying_peers_of_relay_preferences"><a class="link" href="#_notifying_peers_of_relay_preferences">Notifying peers of relay preferences</a></h4>
<div class="paragraph">
<p>Currently, block-relay-only connections are established indirectly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When making an outbound block-relay-only connection, a node sets the boolean flag <code>fRelay</code> in the version message to <code>false</code>.</p>
</li>
<li>
<p><code>fRelay</code> (introduced in the context of <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki" target="_blank" rel="noopener">BIP 37</a>) does not imply that transactions cannot be sent for the entire duration of the connection - in its original use case with BIP37, relay of transactions can be activated later on.</p>
</li>
<li>
<p><code>fRelay=false</code> is also used in <strong>-blocksonly</strong> mode, a low-bandwidth option in which a node does not want to receive transactions from <strong>any peer</strong>, but does participate in address relay.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, nodes currently don&#8217;t have a notion which of their incoming peers see the connection as block-relay-only and don&#8217;t have any logic attached to it.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/20726" target="_blank" rel="noopener">PR#20726</a>, accompanied by the new BIP proposal <a href="https://github.com/sdaftuar/bips/blob/2021-02-bip338-fixups/bip-0338.mediawiki" target="_blank" rel="noopener">BIP 338</a>, introduces the new p2p message <code>disabletx</code> for block-relay-only connections, which makes it explicit that no messages related to transaction relay should ever be exchanged over the duration of the connection.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_p2p_message_encryption"><a class="link" href="#_p2p_message_encryption">P2P message encryption</a></h3>
<div class="paragraph">
<p>P2P messages are currently all unencrypted which can potentially open up vulnerabilities like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Associated metadata in P2P messages may reveal private information.</p>
</li>
<li>
<p>Possibilities for attackers who control the routing infrastructure of the P2P network to censor P2P
messages since P2P messages can be detected trivially - they always start with a fixed sequence of magic bytes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489" target="_blank" rel="noopener">BIP 324</a> proposes a new Bitcoin P2P protocol which features transport encryption and slightly lower bandwidth usage.</p>
</div>
<div class="paragraph">
<p><a href="https://bip324.com" target="_blank" rel="noopener">bip324.com</a> contains a list of all the open PRs and great resources to understand the proposal.
A visual explanation of how BIP 324 works can be found in this blog - <a href="https://github.com/stratospher/blogosphere/blob/main/bip324.md" target="_blank" rel="noopener">How to encrypt the P2P protocol?</a></p>
</div>
<div class="sect3">
<h4 id="_networking_contribution_to_node_rng_entropy"><a class="link" href="#_networking_contribution_to_node_rng_entropy">Networking contribution to node RNG entropy</a></h4>
<div class="paragraph">
<p>Entropy for the RNG is often harvested from network connections:</p>
</div>
<div class="listingblock">
<div class="title">src/net.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">net.cpp
488-
489:    // We're making a new connection, harvest entropy from the time (and our peer count)
490-    RandAddEvent((uint32_t)id);
--
743-
744:    // We just received a message off the wire, harvest entropy from the time (and the message checksum)
745-    RandAddEvent(ReadLE32(hash.begin()));
--
1160-
1161:    // We received a new connection, harvest entropy from the time (and our peer count)
1162-    RandAddEvent((uint32_t)id);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_peer_state"><a class="link" href="#_peer_state">Peer state</a></h3>
<div class="paragraph">
<p>Peer state is divided into two types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Network/Connection state</strong>; any low level stuff, sending/receiving bytes, keeping statistics, eviction logic, etc.</p>
</li>
<li>
<p><strong>Application state</strong>; any data that is transmitted within P2P message payloads, and the processing of that data.
Examples are tx inventory, addr gossiping, ping/pong processing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are three main data structures that handle peer state:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CNode</code> (defined in <code>net.h</code>, used by <code>m_nodes</code>(<code>CConnman</code>) and covered by <code>m_nodes_mutex</code>) is concerned with the <strong>connection state</strong> of the peer.</p>
</li>
<li>
<p><code>CNodeState</code> (defined in <code>netprocessing.cpp</code>, used by <code>m_node_states</code>(<code>PeerManager</code>) and covered by <code>cs_main</code>) is concerned with the <strong>application state</strong> of the peer.</p>
<div class="ulist">
<ul>
<li>
<p>It maintains validation-specific state about nodes, therefore guarded by <code>cs_main</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Peer</code> (defined in <code>netprocessing.cpp</code>, used by <code>m_peer_map</code>(<code>PeerManager</code>) and covered by <code>m_peer_mutex</code>) is concerned with the <strong>application state</strong> of the peer.</p>
<div class="ulist">
<ul>
<li>
<p>It doesn&#8217;t contain validation-critical data, therefore it is not guarded by <code>cs_main</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, there is still some <em>application state</em> contained in <code>CNode</code> for historic reasons.
<a href="https://github.com/bitcoin/bitcoin/issues/19398" target="_blank" rel="noopener">Issue 19398</a> outlines the process to eventually move this out of <code>CNode</code> as well as the reasoning behind the introduction of the <code>Peer</code> struct.</p>
</div>
</div>
<div class="sect2">
<h3 id="_p2p_violations"><a class="link" href="#_p2p_violations">P2P violations</a></h3>
<div class="paragraph">
<p>Bitcoin Core has several options for how to treat peers that violate the rules of the P2P protocol:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ignore the individual message, but continue processing other messages from that peer</p>
</li>
<li>
<p>Increment the peer&#8217;s "misbehaviour" score, and punish the peer once its score goes above a certain amount</p>
</li>
<li>
<p>Disconnect from the peer</p>
</li>
<li>
<p>Disconnect from the peer and prevent any later connections from that peer&#8217;s address (discouragement)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Since <a href="https://github.com/bitcoin/bitcoin/pull/20079" target="_blank" rel="noopener">PR#20079</a> we now treat handshake misbehaviour like an unknown message</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_p2p_changes"><a class="link" href="#_testing_p2p_changes">Testing P2P changes</a></h3>
<div class="paragraph">
<p>It can be challenging to test P2P changes as tooling and functional tests are lacking.
Often devs simply setup a new node with the patch and leave it for some time!?</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Is there fuzzing for P2P messages yet?</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_testing_transaction_and_block_relay_under_segwit"><a class="link" href="#_testing_transaction_and_block_relay_under_segwit">Testing transaction and block relay under SegWit</a></h4>
<div class="paragraph">
<p>SegWit was a softfork defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki" target="_blank" rel="noopener">BIP 141</a>, with P2P changes defined in <a href="https://github.com/bitcoin/bips/blob/65529b12bb01b9f29717e1735ce4d472ef9d9fe7/bip-0144.mediawiki" target="_blank" rel="noopener">BIP 144</a>.</p>
</div>
<div class="paragraph">
<p>SegWit was activated at block 481,824 in August 2017.
Prior to activation, some very careful testing was carried out to verify different scenarios, for example:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>How are transactions and blocks relayed between un-upgraded and upgraded nodes?</p>
</li>
<li>
<p>How do upgraded nodes find other upgraded nodes to connect to?</p>
</li>
<li>
<p>If a node is un-upgraded at activation time and subsequently upgrades, how does it ensure that the blocks that it previously validated (without segwit rules) are valid according to segwit rules?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To enable this kind of testing, <a href="https://github.com/bitcoin/bitcoin/pull/8418" target="_blank" rel="noopener">PR#8418</a> made it possible to configure the segwit activation parameters using a <code>-bip9params</code> configuration option.
That configuration option was later renamed to <code>-vbparams</code> in <a href="https://github.com/bitcoin/bitcoin/pull/10463" target="_blank" rel="noopener">PR#10463</a>, and replaced with <code>-segwitheight</code> in <a href="https://github.com/bitcoin/bitcoin/pull/16060" target="_blank" rel="noopener">PR#16060</a>.</p>
</div>
<div class="paragraph">
<p>Those options allowed starting a node which would never activate segwit by passing <code>-vbparams=segwit:0:0</code> (or later, <code>-segwitheight=-1</code>).
This was used in the functional tests to test the node&#8217;s behaviour across activation.</p>
</div>
<div class="paragraph">
<p>The segwit mainnet activation was a one-time event.
Now that segwit has been activated, those tests are no longer required.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/21090" target="_blank" rel="noopener">PR#21090</a> removed the final tests that made use of <code>-segwitheight=0</code>.
With those tests removed, the special casing for <code>-segwitheight=-1</code> behaviour can also be removed.
That special casing impacted logic in <em>net_processing</em>, <em>validation</em> and <em>mining</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_4"><a class="link" href="#_exercises_4">Exercises</a></h3>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Using either <code>bitcoin-cli</code> in your terminal, or a <a href="#test_shell_nodes">Jupyter Notebook</a> in conjunction with the <code>TestShell</code> class from the Bitcoin Core Test Framework, try to complete the following exercises.</p>
</div>
<div class="paragraph">
<p>Changes to the codebase will require you to re-compile afterwards.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to use the compiled binaries found in your source directory, for example <code>/home/user/bitcoin/src/bitcoind</code>, otherwise your system might select a previously-installed (non-modified) version of bitcoind.</p>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make manual connections</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-square-o"></i> Add the following configuration options to a new Bitcoin Core node running on signet to have it start it with no connections:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">signet=1
dnsseed=0
fixedseeds=0
debug=addrman</code></pre>
</div>
</div>
</li>
<li>
<p><i class="fa fa-square-o"></i> Find the (only!) Signet DNS seeder node (in the <code>SigNetParams</code> class starting with "seed") and using a terminal poll this seed node for an address to connect to.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use <code>dig</code> or <code>nslookup</code> to retrieve seeds from the DNS seeder from the DNS seeders.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you try this with the mainnet seeds you will need to consider which <a href="#_service_flags">service flags</a> the seeder advertises support for.
For example, if a seed node advertises <code>x1</code> support this means they return ip addresses of nodes advertizing the <code>NODE_NETWORK</code> service flag.</p>
</div>
<div class="paragraph">
<p>You could query these from sipa&#8217;s mainnet seeder by prepending <code>x1</code> to the subdomain e.g. <code>nslookup x1.seeder.bitcoin.sipa.be</code></p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><i class="fa fa-square-o"></i> Check how many addresses are known to your node: <code>bitcoin-cli -signet getnodeaddresses 0 | jq length</code></p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Using one of the addresses returned from the previous exercise, connect to this node using the <code>addnode</code> RPC.</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Observe new addresses being received and connected to in the bitcoind terminal or <em>$DATADIR/debug.log</em> file.</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> What dangers can there be in retrieving node addresses in this way?</p>
</li>
<li>
<p><i class="fa fa-square-o"></i> Is this more of less safe than using the hardcoded seeds? Can you think of a better way to distribute seeds to new users?</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mempool"><a class="link" href="#_mempool">Mempool</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_mempool_terminology"><a class="link" href="#_mempool_terminology">Mempool terminology</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Ancestor(s)</dt>
<dd>
<p>One or more "parent" transactions which must be confirmed <strong>before</strong> the current transaction.<br>
The ancestor transaction(s) <em>create</em> outputs which are depended on by the current transaction.</p>
</dd>
<dt class="hdlist1">Descendant(s)</dt>
<dd>
<p>One or more "child" transactions which must be confirmed <strong>after</strong> the current transaction.<br>
The descendant transaction(s) <em>depend</em> on outputs from the current transaction.</p>
</dd>
<dt class="hdlist1">Orphan</dt>
<dd>
<p>A transaction with missing ancestors.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When <em>ancestor</em> and <em>descendant</em> are encountered in the codebase, they refer specifically to other <strong>in-mempool</strong> transactions.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Ancestors and descendants can be confirmed in the same block but they must be in the correct order within the list of <code>transactions</code> for the block to be valid.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mempool_purpose"><a class="link" href="#_mempool_purpose">Mempool purpose</a></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The mempool is designed to hold a list of unconfirmed-but-valid transactions that the node has learned about.</p>
</li>
<li>
<p>Miners will select transactions from the mempool for assembly into a block using the <code>getblocktemplate</code> RPC.</p>
</li>
<li>
<p>Transactions have to pass all policy and validation checks before being allowed to enter the mempool.<br>
The mempool therefore also acts as DoS protection for the node.</p>
</li>
<li>
<p>Transactions will not be added to the mempool if they do not meet fee requirements, are non-standard, or double-spend an input of a transaction already in the mempool (excluding BIP 125 RBF transactions).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There is a bitcoin-devwiki page <a href="https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Mempool-and-mining" target="_blank" rel="noopener">Mempool and mining</a> which includes some additional mempool philosophy.</p>
</div>
<div class="paragraph">
<p>James O&#8217;Beirne has <a href="https://github.com/jamesob/mempool.work/blob/master/README.md">written</a> a comprehensive overview of the current challenges and work in mempool design.
It "documents the existing design, failures, and vulnerabilities of the mempool as well as some proposals that exist to remedy the shortcomings."</p>
</div>
</div>
<div class="sect2">
<h3 id="_mempool_policy_goals"><a class="link" href="#_mempool_policy_goals">Mempool policy goals</a></h3>
<div class="paragraph">
<p>The documentation subfolder <a href="https://github.com/bitcoin/bitcoin/tree/master/doc/policy" target="_blank" rel="noopener">doc/policy</a> contains up-to-date information on <strong>some</strong>, but not all, of the current mempool policy rules.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mempool_life_cycle"><a class="link" href="#_mempool_life_cycle">Mempool life cycle</a></h3>
<div class="sect3">
<h4 id="_initialisation"><a class="link" href="#_initialisation">Initialisation</a></h4>
<div class="paragraph">
<p>The primary mempool object itself is initialized onto the <code>node</code> in <em>init.cpp</em> as part of <code>AppInitMain()</code> which takes <code>NodeContext&amp; node</code> as an argument.</p>
</div>
<div class="listingblock">
<div class="title">init.cpp#AppInitMain()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">assert(!node.mempool);
int check_ratio = std::min&lt;int&gt;(std::max&lt;int&gt;(args.GetIntArg("-checkmempool", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);
node.mempool = std::make_unique&lt;CTxMemPool&gt;(node.fee_estimator.get(), check_ratio);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>check_ratio</code>, used to determine sanity checks, defaults to <code>0</code> for all networks except regtest, unless the <code>checkmempool</code> program option has been specified.</p>
</div>
<div class="paragraph">
<p>Sanity checking here refers to checking the consistency of the entire mempool every 1 in <code>n</code> times a new transaction is added, so is potentially computationally expensive to have enabled.<br>
See <code>CTxMemPool::Check()</code> for more information on what the check does.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_loading_a_previous_mempool"><a class="link" href="#_loading_a_previous_mempool">Loading a previous mempool</a></h5>
<div class="paragraph">
<p>If the node has been run before then it might have some blocks and a mempool to load.
"Step 11: import blocks" of <code>AppInitMain()</code> in <em>init.cpp</em> calls <code>ThreadImport()</code> to load the mempool from disk where it is saved to file <code>mempool.dat</code>:</p>
</div>
<div class="listingblock">
<div class="title">init.cpp#AppInitMain()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    chainman.m_load_block = std::thread(&amp;TraceThread&lt;std::function&lt;void()&gt;&gt;, "loadblk", [=, &amp;chainman, &amp;args] {
        ThreadImport(chainman, vImportFiles, args);
    });</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This is run in its own thread so that (potentially) slow disk I/O has a minimal impact on startup times, and the remainder of startup execution can be continued.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ThreadImport</code> runs a few jobs sequentially:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Optionally perform a reindex</p>
</li>
<li>
<p>Load the block files from disk</p>
</li>
<li>
<p>Check that we are still on the best chain according to the blocks loaded from disk</p>
</li>
<li>
<p>Load the mempool via <code>chainman.ActiveChainstate().LoadMempool(args);</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>validation.cpp#LoadMempool()</code> is an almost mirror of <code>DumpMempool()</code> described in more detail below in <a href="#_mempool_shutdown">Mempool shutdown</a>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read the version and count of serialized transactions to follow</p>
</li>
<li>
<p>Test each tx for expiry before submitting it to MemPoolAccept</p>
</li>
<li>
<p>Read any remaining <code>mapDeltas</code> and <code>unbroadcast_txids</code> from the file and apply them</p>
</li>
</ol>
</div>
<div id="default_mempool_expire" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We test for expiry because it is current default policy not to keep transactions in the mempool longer than 336 hours, i.e. two weeks.<br>
The default value comes from the constant <code>DEFAULT_MEMPOOL_EXPIRE</code> which can be overridden by the user with the <code>-mempoolexpiry</code> option.<br>
Loading (and validating) a mempool of transactions this old is likely a waste of time and resources.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_execution"><a class="link" href="#_runtime_execution">Runtime execution</a></h4>
<div class="paragraph">
<p>While the node is running the mempool is persisted in memory.
By default the mempool is limited to 300MB as specified by <code>DEFAULT_MAX_MEMPOOL_SIZE</code>.
This can be overridden by the program option <code>maxmempoolsize</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#_transaction_format_in_the_mempool">Transaction format in the mempool</a> for more information on what data counts towards this limit, or review the <code>CTxMemPool</code> data members which store current usage metrics e.g. <code>CTxMemPool::cachedInnerUsage</code> and the implementation of e.g. <code>CTxMemPool::DynamicMemoryUsage()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mempool_shutdown"><a class="link" href="#_mempool_shutdown">Mempool shutdown</a></h4>
<div class="paragraph">
<p>When the node is shut down its mempool is (by default) persisted to disk, called from <code>init.cpp#Shutdown()</code>:</p>
</div>
<div class="listingblock">
<div class="title">init.cpp#Shutdown()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    if (node.mempool &amp;&amp; node.mempool-&gt;IsLoaded() &amp;&amp; node.args-&gt;GetArg("-persistmempool", DEFAULT_PERSIST_MEMPOOL)) {
        DumpMempool(*node.mempool);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A pointer to the mempool object is passed to <code>DumpMempool()</code>, which begins by locking the mempool mutex, <code>pool.cs</code>, before a snapshot of the mempool is created using local variables <code>mapDeltas</code>, <code>vinfo</code> and <code>unbroadcast_txids</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>mapDeltas</code> is used by miners to apply (fee) prioritisation to certain transactions when creating new block templates.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>vinfo</code> stores information on each transaction as a vector of <code>CTxMemPoolInfo</code> objects.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">validation.cpp#DumpMempool()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">bool DumpMempool(const CTxMemPool&amp; pool, FopenFn mockable_fopen_function, bool skip_file_commit)
{
    int64_t start = GetTimeMicros();

    std::map&lt;uint256, CAmount&gt; mapDeltas;
    std::vector&lt;TxMempoolInfo&gt; vinfo;
    std::set&lt;uint256&gt; unbroadcast_txids;

    static Mutex dump_mutex;
    LOCK(dump_mutex);

    {
        LOCK(pool.cs);
        for (const auto &amp;i : pool.mapDeltas) {
            mapDeltas[i.first] = i.second;
        }
        vinfo = pool.infoAll();
        unbroadcast_txids = pool.GetUnbroadcastTxs();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next a new (temporary) file is opened and some metadata related to mempool version and size is written to the front.
Afterwards we loop through <code>vinfo</code> writing the transaction, the time it entered the mempool and the fee delta (prioritisation) to the file, before deleting its entry from our <code>mapDeltas</code> mirror.</p>
</div>
<div class="paragraph">
<p>Finally, any remaining info in <code>mapDeltas</code> is appended to the file.
This might include prioritisation information on transactions not in our mempool.</p>
</div>
<div class="listingblock">
<div class="title">validation.cpp#DumpMempool()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    // ...
    try {
        FILE* filestr{mockable_fopen_function(GetDataDir() / "mempool.dat.new", "wb")};
        if (!filestr) {
            return false;
        }

        CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);

        uint64_t version = MEMPOOL_DUMP_VERSION;
        file &lt;&lt; version;

        file &lt;&lt; (uint64_t)vinfo.size();
        for (const auto&amp; i : vinfo) {
            file &lt;&lt; *(i.tx);
            file &lt;&lt; int64_t{count_seconds(i.m_time)};
            file &lt;&lt; int64_t{i.nFeeDelta};
            mapDeltas.erase(i.tx-&gt;GetHash());
        }

        file &lt;&lt; mapDeltas;

        LogPrintf("Writing %d unbroadcast transactions to disk.\n", unbroadcast_txids.size());
        file &lt;&lt; unbroadcast_txids;
    // ...
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>We are able to write (and later read) <code>mapDeltas</code> and <code>unbroadcast_txids</code> to the file only using the <code>&lt;&lt;</code> operator.
This is due to the operator overload on the <code>CAutoFile</code> class found in <em>streams.h</em>:</p>
</div>
<div class="listingblock">
<div class="title">streams.h</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/**
 * map
 */
template&lt;typename Stream, typename K, typename T, typename Pred, typename A&gt;
void Serialize(Stream&amp; os, const std::map&lt;K, T, Pred, A&gt;&amp; m)
{
    WriteCompactSize(os, m.size());
    for (const auto&amp; entry : m)
        Serialize(os, entry);
}

class: CAutoFile
{
public:
    // ...
    template&lt;typename T&gt;
    CAutoFile&amp; operator&lt;&lt;(const T&amp; obj)
    {
        // Serialize to this stream
        if (!file)
            throw std::ios_base::failure("CAutoFile::operator&lt;&lt;: file handle is nullptr");
        ::Serialize(*this, obj);
        return (*this);
    }
    // ...
};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, if writing the elements to the temporary file was successful, we close the file and rename it to <code>mempool.dat</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_addition_to_the_mempool"><a class="link" href="#_addition_to_the_mempool">Addition to the mempool</a></h3>
<div class="paragraph">
<p>Transactions are added to the mempool via <code>addUnchecked()</code> as part of the <code>AcceptToMemoryPool()</code> flow.
See <a href="#_transaction_validation">Transaction validation</a> for more information on how this flow is entered.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The function name <code>addUnchecked</code> specifically refers to the fact that no checks are being performed, so this must not be called until policy checks have passed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This function is called from within <em>validation.cpp</em> (<code>MemPoolAccept::Finalize()</code>) where the appropriate consensus and policy checks <em>have</em> already been performed on the transaction.
The transaction is added to the primary index <code>mapTx</code> before any fee prioritisation ("delta") is applied to it.</p>
</div>
<div class="paragraph">
<p>Next any links to parent transactions are generated by looping through the inputs and mapping the <code>COutPoint</code> of the input to this transaction <code>CTransaction</code> in the <code>mapNextTx</code> map.
Additionally the tx input is added to a set which is used to update parent transactions if they are still in the mempool.</p>
</div>
<div class="paragraph">
<p>After all inputs have been considered, <code>UpdateAncestorsOf()</code> is called which will add this transaction as a descendant to any ancestors in the mempool.
This is followed by <code>UpdateEntryForAncestors()</code> which will re-calculate and apply descendant <code>count</code>, <code>size</code>, <code>fee</code> and <code>sigOpCost</code> of the ancestors with the new descendant being accounted for.</p>
</div>
<div class="paragraph">
<p>Finally update <code>totalTxSize</code> and <code>totalFee</code> (both sum totals of the mempool) to account for this new transaction.</p>
</div>
</div>
<div class="sect2">
<h3 id="_removal_from_the_mempool"><a class="link" href="#_removal_from_the_mempool">Removal from the mempool</a></h3>
<div class="paragraph">
<p>Transactions are removed from the mempool for a number of reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A new block has been connected <code>removeForBlock()</code></p>
</li>
<li>
<p>A re-org is taking place <code>removeForReorg()</code></p>
</li>
<li>
<p>The transaction has <a href="#default_mempool_expire">expired</a> <code>Expire()</code></p>
</li>
<li>
<p>The transaction is being replaced by a higher-fee version <code>MemPoolAccept::Finalize()</code></p>
</li>
<li>
<p>The mempool must be trimmed back down below its maximum size <code>TrimToSize()</code></p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="title">Removal from the mempool</div>
<div class="content">
<pre>flowchart LR
    remove_staged["RemoveStaged()"]
    remove_recursive["removeRecursive()"]
    remove_reorg["removeForReorg()"]
    remove_block["removeForBlock()"]
    expire["Expire()"]
    trim_to_size["TrimToSize()"]
    finalize["MemPoolAccept::Finalize()"]
    calculate_ancestors["CalculateMemPoolAncestors()"]
    update_ancestors["UpdateAncestorsOf()"]
    update_children["UpdateChildrenForRemoval()"]
    remove_unchecked["removeUnchecked()"]

    remove_recursive --&gt; remove_staged
    remove_reorg --&gt; remove_staged
    remove_block --&gt; remove_staged
    expire --&gt; remove_staged
    trim_to_size --&gt; remove_staged
    finalize ---&gt; remove_staged

    remove_staged --&gt; update_for_remove

    update_for_remove --&gt; remove_unchecked

    subgraph validation.cpp
        finalize
    end

    subgraph txmempool.cpp
        remove_recursive
        remove_reorg
        remove_block
        expire
        trim_to_size
    end

    subgraph update_for_remove["UpdateForRemoveFromMempool()"]
        calculate_ancestors --&gt; update_ancestors --&gt; update_children
    end</pre>
</div>
</div>
<div class="paragraph">
<p><code>RemoveStaged()</code> takes a set of transactions referenced by their txid along with their <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/txmempool.h#L347-L354">removal reason</a>, and removes them sequentially.
It does this by first updating the ancestors of the transaction, followed by the descendants.
After calculating and updating related transaction information it calls <code>removeUnchecked()</code> which actions the removal from the mempool.</p>
</div>
<div class="paragraph">
<p><code>removeUnchecked()</code> starts by notifying the validation interface that a transaction has been removed from the mempool for all reasons other than a new block arriving, as there is a different <code>BlockConnected</code> signal which can be used for that.</p>
</div>
<div class="paragraph">
<p>Next it loops over the <code>txin</code>s of the transaction, and removes each <code>prevout</code> of each <code>txin</code> from the <code>mapNextTx</code> map.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>mapNextTx</code> is used to map a <code>COutPoint</code> to the unconfirmed transaction spending it.
This way there is a quick lookup available to check that a new transaction being added to the mempool is not trying to double spend a UTXO.</p>
</div>
<div class="paragraph">
<p>You can see the map being created as new transactions are learned about in <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/txmempool.cpp#L510"><code>addUnchecked()</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the node has upgraded to SegWit the <code>vTxHashes</code> vector, which stores <code>wtxid</code>s is then updated.
As <code>vTxHashes</code> stores the <code>wtxid</code>s in random order, first we move the transaction&#8217;s entry to the back, and then pop it off, resizing the vector if needed.</p>
</div>
<div class="paragraph">
<p>Finally, as with <code>addUnchecked()</code> we update the mempool sum totals for <code>txSize</code> and <code>fee</code> and erase the transaction from the primary mempool index <code>mapTx</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Both adding and removing transactions increment the <code>mempool_seqence</code> counter.
This is used by the <code>getrawmempool</code> RPC (via <code>MempoolToJSON</code>) in tracking the number of mempool database transaction operations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mempool_unbroadcast_set"><a class="link" href="#_mempool_unbroadcast_set">Mempool unbroadcast set</a></h3>
<div class="paragraph">
<p>The mempool contains an "unbroadcast" set called <code>m_unbroadcast_txids</code>.
As the name implies this stores the txids of transactions which are in our mempool but have not been verified as broadcast to the wider P2P network.
This might occur for example if a transaction is submitted locally (e.g. from the wallet or RPC), but we are not yet connected to any peers.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When a transaction is submitted to the network via <code>BroadcastTransaction()</code> it is added to the unbroadcast set in the mempool, before <code>PeerManager</code> calls <code>RelayTransaction()</code> to attempt initial broadcast.</p>
</li>
<li>
<p>When a transaction is heard about from the P2P network (via <code>getdata</code> in response to an <code>INV</code>), the transaction will be <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/net_processing.cpp#L2022">removed</a> from the unbroadcast set.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Transactions are also removed from the set on reorgs, new blocks arriving or if they&#8217;ve "expired" via <code>RemoveStaged()</code>
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>PeerManager</code> schedules <code>ReattemptInitialBroadcast()</code> to be run every 10 minutes.
This function loops over the unbroadcast set and either attempts rebroadcast or removes the transaction from the unbroadcast set if it is no longer in our mempool.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
amiti wrote a <a href="https://gist.github.com/amitiuttarwar/b592ee410e1f02ac0d44fcbed4621dba" target="_blank" rel="noopener">gist</a> on her proposal to improve rebroadcast logic in Bitcoin Core.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_format_in_the_mempool"><a class="link" href="#_transaction_format_in_the_mempool">Transaction format in the mempool</a></h3>
<div class="paragraph">
<p>A <code>CTXMemPoolEntry</code> describes a mempool entry (i.e. transaction) in the mempool.
It stores not only transaction information, but also pre-computed information about ancestors.</p>
</div>
<div class="listingblock">
<div class="title">txmempool.h</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">class CTxMemPoolEntry
{
public:
    typedef std::reference_wrapper&lt;const CTxMemPoolEntry&gt; CTxMemPoolEntryRef;
    // two aliases, should the types ever diverge
    typedef std::set&lt;CTxMemPoolEntryRef, CompareIteratorByHash&gt; Parents;
    typedef std::set&lt;CTxMemPoolEntryRef, CompareIteratorByHash&gt; Children;

private:
    const CTransactionRef tx;
    mutable Parents m_parents;
    mutable Children m_children;
    const CAmount nFee;             //!&lt; Cached to avoid expensive parent-transaction lookups
    const size_t nTxWeight;         //!&lt; ... and avoid recomputing tx weight (also used for GetTxSize())
    const size_t nUsageSize;        //!&lt; ... and total memory usage
    const int64_t nTime;            //!&lt; Local time when entering the mempool
    const unsigned int entryHeight; //!&lt; Chain height when entering the mempool
    const bool spendsCoinbase;      //!&lt; keep track of transactions that spend a coinbase
    const int64_t sigOpCost;        //!&lt; Total sigop cost
    int64_t feeDelta;          //!&lt; Used for determining the priority of the transaction for mining in a block
    LockPoints lockPoints;     //!&lt; Track the height and time at which tx was final

    // Information about descendants of this transaction that are in the
    // mempool; if we remove this transaction we must remove all of these
    // descendants as well.
    uint64_t nCountWithDescendants;  //!&lt; number of descendant transactions
    uint64_t nSizeWithDescendants;   //!&lt; ... and size
    CAmount nModFeesWithDescendants; //!&lt; ... and total fees (all including us)

    // Analogous statistics for ancestor transactions
    uint64_t nCountWithAncestors;
    uint64_t nSizeWithAncestors;
    CAmount nModFeesWithAncestors;
    int64_t nSigOpCostWithAncestors;

    // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advantage to having pre-computed data on descendants and ancestors stored with each transaction in the mempool is that operations involving adding and removing transactions can be performed faster.
When a transaction is added to the mempool we must update the descendant data for all ancestor <code>CTxMemPoolEntry</code>'s.
Conversely if a transaction is removed from the mempool, we must also remove all of its descendants.
A particular area where speed can be critical is in block template assembly.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Some of this extra transaction metadata counts towards the mempool&#8217;s maximum size, therefore a default mempool of 300MB will contain less than 300MB of serialized transactions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_mapping_transactions_in_the_mempool"><a class="link" href="#_mapping_transactions_in_the_mempool">Mapping transactions in the mempool</a></h3>
<div class="paragraph">
<p>A lot of how fee-maximizing block templates can be swiftly generated from chains of potentially-complex interlinked and dependant transactions comes down to <code>CTxMemPool</code>'s <code>boost::multi_index</code> <code>mapTx</code>, which is able to natively store transactions in an index against multiple criteria as described in the <a href="https://www.boost.org/doc/libs/1_68_0/libs/multi_index/doc/index.html" target="_blank" rel="noopener">documentation</a> and code comments:</p>
</div>
<div class="listingblock">
<div class="title">txmempool.h#CTxMemPool</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">/*
 * mapTx is a boost::multi_index that sorts the mempool on 5 criteria:
 * - transaction hash (txid)
 * - witness-transaction hash (wtxid)
 * - descendant feerate [we use max(feerate of tx, feerate of tx with all descendants)]
 * - time in mempool
 * - ancestor feerate [we use min(feerate of tx, feerate of tx with all unconfirmed ancestors)]
 */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The index has 5 sort fields: the default, and tagged fields <code>index_by_wtxid</code>, <code>descendant_score</code>, <code>entry_time</code> and <code>ancestor_score</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The default, and untagged, sort field of the index, which is using the <a href="https://www.boost.org/doc/libs/1_62_0/libs/multi_index/doc/reference/hash_indices.html#unique_non_unique" target="_blank" rel="noopener">hashed_unique</a> sort; hashing the <code>txid</code> using Bitcoin Core&#8217;s implementation of the SipHash hasher for txids.<br>
This is used when adding and removing transactions from the mempool, requesting and looking up mempool transactions (by txid) and checking whether RBF is enabled.</p>
</li>
<li>
<p><code>index_by_wtxid</code> is used when checking whether transactions received over the P2P network already exist in the mempool (via the <code>exists()</code> function).</p>
</li>
<li>
<p><code>descendant_score</code> is used when trying to trim the mempool to size (via <code>TrimToSize()</code>).<br>
In this case we want to keep parent (ancestor) transactions in the mempool who have high fee-paying children (descendants).</p>
</li>
<li>
<p><code>entry_time</code> is used to calculate when transactions in the mempool should expire.</p>
</li>
<li>
<p><code>ancestor_score</code> is used to create new block templates by selecting the most valuable effective-feerate transaction chains.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_package_relay"><a class="link" href="#_package_relay">Package relay</a></h3>
<div class="paragraph">
<p><a href="https://bitcoinops.org/en/topics/package-relay/" target="_blank" rel="noopener">Package Relay</a> is a long-discussed concept and, at the time of writing, is a work in progress in Bitcoin Core.
A significant portion of the project involves changes to mempool validation, which glozow describes in her gist <a href="https://gist.github.com/glozow/dc4e9d5c5b14ade7cdfac40f43adb18a" target="_blank" rel="noopener">Package mempool accept</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/20833" target="_blank" rel="noopener">PR#20833</a> added the ability for mempool validation to assess a set of dependent transactions and enabled the <code>testmempoolaccept</code> RPC to support multiple transactions.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/21800" target="_blank" rel="noopener">PR#21800</a> added the ability to analyse and limit the ancestor and descendant sets of packages in relation to the mempool.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/bitcoin/bitcoin/pull/22674" target="_blank" rel="noopener">PR#22674</a> defined child-with-unconfirmed-parents packages and enabled submission of such packages to the mempool.</p>
</div>
<div class="paragraph">
<p>These PRs were also accompanied by several refactoring efforts:
<a href="https://github.com/bitcoin/bitcoin/pull/21062" target="_blank" rel="noopener">PR#21062</a>,
<a href="https://github.com/bitcoin/bitcoin/pull/22796" target="_blank" rel="noopener">PR#22796</a>,
<a href="https://github.com/bitcoin/bitcoin/pull/22675" target="_blank" rel="noopener">PR#22675</a>,
<a href="https://github.com/bitcoin/bitcoin/pull/22855" target="_blank" rel="noopener">PR#22855</a>,
<a href="https://github.com/bitcoin/bitcoin/pull/23381" target="_blank" rel="noopener">PR#23381</a>.</p>
</div>
<div class="paragraph">
<p>The document <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/policy/packages.md" target="_blank" rel="noopener">doc/policy/packages.md</a> contains current information on the stated package acceptance rules.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pinning_attacks"><a class="link" href="#_pinning_attacks">Pinning attacks</a></h3>
<div class="paragraph">
<p>glozow describes pinning attacks in her document <a href="https://github.com/glozow/bitcoin-notes/blob/master/pinning.md" target="_blank" rel="noopener">"Pinning zoo"</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_script"><a class="link" href="#_script">Script</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v23.0" target="_blank" rel="noopener">v23.0</a>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_script_origins"><a class="link" href="#_script_origins">Script origins</a></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>New scripts are created when creating a new address.</p>
</li>
<li>
<p>Scripts can be learned about when we receive a new transaction from the P2P network or from a newly-connected block.</p>
</li>
<li>
<p>With Taproot there may be scripts in alternative Tapscript execution paths which nobody on the network will ever learn about.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_scripts_in_bitcoin_core"><a class="link" href="#_scripts_in_bitcoin_core">Scripts in Bitcoin Core</a></h3>
<div class="paragraph">
<p>The primary script objects are found in <em>script.h</em>.
An enum over all the permitted OPCODES, <code>enum opcodetype</code>.
The <code>CScriptNum</code> class which handles arithmetic operations on integer <code>CScriptNum</code>s, whether from a loose <code>int_64t</code> or from a second <code>CScriptNum</code> object.
The <code>CScript</code> class which supports serializing data into scripts, along with many helper functions such as returning the script type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_validating_scripts"><a class="link" href="#_validating_scripts">Validating scripts</a></h3>
<div class="paragraph">
<p>For some additional context on how scripts are validated in Bitcoin see <a href="#_executing_scripts">Executing scripts</a> in the Appendix.</p>
</div>
<div class="paragraph">
<p>Transactions contain a vector of inputs (<code>CTxIn</code>) and vector of outputs (<code>CTxOut</code>), along with other required data.</p>
</div>
<div class="paragraph">
<p>Each <code>CTxIn</code> contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>COutPoint prevout;</code></p>
</li>
<li>
<p><code>CScript scriptSig;</code></p>
</li>
<li>
<p><code>uint32_t nSequence;</code></p>
</li>
<li>
<p><code>CScriptWitness scriptWitness;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each <code>CTxOut</code> contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CAmount nValue;</code></p>
</li>
<li>
<p><code>CScript scriptPubKey;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a new transaction is learned about from the wallet or P2P network (as a TX INV ) it is passed to <a href="#_single_transactions"><code>AcceptToMemoryPool()</code></a> which will run the various script checks.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Transactions learned about directly in blocks have their scripts validated via <code>ActivateBestChainStep()</code> -&#8594; <code>ConnectBlock()</code> -&#8594; <code>ConnectTip()</code> -&#8594; <code>CChainState::ConnectBlock()</code> (<a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L1924-L2232" target="_blank" rel="noopener">link</a>), which will end up calling <code>CheckTxInputs()</code> and <code>CheckInputScripts()</code>, as described in the subsequent section on <a href="#_policyscriptchecks_script_checks">PolicyScriptChecks</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_precheck_script_checks"><a class="link" href="#_precheck_script_checks">PreCheck script checks</a></h4>
<div class="paragraph">
<p><code>PreChecks()</code> performs some structural checks inside of <code>CheckTransaction()</code> before passing the transaction to <code>IsStandard()</code>.
In here the transaction weight is checked, along with the <code>scriptSig</code> size of every input and the type of every output.
Any failures are written back into the <code>reason</code> string which will be propagated up in the case the function returns <code>false</code>.</p>
</div>
<div class="paragraph">
<p>The next script checks come after the mempool is consulted to test for conflicts, and inputs are checked against our <code>CoinsCache</code> (UTXO set).
<code>AreInputsStandard()</code> will take the transaction and access each <code>vin</code> from a copy of our UTXO set <code>CCoinsViewCache</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
We use a cached version of <code>CCoinsView</code> here because although we want to introspect the transaction by doing a mock evaluation of the script, we do not want to modify the UTXO set yet, nor mark any coins as <code>DIRTY</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The type of script can be evaluated using the <em>script/standard.cpp#Solver()</em> function, which will return the script type as a member of the <code>TxOutType</code> <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/standard.h#L59-L71" target="_blank" rel="noopener">enum</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>Solver()</code> takes a scriptPubkey as a <code>CScript</code> and a vector of <code>unsigned_char</code> vectors called <code>vSolutionsRet</code>.
It will attempt to evaluate and return the script type, along with any parsed pubKeys or pubKeyHashes in the <code>vSolutionsRet</code> vector.</p>
</div>
<div class="paragraph">
<p>For example, if the script type is P2SH it will execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    // Shortcut for pay-to-script-hash, which are more constrained than the other types:
    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL
    if (scriptPubKey.IsPayToScriptHash())
    {
        std::vector&lt;unsigned char&gt; hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);
        vSolutionsRet.push_back(hashBytes);
        return TxoutType::SCRIPTHASH;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, simply reading the scriptHash into the <code>vSolutionsRet</code> vector before returning with the type.</p>
</div>
<div class="paragraph">
<p>For SegWit inputs the witness program is returned, for PayToPubKey (which although basically unused now is still supported) the pubKey is returned, and for P2PKH the pubKeyHash is returned.
The MultiSig case returns the number of required signatures, all the pubKeys and, the total number of keys.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If the input is <code>NONSTANDARD</code> or <code>WITNESS_UNKNOWN</code> then we can return early with <code>false</code>.
If the transaction is of type <code>SCRIPTHASH</code> (P2SH) then we want to check that the <code>scriptSig</code> does not have extra data included which is not relevant to the <code>scriptPubKey</code>, and that the <code>SigOpCount</code> for the input obeys the specific P2SH limits.
To do this we perform a mini evaluation of the script by passing in the <code>SCRIPT_VERIFY_NONE</code> <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.h#L44" target="_blank" rel="noopener">flag</a>, which instructs the interpreter not to verify operations guarded by flags.</p>
</div>
<div class="paragraph">
<p>Looking into <code>EvalScript()</code> itself we can see which verification operations are going to be skipped by using this flag; in the positions we see the flag being tested e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">case OP_CHECKLOCKTIMEVERIFY:
{
    if (!(flags &amp; SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
        // not enabled; treat as a NOP2
        break;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <code>SCRIPT_VERIFY_NONE</code> set this will skip <code>fRequireMinimal</code>, <code>OP_CHECKLOCKTIMEVERIFY</code>, <code>OP_CHECKSEQUENCEVERIFY</code>, discouragement of the upgradable <code>NOP</code>s 1; 4; 5; 6; 7; 8; 9; 10; <code>OP_CHECKSIG</code> and <code>OP_CHECKSIGVERIFY</code>.
This makes the evaluation much cheaper by avoiding expensive signature verification, whilst still allowing quick testing that stack will not be empty (if signature verification succeeded), and that <code>MAX_P2SH_SIGOPS</code> count is not exceeded.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Avoiding expensive operations, e.g. full script evaluation, for as long as possible, whilst also avoiding repeating work, is a key anti-DoS consideration of transaction and script validation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After <code>AreInputsStandard()</code> has returned, if the transaction is SegWit the witnesses are checked by <code>IsWitnessStandard()</code>.
This functions similarly to <code>AreInputsStandard()</code> is that it will loop over every <code>vin</code> to the transaction and access the coin using the same <code>CCoinsViewCache</code> as used previously.</p>
</div>
<div class="paragraph">
<p>The input&#8217;s script <code>prevScript</code> is initialised to the input&#8217;s scriptPubKey, but then a check is done to see if the input is of P2SH type (corresponding to a P2SH-wrapped address), again performing the mock script validation with the <code>SCRIPT_VERIFY_NONE</code> flag applied.
If it is found to be P2SH-wrapped then the input&#8217;s script is set to the <code>scriptSig</code> as converted into a stack.</p>
</div>
<div class="paragraph">
<p>With the input script set witness evaluation can begin.
First the script is checked to be a valid witness program, i.e. a single byte <code>PUSH</code> opcode, followed by a sized data push.
This is using <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/script.cpp#L220-L234" target="_blank" rel="noopener"><code>CScript::IsWitnessProgram()</code></a>.</p>
</div>
<div class="paragraph">
<p>Segwit V0 or V1 script size limits (as appropriate) are checked before returning <code>true</code>.
The final script checks inside of <code>PreChecks()</code> are to get the full transaction sigOp cost, which is a total of the legacy, P2SH and Witness sigOps.</p>
</div>
</div>
<div class="sect3">
<h4 id="_policyscriptchecks_script_checks"><a class="link" href="#_policyscriptchecks_script_checks">PolicyScriptChecks script checks</a></h4>
<div class="paragraph">
<p>This block is going to re-use the same <code>Workspace</code> as <code>PreChecks</code>, but at this stage doesn&#8217;t re-use any cached <code>PreComputedTransactionData</code>.</p>
</div>
<div class="paragraph">
<p>The main check block is shown below:</p>
</div>
<div class="listingblock">
<div class="title"><em>validation.cpp:982</em></div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    // Check input scripts and signatures.
    // This is done last to help prevent CPU exhaustion denial-of-service attacks.
    if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, ws.m_precomputed_txdata)) {
        // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we
        // need to turn both off, and compare against just turning off CLEANSTACK
        // to see if the failure is specifically due to witness validation.
        TxValidationState state_dummy; // Want reported failures to be from first CheckInputScripts
        if (!tx.HasWitness() &amp;&amp; CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags &amp; ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, ws.m_precomputed_txdata) &amp;&amp;
                !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags &amp; ~SCRIPT_VERIFY_CLEANSTACK, true, false, ws.m_precomputed_txdata)) {
            // Only the witness is missing, so the transaction itself may be fine.
            state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED,
                    state.GetRejectReason(), state.GetDebugMessage());
        }
        return false; // state filled in by CheckInputScripts
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This performs validation of the input scripts using our "policy flags", where policy flags refer to a <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/policy/policy.h#L60-L79" target="_blank" rel="noopener">list</a> of script verification <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.h#L38-L147" target="_blank" rel="noopener">flags</a> that form "standard transactions", i.e. those transactions that will be relayed around the network by other nodes running the same policies.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Notice that <code>CheckInputScripts()</code> is run up to 3 times.
The first run will check all the inputs using the whole <code>STANDARD_SCRIPT_VERIFY_FLAGS</code> and <code>cacheSigStore</code> set to <code>true</code>, so that we cache expensive signature verification results.
If this returns <code>true</code> then <code>PolicyScriptChecks()</code> is complete and will also return <code>true</code> to the caller.</p>
</div>
<div class="paragraph">
<p>If this first check fails we then check to see if it is specifically a missing witness which is causing the failure.
In order to do this we will execute two more runs, one with <code>SCRIPT_VERIFY_WITNESS</code> and <code>SCRIPT_VERIFY_CLEANSTACK</code> disabled which should pass, and a second in series with only <code>SCRIPT_VERIFY_CLEANSTACK</code> disabled which should fail.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>From this call-site inside MempoolAccept <code>CheckInputScripts()</code> is called with <code>cacheSigStore</code> set to <code>true</code>, and <code>cacheFullScriptStore</code> set to <code>false</code>.
This means that we will keep signature verifications in the <code>CSignatureCache</code> (named <code>signatureCache</code>).
Full scripts will not be cached.
The two caches are setup as <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1144-L1145" target="_blank" rel="noopener">part</a> of <code>AppInitMain()</code>.</p>
</div>
<div class="paragraph">
<p><code>CheckInputScripts()</code> begins by checking that we have not already executed this input script and stored it in the global Cuckoo Cache <code>g_scriptExecutionCacheHasher</code>, if we have, then this means the previous execution already succeeded so we can return <code>true</code> early.
Next check that we have all our input coins loaded from the cached copy of the UTXO set <code>CCoinsViewCache</code>.</p>
</div>
<div class="paragraph">
<p>Now script execution begins by looping over each input and storing the input and transaction in a <code>CScriptCheck</code> closure (<code>check</code>) for later evaluation.
Calling the <code>()</code> operator on the closure will <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L1593-L1597" target="_blank" rel="noopener">initialize</a> a new <code>CScript</code> and <code>CScriptWitness</code> for the evaluation, and execute <code>VerifyScript()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can see the <code>cacheSigStore</code> boolean being propagated to the <code>CachingSignatureTransactionChecker</code> signalling that we should cache these signature evalations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Execution of <code>VerifyScript</code> is described below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_verifyscript"><a class="link" href="#_verifyscript">VerifyScript</a></h4>
<div class="paragraph">
<p><code>Verifyscript()</code>s function is to very a single scriptSig (SS) against a scriptPubKey (SPK) and return a boolean <code>true</code> or <code>false</code>, returning a more specific error description via the passed in <code>ScriptError</code>.
Historically (in Bitcoin versions &lt; 0.3.5) this was done by concatenating the SS and the SPK and evaluating as one, however this meant that malicious actors could leave arbitrary extra objects on the stack, ultimately resulting in being able to spend coins using any scripts with what should have been an invalid SS.
Therefore now evaluation takes place in two stages, first the SS, who&#8217;s pre-populated <code>stack</code> is then passed in as an argument to SPK evaluation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The mechanics of <code>EvalScript()</code> are shown in the section <a href="#_evalscript">EvalScript</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If both calls to <code>EvalScript</code> succeed, then any witness program is verified, followed by P2SH scripts.
Notice here how in each of these cases the stack is trimmed to size <code>1</code> at the end of evaluation, because in both cases extra elements would ordinarily remain on the stack (P2SH and witness inputs).
If the evaluation succeeds then the <code>CLEANSTACK</code> rule is enforced <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.cpp#L2067-L2078" target="_blank" rel="noopener">afterwards</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_evalscript"><a class="link" href="#_evalscript">EvalScript</a></h4>
<div class="paragraph">
<p><code>EvalScript()</code> handles the Forth-like script interpretation itself.
It takes in a stack, script, interpretation flags, a <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.h#L243-L267" target="_blank" rel="noopener">signature checker</a>, a signature version and a <code>ScriptExecutionData</code> struct.</p>
</div>
<div class="paragraph">
<p>After checking that it&#8217;s not about to evaluate a Taproot key-path spend (<code>SIGVERSION::TAPROOT</code>), which has no script to execute, we initialize some iterators on the script, along with variables to represent the current opcode, the push value, the condition stack and the altstack.
The <a href="https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.cpp#L282-L343" target="_blank" rel="noopener">condition stack</a> is used to help evaluation of IF/ELSE clauses and the altstack is used to push and pop items from the main stack during execution (using <code>OP_TOALTSTACK</code> and <code>OP_FROMALTSTACK</code>).</p>
</div>
<div class="paragraph">
<p>Next we check script size is less that <code>MAX_SCRIPT_SIZE</code> (10KB).
Although total serialized transaction size, and SigOpCount has been checked previously, this is the first time the size of the scripts themselves are checked.</p>
</div>
<div class="paragraph">
<p>Then comes the main evaluation for loop.
Whilst many conditions are checked, and specific invalidity errors returned, there is also the possibility of other un-tested errors occurring during evaluation, and so the loop is enclosed by a try-except block which will catch these errors, instead of causing a program crash.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Script execution is effectively executing uncontrolled, 3rd party data.
If a malicious actor found a way to purposefully provoke an unhandled error during evaluation, without the try-catch block, they would be able to effectively crash any node on the network of their choosing by sending it the malicious script.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main loop is simple conceptually:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read an instruction using the <code>CScript::GetOp()</code> method.
This will read an <code>opcodetype</code> into the <code>opcode</code> variable, and the raw instruction into the <code>vchPushValue</code> variable.</p>
</li>
<li>
<p>Test for the script element size, number of script ops, and whether this is a disabled opcode.</p>
</li>
<li>
<p>Enter a switch on <code>opcode</code> to perform specific evaluation according to the operation specified.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_signing_a_transaction"><a class="link" href="#_signing_a_transaction">Signing a transaction</a></h3>
<div class="paragraph">
<p><code>script/sign.cpp#SignTransaction()</code> will sign a transaction one input at a time, by looping through the <code>vin</code>s of the <code>CMutableTransaction</code> it has been passed.</p>
</div>
<div class="paragraph">
<p>The critical section of the <code>SignTransaction()</code> loop is shown below:</p>
</div>
<div class="listingblock">
<div class="title">src/script/sign.cpp#SignTransaction()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    for (unsigned int i = 0; i &lt; mtx.vin.size(); i++) {
        CTxIn&amp; txin = mtx.vin[i];
        auto coin = coins.find(txin.prevout);
        if (coin == coins.end() || coin-&gt;second.IsSpent()) {
            input_errors[i] = "Input not found or already spent";
            continue;
        }
        const CScript&amp; prevPubKey = coin-&gt;second.out.scriptPubKey;
        const CAmount&amp; amount = coin-&gt;second.out.nValue;

        SignatureData sigdata = DataFromTransaction(mtx, i, coin-&gt;second.out);
        // Only sign SIGHASH_SINGLE if there's a corresponding output:
        if (!fHashSingle || (i &lt; mtx.vout.size())) {
            ProduceSignature(*keystore, MutableTransactionSignatureCreator(&amp;mtx, i, amount, nHashType), prevPubKey, sigdata);
        }

        UpdateInput(txin, sigdata);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Pubkey and amount for each coin are retrieved, along with signature data for the coin.
<code>DataFromTransaction()</code> returns all the information needed to produce a signature for that coin as a <code>SignatureData</code> struct:</p>
</div>
<div class="listingblock">
<div class="title">src/script/sign.h#SignatureData</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">// This struct contains information from a transaction input and also contains signatures for that input.
// The information contained here can be used to create a signature and is also filled by ProduceSignature
// in order to construct final scriptSigs and scriptWitnesses.
struct SignatureData {
    bool complete = false; ///&lt; Stores whether the scriptSig and scriptWitness are complete
    bool witness = false; ///&lt; Stores whether the input this SigData corresponds to is a witness input
    CScript scriptSig; ///&lt; The scriptSig of an input. Contains complete signatures or the traditional partial signatures format
    CScript redeem_script; ///&lt; The redeemScript (if any) for the input
    CScript witness_script; ///&lt; The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.
    CScriptWitness scriptWitness; ///&lt; The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.
    std::map&lt;CKeyID, SigPair&gt; signatures; ///&lt; BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.
    std::map&lt;CKeyID, std::pair&lt;CPubKey, KeyOriginInfo&gt;&gt; misc_pubkeys;
    std::vector&lt;CKeyID&gt; missing_pubkeys; ///&lt; KeyIDs of pubkeys which could not be found
    std::vector&lt;CKeyID&gt; missing_sigs; ///&lt; KeyIDs of pubkeys for signatures which could not be found
    uint160 missing_redeem_script; ///&lt; ScriptID of the missing redeemScript (if any)
    uint256 missing_witness_script; ///&lt; SHA256 of the missing witnessScript (if any)

    SignatureData() {}
    explicit SignatureData(const CScript&amp; script) : scriptSig(script) {}
    void MergeSignatureData(SignatureData sigdata);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the signing <code>SigningProvider</code>, <code>scriptPubKey</code> and <code>sigdata</code> we are able to call <code>script/sign.cpp#ProduceSignature()</code> for signing on each individual input.
Inputs by default will signed with a sighash of <code>SIGHASH_ALL</code>, but this can be re-configured as appropriate.</p>
</div>
<div class="sect3">
<h4 id="_producing_a_signature"><a class="link" href="#_producing_a_signature">Producing a signature</a></h4>
<div class="paragraph">
<p>Taking a look inside <code>ProduceSignature()</code> we can see how this works.</p>
</div>
<div class="listingblock">
<div class="title">src/script/sign.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">bool ProduceSignature(const SigningProvider&amp; provider, const BaseSignatureCreator&amp; creator, const CScript&amp; fromPubKey, SignatureData&amp; sigdata)
{
    if (sigdata.complete) return true;

    std::vector&lt;valtype&gt; result;
    TxoutType whichType;
    bool solved = SignStep(provider, creator, fromPubKey, result, whichType, SigVersion::BASE, sigdata);
    bool P2SH = false;
    CScript subscript;
    sigdata.scriptWitness.stack.clear();

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function performs some initialisations before calling <code>script/sign.cpp#SignStep()</code> for the first time, with the <code>SigVersion</code> <code>SIGVERSION::BASE</code>.
<code>SignStep()</code> in turn calls <code>Solver()</code>, which is a function designed to detect the script type encoding of the <code>scriptPubKey</code>, and then return the detected type along with the parsed <code>scriptPubKey</code>s/hashes.</p>
</div>
<div class="paragraph">
<p>If it is successful, <code>SignStep</code> continues by switching over the script type and, depending on the script type, calling the required signing operation and pushing the required elements onto the <code>sigdata</code> variable.</p>
</div>
<div class="listingblock">
<div class="title">script/sign.cpp</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">static bool SignStep(const SigningProvider&amp; provider, const BaseSignatureCreator&amp; creator, const CScript&amp; scriptPubKey,
                     std::vector&lt;valtype&gt;&amp; ret, TxoutType&amp; whichTypeRet, SigVersion sigversion, SignatureData&amp; sigdata)
{
    // ...
    whichTypeRet = Solver(scriptPubKey, vSolutions);

    switch (whichTypeRet) {
    case TxoutType::NONSTANDARD:
    case TxoutType::NULL_DATA:
    case TxoutType::WITNESS_UNKNOWN:
    case TxoutType::WITNESS_V1_TAPROOT:
        // ...
    case TxoutType::PUBKEY:
        // ...
    case TxoutType::PUBKEYHASH:
        // ...
    case TxoutType::SCRIPTHASH:
        // ...
    case TxoutType::MULTISIG:
        // ...
    case TxoutType::WITNESS_V0_KEYHASH:
        // ...
    case TxoutType::WITNESS_V0_SCRIPTHASH:
        // ...
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once <code>SignStep()</code> returns to <code>ProduceSignature()</code>, a second switch takes place.
If we are trying to produce a signature for P2SH, P2WPKH or P2WSH then the first pass from <code>SignStep()</code> will have been enough to detect the <code>TxOutType</code> and assemble the (redeem/witness) scripts, but not yet generate the entire signature in required format.
In order to get this signature, <code>SignStep()</code> is called again, this time with the assembled redeem/witness script and the appropriate <code>TxOutType</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This recursion makes sense if you consider that, in order to sign for these script-encumbered inputs, we don&#8217;t want to sign for the <code>scriptPubKey</code> that we are starting with but for the {redeem|witness} script instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can see this switch in <code>ProduceSignature()</code>:</p>
</div>
<div class="listingblock">
<div class="title">src/script/sign.cpp#ProduceSignature()</div>
<div class="content">
<pre class="pygments highlight nowrap"><code data-lang="cpp">    if (solved &amp;&amp; whichType == TxoutType::SCRIPTHASH)
    {
        // Solver returns the subscript that needs to be evaluated;
        // the final scriptSig is the signatures from that
        // and then the serialized subscript:
        subscript = CScript(result[0].begin(), result[0].end());
        sigdata.redeem_script = subscript;
        solved = solved &amp;&amp; SignStep(provider, creator, subscript, result, whichType, SigVersion::BASE, sigdata) &amp;&amp; whichType != TxoutType::SCRIPTHASH;
        P2SH = true;
    }

    if (solved &amp;&amp; whichType == TxoutType::WITNESS_V0_KEYHASH)
    {
        CScript witnessscript;
        // This puts the parsed pubkeys from the first pass into the witness script
        witnessscript &lt;&lt; OP_DUP &lt;&lt; OP_HASH160 &lt;&lt; ToByteVector(result[0]) &lt;&lt; OP_EQUALVERIFY &lt;&lt; OP_CHECKSIG;
        TxoutType subType;
        solved = solved &amp;&amp; SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata);
        sigdata.scriptWitness.stack = result;
        sigdata.witness = true;
        result.clear();
    }
    else if (solved &amp;&amp; whichType == TxoutType::WITNESS_V0_SCRIPTHASH)
    {
        CScript witnessscript(result[0].begin(), result[0].end());
        sigdata.witness_script = witnessscript;
        TxoutType subType;
        solved = solved &amp;&amp; SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata) &amp;&amp; subType != TxoutType::SCRIPTHASH &amp;&amp; subType != TxoutType::WITNESS_V0_SCRIPTHASH &amp;&amp; subType != TxoutType::WITNESS_V0_KEYHASH;
        result.push_back(std::vector&lt;unsigned char&gt;(witnessscript.begin(), witnessscript.end()));
        sigdata.scriptWitness.stack = result;
        sigdata.witness = true;
        result.clear();
    } else if (solved &amp;&amp; whichType == TxoutType::WITNESS_UNKNOWN) {
        sigdata.witness = true;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, if all went well the signature is checked with <a href="#_verifyscript"><code>VerifyScript()</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_signature"><a class="link" href="#_creating_a_signature">Creating a signature</a></h4>
<div class="paragraph">
<p>TODO: dig into <code>CreateSig()</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_bitcoin_script_from_the_command_line"><a class="link" href="#_working_with_bitcoin_script_from_the_command_line">Working with bitcoin script from the command line</a></h3>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Blockchain Commons contains guides related to Bitcoin Script including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/09_1_Understanding_the_Foundation_of_Transactions.md" target="_blank" rel="noopener">Accessing scripts from transactions</a> with <code>bitcoin-cli</code></p>
</li>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/09_2_Running_a_Bitcoin_Script.md" target="_blank" rel="noopener">How scripts are evaluated</a></p>
</li>
<li>
<p><a href="https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/09_3_Testing_a_Bitcoin_Script.md" target="_blank" rel="noopener">Testing bitcoin scripts</a> using <code>btcdeb</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_appendix"><a class="link" href="#_appendix">Appendix</a></h3>
<div class="sect3">
<h4 id="_executing_scripts"><a class="link" href="#_executing_scripts">Executing scripts</a></h4>
<div class="paragraph">
<p>Bitcoin differs from most other cryptocurrencies by not including the script with the unspent transaction output on the blockchain, only the scriptPubKey is publicly viewable until spending time.
The practical effects of this are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Users wishing to sign transactions which are locked using locking scripts require <strong>two</strong> pieces of information:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The relevant private key(s)</p>
</li>
<li>
<p>The <code>redeemScript</code>, i.e. the contract of the script itself.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Scripts are executed by first evaluating the unlocking script, then evaluating the locking script on the same stack.
If both of these steps result in a <code>1</code> (or any other non-zero value) being the only item on the stack, the script is verified as <code>true</code>.</p>
</div>
<div class="paragraph">
<p>TODO: Not true exactly:
<a href="https://bitcoin.stackexchange.com/questions/112439/how-can-the-genesis-block-contain-arbitrary-data-on-it-if-the-script-is-invalid" class="bare">https://bitcoin.stackexchange.com/questions/112439/how-can-the-genesis-block-contain-arbitrary-data-on-it-if-the-script-is-invalid</a></p>
</div>
<div class="paragraph">
<p>If any of the following are true, the script will evaluate to <code>false</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The final stack is empty</p>
</li>
<li>
<p>The top element on the stack is <code>0</code></p>
</li>
<li>
<p>There is more than one element remaining on the stack</p>
</li>
<li>
<p>The script returns prematurely</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are a number of other ways which scripts can fail TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_script_inside_of_addresses"><a class="link" href="#_script_inside_of_addresses">Script inside of addresses</a></h4>
<div class="paragraph">
<p>Bitcoin addresses can be of a "script hash" type (P2SH, and now P2WSH).
As the name implies a valid script is created before being hashed.
This hash is then used to generate an address which coins can be sent to.
Once coins have been received to this address a (redeem / witness) script which hashes to the same hash must be provided (<code>scriptPubKey</code>), along with a satisfactory <code>scriptSig</code> in order to authorize a new spend.</p>
</div>
<div class="paragraph">
<p>The origins of this revolutionary (at the time) style of address are touched upon in this <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020429.html" target="_blank" rel="noopener">email</a> from ZmnSCPxj.
The general context of the email is recursive covenants.
A portion of the email is quoted below for convenience:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Covenants were first expressed as a possibility, I believe, during discussions around P2SH.
Basically, at the time, the problem was this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Some receivers wanted to use k-of-n multisignature for improved security.</p>
</li>
<li>
<p>The only way to implement this, pre-P2SH, was by putting in the <code>scriptPubKey</code> all the public keys.</p>
</li>
<li>
<p>The sender is the one paying for the size of the <code>scriptPubKey</code>.</p>
</li>
<li>
<p>It was considered unfair that the sender is paying for the security of the receiver.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, <code>OP_EVAL</code> and the P2SH concept was conceived.
Instead of the <code>scriptPubKey</code> containing the k-of-n multisignature, you create a separate script containing the public keys, then hash it, and the <code>scriptPubKey</code> would contain the hash of the script.
By symmetry with the P2PKH template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">    OP_DUP OP_HASH160 &lt;hash160(pubkey)&gt; OP_EQUALVERIFY OP_CHECKSIG</code></pre>
</div>
</div>
<div class="paragraph">
<p>The P2SH template would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">    OP_DUP OP_HASH160 &lt;hash160(redeemScript)&gt; OP_EQUALVERIFY OP_EVAL</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OP_EVAL</code> would take the stack top vector and treat it as a Bitcoin SCRIPT.</p>
</div>
<div class="paragraph">
<p>It was then pointed out that <code>OP_EVAL</code> could be used to create recursive SCRIPTs by quining using <code>OP_CAT</code>.
<code>OP_CAT</code> was already disabled by then, but people were talking about re-enabling it somehow by restricting the output size of <code>OP_CAT</code> to limit the O(2^N) behavior.</p>
</div>
<div class="paragraph">
<p>Thus, since then, <code>OP_CAT</code> has been associated with <strong><strong>recursive</strong></strong> covenants (and people are now reluctant to re-enable it even with a limit on its output size, because recursive covenants).
In particular, <code>OP_CAT</code> in combination with <code>OP_CHECKSIGFROMSTACK</code> and <code>OP_CHECKSIG</code>, you could get a deferred <code>OP_EVAL</code> and then use <code>OP_CAT</code> too to quine.</p>
</div>
<div class="paragraph">
<p>Because of those concerns, the modern P2SH is now "just a template" with an implicit <code>OP_EVAL</code> of the <code>redeemScript</code>, but without any <code>OP_EVAL</code> being actually enabled.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; ZmnSCPxj
</div>
</div>
<div class="paragraph">
<p>For more details refer to <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki" target="_blank" rel="noopener">BIP16</a> which introduced P2SH addresses.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_build_system"><a class="link" href="#_build_system">Build system</a></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">return Error("Build system section not implemented yet!");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rpc_rest_zmq"><a class="link" href="#_rpc_rest_zmq">RPC / REST / ZMQ</a></h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This section has been updated to Bitcoin Core @ <a href="https://github.com/bitcoin/bitcoin/tree/v24.0.1" target="_blank" rel="noopener">v24.0.1</a>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_adding_new_rpcs"><a class="link" href="#_adding_new_rpcs">Adding new RPCs</a></h3>
<div class="paragraph">
<p>When trying to expose new information to users there are generally two possible approaches for developers to consider:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add a new server-side RPC which directly delivers the new data</p>
</li>
<li>
<p>Create a new function on the client-side (e.g. the cli tool <code>bitcoin-cli</code>) which calls one or more existing RPCs and manipulates the results into the required format.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the data is not available from existing RPCs then option 1) must be taken.
However if option 2) is available then this is the preferred first choice.
This is for the following reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Minimalistic approach: put client-side functionality into the client, not the server</p>
<div class="ulist">
<ul>
<li>
<p>Adding server-side increases maintenance burden</p>
</li>
</ul>
</div>
</li>
<li>
<p>Client-side functionality does not have to worry about API stability (as the RPCs do)</p>
</li>
<li>
<p>Functions can more easily start client side and migrate to server-side if heavily used, than visa-versa</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There may be other considerations though too:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If this functionality might be wanted in multiple clients, e.g. <code>bitcoin-cli</code> and the GUI <code>bitcoin-qt</code>, then rather than making two implementations in two clients it may make sense to add a single server-side function</p>
</li>
<li>
<p>Doing expensive computations on the client side when an inexpensive pathway is available server-side</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ultimately there is no "correct" answer for all cases, but considering some of the above before implementing one way or another</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_server"><a class="link" href="#_http_server">HTTP Server</a></h3>
<div class="paragraph">
<p>Bitcoin Core&#8217;s <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L138-L139">HTTP server</a> is responsible for handling both RPC and REST requests, but not ZMQ.
Since <a href="https://github.com/bitcoin/bitcoin/pull/5677">PR#5677</a> the server is based on <a href="https://libevent.org/">libevent2</a>.
Libevent is a general purpose event notification library, but is used in Bitcoin Core specifically for HTTP requests (which it supports natively).</p>
</div>
<div class="paragraph">
<p>Much (not all) of the libevent interface is hidden behind wrappers.
For example, <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.h#L56"><code>HTTPRequest</code></a> wraps <code>evhttp_request</code> and <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.h#L154"><code>HTTPEvent</code></a> wraps <a href="https://libevent.org/doc/structevent__base.html"><code>event_base</code></a>.</p>
</div>
<div class="paragraph">
<p>The relevant workflow for how (for example) an RPC request is handled is roughly as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The HTTP server receives an RPC command from a caller, creates an <code>evhttp_request</code> object and passes its pointer to <code>http_request_cb()</code> (this step is completely handled by libevent).</p>
</li>
<li>
<p>An <code>HTTPWorkItem</code> is <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L264">created</a>, containing the <code>evhttp_request</code> (wrapped in <code>HTTPRequest hreq</code>) as well as the path and reference to the handler function (which contains the business logic to be executed to deal with the request).</p>
<div class="ulist">
<ul>
<li>
<p>There are <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httprpc.cpp#L301-L304">2 handlers</a> for RPCs.</p>
</li>
<li>
<p>There are <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/rest.cpp#L931-L943">12 handlers</a> for REST.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>HTTPWorkItem</code> <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L266">is put on the global</a> <code>WorkQueue g_work_queue</code>, which <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L338-L344">is processed</a> by multiple worker threads asynchronously.</p>
</li>
<li>
<p>When the handler function of a <code>HTTPWorkItem</code> completes successfully, it calls <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httprpc.cpp#L230"><code>HTTPRequest::WriteReply()</code></a>, which triggers the libevent function <a href="https://libevent.org/doc/http_8h.html#a0a77d07263e20733a7562dcd576ad721"><code>evhttp_send_reply()</code></a>, which in turn returns a response to the caller and destroys the <code>evhttp_request</code> object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Endpoints are registered to the HTTP server by calling <code>RegisterHTTPHandler()</code>, such as e.g.in <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httprpc.cpp#L301-L304"><code>StartHTTPRPC()</code></a>.</p>
</div>
<div class="paragraph">
<p>The HTTP server is initiated and started from <code>AppInitServers()</code>, and stopped from <code>Shutdown()</code>.</p>
</div>
<div class="paragraph">
<p><code>StartHTTPServer()</code> <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L433">adds</a> a thread for each worker to <code>g_thread_http_workers</code>.
These threads will keep running until <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L118"><code>WorkQueue::Interrupt()</code></a> sets <code>running</code> to <code>false</code> and <a href="https://github.com/bitcoin/bitcoin/blob/v24.0.1/src/httpserver.cpp#L106">the queue is empty</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_2"><a class="link" href="#_appendix_2">Appendix</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="pimpl-technique"><a class="link" href="#pimpl-technique">PIMPL technique</a></h3>
<div class="paragraph">
<p>The Bitcoin Core codebase contains many classes of the form <code>class *Impl</code>.
These classes are taking advantage of the Pointer to Implementation <a href="https://en.cppreference.com/w/cpp/language/pimpl" target="_blank" rel="noopener">technique</a> which helps to both provide more stable ABIs and also to reduce compile-time dependencies.</p>
</div>
<div class="listingblock">
<div class="title">Some of the current Bitcoin Core PIMPL classes</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp">AddrManImpl
ChainImpl
NodeImpl
PeerManagerImpl
WalletImpl

FieldImpl
DBImpl
ExternalSignerImpl
NotificationsHandlerImpl
RPCHandlerImpl
IpcImpl
ProcessImpl
RPCMethodImpl
SketchImpl
DescriptorImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p>Amiti Uttarwar <a href="https://bitcoincore.reviews/22950" target="_blank" rel="noopener">hosted</a> a PR review club "Pimpl AddrMan to abstract implementation details" which contains information on the design aims, advantages and disadvantages.
Below are copies of the annotated pictures she created and included to assist learning.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://bitcoincore.reviews/22950"><img src="images/pimpl_peerman_amiti.png" alt="pimpl peerman amiti"></a>
</div>
<div class="title">Figure 1. PIMPL peerman</div>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://bitcoincore.reviews/22950"><img src="images/pimpl_txrequest_amiti.png" alt="pimpl txrequest amiti"></a>
</div>
<div class="title">Figure 2. PIMPL txrequest</div>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://bitcoincore.reviews/22950"><img src="images/compilation_firewall_amiti.jpg" alt="compilation firewall amiti"></a>
</div>
<div class="title">Figure 3. Compilation firewall</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_glossary"><a class="link" href="#_glossary">Glossary</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a"><a class="link" href="#_a">A</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Address</dt>
<dd>
<p>A string consisting of alphanumerics from the encoding scheme used, e.g. <code>bc1qcwfw5vekqeyx3j8negc4lltdafg3dpqs6cw24n</code>.
The exact format specifications of the string vary by address type.
Just as you ask others to send an email to your email address, you would ask others to send you bitcoin to one of your Bitcoin addresses.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_b"><a class="link" href="#_b">B</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">BIP</dt>
<dd>
<p>Bitcoin Improvement Proposals.
A set of proposals that members of the bitcoin community have submitted to improve bitcoin.
For example, BIP-21 is a proposal to improve the bitcoin uniform resource identifier (URI) scheme.</p>
</dd>
<dt class="hdlist1">Bitcoin</dt>
<dd>
<p>The name of the currency unit (the coin), the network, and the software.</p>
</dd>
<dt class="hdlist1">Block</dt>
<dd>
<p>An ordered grouping of valid transactions, marked with a timestamp and a hash of the previous block.
The block header is hashed to produce a proof of work, thereby validating the transactions.
Valid blocks are added to the most-work chain by network consensus.</p>
</dd>
<dt class="hdlist1">Blockchain</dt>
<dd>
<p>A chain of validated blocks, each linking to its predecessor all the way to the genesis block.</p>
</dd>
<dt class="hdlist1">Block Fees</dt>
<dd>
<p>The difference between the total input and output amounts for all transactions included in the block are able to be claimed by the miner in the Coinbase Transaction.</p>
</dd>
<dt class="hdlist1">Block Reward</dt>
<dd>
<p>The total of a Block Subsidy + Block fees.</p>
</dd>
<dt class="hdlist1">Block Subsidy</dt>
<dd>
<p>An amount included in each new block as a reward by the network to the miner who found the Proof-of-Work solution.
Approximately every four years, or more accurately every 210,000 blocks, the block reward is halved.
It is currently 6.25 BTC per block.</p>
</dd>
<dt class="hdlist1">Byzantine Generals Problem</dt>
<dd>
<p>A reliable computer system must be able to cope with the failure of one or more of its components.
A failed component may exhibit a type of behavior that is often overlooked&#8212;&#8203;namely, sending conflicting information to different parts of the system.
The problem of coping with this type of failure is expressed abstractly as the Byzantine Generals Problem.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_c"><a class="link" href="#_c">C</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Candidate Block</dt>
<dd>
<p>A block that a miner is still trying to mine.
It is not yet a valid block, because it does not contain a valid Proof-of-Work.</p>
</dd>
<dt class="hdlist1">Child-Pays-For-Parent (CPFP)</dt>
<dd>
<p>A Child Pays For Parent (CPFP) transaction is one where you pay a high fee to incentivize miners to also confirm the unconfirmed transaction from which you are drawing the inputs i.e.
the parent transaction.</p>
</dd>
<dt class="hdlist1">CKD</dt>
<dd>
<p>Child key derivation (CKD) functions.
Given a parent extended key and an index <code>i</code>, it is possible to compute the corresponding child extended key.
The algorithm to do so depends on whether the child is a hardened key or not (or, equivalently, whether <code>i</code>  231), and whether we&#8217;re talking about private or public keys.
<a href="https://en.bitcoin.it/wiki/BIP_0032#Child_key_derivation_.28CKD.29_functions">Read More</a></p>
</dd>
<dt class="hdlist1">Coinbase (aka coinbase data)</dt>
<dd>
<p>A special field used as the sole input for coinbase transactions.
The coinbase data field allows claiming the block reward and provides up to 100 bytes for arbitrary data.
Not to be confused with coinbase transaction or coinbase reward.</p>
</dd>
<dt class="hdlist1">Coinbase Transaction</dt>
<dd>
<p>The first transaction in a block.
Always created by a miner, it includes a single coinbase.
Not to be confused with coinbase (coinbase data) or coinbase reward</p>
</dd>
<dt class="hdlist1">Cold Storage</dt>
<dd>
<p>When bitcoin private keys are created and stored in a secure offline environment.
Cold storage is important for anyone with bitcoin holdings.
Online computers are vulnerable to hackers and should not be used to store a significant amount of bitcoin.</p>
</dd>
<dt class="hdlist1">Confirmation</dt>
<dd>
<p>Once a transaction is included in a block, it has one confirmation.
As soon as <em>another</em> block is mined on the same chain tip, the transaction has two confirmations, and so on.
Six or more confirmations is considered sufficient proof that a transaction cannot be reversed.</p>
</dd>
<dt class="hdlist1">Consensus</dt>
<dd>
<p>When several nodes, usually most nodes on the network, all have the same blocks in their locally-validated best block chain.
Not to be confused with consensus rules.</p>
</dd>
<dt class="hdlist1">Consensus Rules</dt>
<dd>
<p>The block validation rules that full nodes follow to stay in consensus with other nodes.
Not to be confused with consensus.</p>
</dd>
<dt class="hdlist1">CSV</dt>
<dd>
<p><code>CHECKSEQUENCEVERIFY</code> or <code>CSV</code> is an opcode for the Bitcoin scripting system that in combination with <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP 68</a> allows execution pathways of a script to be restricted based on the age of the UTXO being spent.
<a href="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki">BIP 0112</a></p>
</dd>
<dt class="hdlist1">CLTV</dt>
<dd>
<p><code>CHECKLOCKTIMEVERIFY</code> or <code>CTLV</code> is an opcode for the Bitcoin scripting system that allows a transaction output to be made unspendable until some point in the future. i.e. a coin cannot be spent until a certain time or blockchain height has been past. <a href="https://github.com/bitcoin/bips/blob/1f0b563738199ca60d32b4ba779797fc97d040fe/bip-0065.mediawiki">BIP 65</a></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_d"><a class="link" href="#_d">D</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Difficulty</dt>
<dd>
<p>A network-wide consensus parameter that controls how much computation is required to produce a proof of work.</p>
</dd>
<dt class="hdlist1">Difficulty Re-targeting</dt>
<dd>
<p>A network-wide recalculation of the difficulty that occurs once every 2,016 blocks and considers the hashing power of the previous 2,015 blocks (due to an off-by-one error).</p>
</dd>
<dt class="hdlist1">Difficulty Target</dt>
<dd>
<p>A difficulty at which all the computation in the network will find blocks approximately every 10 minutes.</p>
</dd>
<dt class="hdlist1">Double-Spending</dt>
<dd>
<p>Double spending is the result of successfully spending the same coin more than once.
Bitcoin protects against double-spending by verifying each transaction added to the block chain to ensure that the inputs for the transaction had not previously already been spent.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_e"><a class="link" href="#_e">E</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">ECDSA</dt>
<dd>
<p>Elliptic Curve Digital Signature Algorithm or ECDSA is a cryptographic algorithm used by bitcoin to ensure that funds can only be spent by the owner of the associated private key.</p>
</dd>
<dt class="hdlist1">Extra Nonce</dt>
<dd>
<p>As difficulty increased, miners often cycled through all 4 billion values of the nonce without finding a block.
Because the coinbase script can store between 2 and 100 bytes of data, miners started using that space as extra nonce space, allowing them to explore a much larger range of block header values to find valid blocks.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_f"><a class="link" href="#_f">F</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Fees</dt>
<dd>
<p>The sender of a transaction often includes a fee to the network for processing the requested transaction.
Most transactions require a minimum fee of 0.5 mBTC.</p>
</dd>
<dt class="hdlist1">Fork</dt>
<dd>
<p>Fork, also known as accidental fork, occurs when two or more blocks have the same block height, forking the block chain.
Typically occurs when two or more miners find blocks at nearly the same time.
Can also happen as part of an attack.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_g"><a class="link" href="#_g">G</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Genesis Block</dt>
<dd>
<p>The first block in the blockchain, used as the root for all future blocks.
The bitcoin genesis block has an unspendable Coinbase Output.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_h"><a class="link" href="#_h">H</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Halving</dt>
<dd>
<p>A halving event occurs when the block reward is cut in half, which happens approximately every four years (or precisely every 210,000 blocks).
Bitcoin already had three halving events: in 2012 (from 50 to 25 BTC), in 2016 (from 25 to 12.5 BTC), and in 2020 (from 12.5 to 6.25 BTC).</p>
</dd>
<dt class="hdlist1">Hard Fork</dt>
<dd>
<p>A loosening of consensus rules, such that transactions obeying the new ruleset <em>may</em> appear invalid to old, un-upgraded nodes.
Not to be confused with fork, soft fork, software fork or Git fork.</p>
</dd>
<dt class="hdlist1">Hardware Wallet</dt>
<dd>
<p>A hardware wallet is a special type of bitcoin wallet which stores the user&#8217;s private keys in a secure hardware device.</p>
</dd>
<dt class="hdlist1">Hash</dt>
<dd>
<p>A digital fingerprint of some binary input.</p>
</dd>
<dt class="hdlist1">Hashlocks</dt>
<dd>
<p>A hashlock is a type of encumbrance that restricts the spending of an output until a specified piece of data is publicly revealed.
Hashlocks have the useful property that once any hashlock is opened publicly, any other hashlock secured using the same key can also be opened.
This makes it possible to create multiple outputs that are all encumbered by the same hashlock and which all become spendable at the same time.</p>
</dd>
<dt class="hdlist1">HD Protocol</dt>
<dd>
<p>The Hierarchical Deterministic (HD) key creation and transfer protocol (BIP-32), which allows creating child keys from parent keys in a hierarchy.</p>
</dd>
<dt class="hdlist1">HD Wallet</dt>
<dd>
<p>Wallets using the Hierarchical Deterministic (HD Protocol) key creation and transfer protocol (BIP-32).</p>
</dd>
<dt class="hdlist1">HD Wallet Seed</dt>
<dd>
<p>HD wallet seed or root seed is a potentially-short value used as a seed to generate the master private key and master chain code for an HD wallet.</p>
</dd>
<dt class="hdlist1">HTLC</dt>
<dd>
<p>A Hashed Time Lock Contract or HTLC is a class of payments that use hashlocks and timelocks to require that the receiver of a payment either acknowledge receiving the payment prior to a deadline by generating cryptographic proof of payment or forfeit the ability to claim the payment, allowing it to be claimed back by the sender.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_k"><a class="link" href="#_k">K</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">KYC</dt>
<dd>
<p>Know your customer (KYC) is the process of a business, identifying and verifying the identity of its clients.
The term is also used to refer to the bank regulation which governs these activities.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_l"><a class="link" href="#_l">L</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">LevelDB</dt>
<dd>
<p>LevelDB is an open source on-disk key-value store.
LevelDB is a light-weight, single-purpose library for persistence with bindings to many platforms.</p>
</dd>
<dt class="hdlist1">Lightning Network</dt>
<dd>
<p>Lightning Network is an implementation of Hashed Timelock Contracts (HTLCs) with bi-directional payment channels which allows payments to be securely routed across multiple peer-to-peer payment channels.
This allows the formation of a network where any peer on the network can pay any other peer even if they don&#8217;t directly have a channel open between each other.</p>
</dd>
<dt class="hdlist1">Locktime</dt>
<dd>
<p>Locktime, or more technically <code>nLockTime</code>, is the part of a transaction which indicates the earliest time or earliest block when that transaction may be added to the block chain.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_m"><a class="link" href="#_m">M</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Mempool</dt>
<dd>
<p>The mempool (memory pool) is a collection of all the valid transactions which have been learned about from the P2P network, but have not yet been confirmed in a block.
Whilst nodes must stay in consensus about which transactions are in each block, they may have (slightly) different mempools to each other due to transaction propagation delays, amongst other things.</p>
</dd>
<dt class="hdlist1">Merkle Root</dt>
<dd>
<p>The root node of a merkle tree, a descendant of all the hashed pairs in the tree.
Block headers must include a valid merkle root descended from all transactions in that block.</p>
</dd>
<dt class="hdlist1">Merkle Tree</dt>
<dd>
<p>A tree constructed by hashing paired data (the leaves), then pairing and hashing the results until a single hash remains, the merkle root.
In bitcoin, the leaves are almost always transactions from a single block.</p>
</dd>
<dt class="hdlist1">Miner</dt>
<dd>
<p>A network node that finds valid proof of work for new blocks, by repeated hashing of the Block Header until they find a Hash which is lower than the current Difficulty.</p>
</dd>
<dt class="hdlist1">Mining Reward</dt>
<dd>
<p>Also known as Block Reward.
The reward miners receive in return for the security provided by mining.
Includes the new coins created with each new block, also known as a block reward or coinbase reward, and the transaction fees from all the transactions included in the block.</p>
</dd>
<dt class="hdlist1">Multisignature</dt>
<dd>
<p>Multisignature (multisig) transactions require signatures from multiple keys to authorize a transaction using an <code>m-of-m</code> scheme.
Also see Threshold Multisignature.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_n"><a class="link" href="#_n">N</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Network</dt>
<dd>
<p>A peer-to-peer network that propagates transactions and blocks to every Bitcoin node on the network.</p>
</dd>
<dt class="hdlist1">Nonce</dt>
<dd>
<p>The "nonce" in a bitcoin block is a 32-bit (4-byte) field whose value is permuted by miners until the hash of the block will contain a run of leading zeros.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_o"><a class="link" href="#_o">O</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Off-chain Transactions</dt>
<dd>
<p>An off-chain transaction is a movement of on-chain coins which is not immediately reflected on the main block chain, e.g. a payment through a Lightning Channel.
While an on-chain transaction&#8201;&#8212;&#8201;usually referred to as simply <em>a transaction</em>&#8201;&#8212;&#8201;modifies the blockchain and depends on the blockchain to determine its validity an off-chain transaction relies on other methods to record and validate the transaction, and may require "settlement" on-chain again at some point in the future.</p>
</dd>
<dt class="hdlist1">Opcode</dt>
<dd>
<p>Operation codes from the Bitcoin Scripting language which push data or perform functions within a pubkey script or signature script.</p>
</dd>
<dt class="hdlist1">OP_RETURN</dt>
<dd>
<p>An opcode used in one of the outputs in an <code>OP_RETURN</code> Transaction.
Not to be confused with <code>OP_RETURN</code> transaction.</p>
</dd>
<dt class="hdlist1">OP_RETURN Transaction</dt>
<dd>
<p>A transaction type that adds arbitrary data to a provably unspendable pubkey script that full nodes dont have to store in their UTXO database.
Not to be confused with OP_RETURN opcode.</p>
</dd>
<dt class="hdlist1">Orphan Block</dt>
<dd>
<p>Blocks whose parent block has not been processed by the local node, so they cant be fully validated yet.
Orphan blocks are usually cached rather than discarded, in case they make up the most-work chain in the future.
Relatively rare as of 2022.
Not to be confused with Stale Block.</p>
</dd>
<dt class="hdlist1">Orphan Transactions</dt>
<dd>
<p>Transactions that can&#8217;t go into the Mempool due to one or more missing inputs.</p>
</dd>
<dt class="hdlist1">Output</dt>
<dd>
<p>Output, transaction output, or <code>TxOut</code> is an output of a transaction which contains two fields: a value field for transferring zero or more satoshis and a pubkey script for indicating what conditions must be fulfilled for those satoshis to be spent when this Output is used as an input to a future transaction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_p"><a class="link" href="#_p">P</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">P2PKH</dt>
<dd>
<p>P2PKH (Pay-To-PubKey-Hash) is script pattern formed from hashing the pubkey being used to encumber the output.
An output locked by a P2PKH script can be unlocked (spent) by presenting a public key (which hashes to the same value) and a digital signature created by the corresponding private key.</p>
</dd>
<dt class="hdlist1">P2SH</dt>
<dd>
<p>P2SH or (Pay-to-Script-Hash) is script pattern that greatly simplifies the use of complex transaction scripts, as well as reduces transaction fees for the sender.
The script that encumbers the output (redeem script) is not presented in the locking script.
Instead, only a hash of it is in the locking script requiring the recipient to provide the script in their redeem script on spending it in the future.</p>
</dd>
<dt class="hdlist1">P2SH Address</dt>
<dd>
<p>P2SH addresses are Base58Check encodings of the 20-byte hash of a script.
They use the version prefix "5", which results in Base58Check-encoded addresses that start with a "3".
P2SH addresses hide all of the complexity, so that the person making a payment does not see the script.</p>
</dd>
<dt class="hdlist1">P2WPKH</dt>
<dd>
<p>The signature of a P2WPKH (Pay-to-Witness-Public-Key-Hash) contains the same information as P2PKH, but is located in the witness field instead of the scriptSig field.
The <code>scriptPubKey</code> is also modified.</p>
</dd>
<dt class="hdlist1">P2WSH</dt>
<dd>
<p>The difference between P2SH and P2WSH (Pay-to-Witness-Script-Hash) is about the cryptographic proof location change from the scriptSig field to the witness field and the scriptPubKey that is also modified.</p>
</dd>
<dt class="hdlist1">Paper Wallet</dt>
<dd>
<p>In the most specific sense, a paper wallet is a document containing one or more Private Keys.
However, people often use the term to mean any way of storing bitcoin offline as a physical document.
This second definition also includes paper keys and redeemable codes.</p>
</dd>
<dt class="hdlist1">Passphrase</dt>
<dd>
<p>A passphrase is an optional string created by the user that serves as an additional security factor protecting a wallet seed.
It can also be used as a form of plausible deniability, where a chosen passphrase leads to a wallet with a small amount of funds used to distract an attacker from the real wallet that contains the majority of funds, when two different passphrases are used on the same Seed.</p>
</dd>
<dt class="hdlist1">Payment Channel</dt>
<dd>
<p>A micropayment channel or payment channel is a class of techniques designed to allow users to make multiple bitcoin transactions without committing all of the transactions to the Bitcoin blockchain.
In a typical payment channel, only two transactions are added to the block chain but an unlimited or nearly unlimited number of payments can be made between the participants.</p>
</dd>
<dt class="hdlist1">Pooled Mining</dt>
<dd>
<p>Pooled mining is a mining approach where multiple generating clients contribute to the generation of a block, and then split the block reward according the contributed processing power.</p>
</dd>
<dt class="hdlist1">Proof-of-Work</dt>
<dd>
<p>A hash adhering to a pattern that requires significant computation to find, therefore "proving" work was done to find it (on average).
Miners must construct a block template which, when hashed using SHA256 (the work), will have a value at or below a network-wide Difficulty Target.</p>
</dd>
<dt class="hdlist1">Partially Spent Bitcoin Transaction (PSBT)</dt>
<dd>
<p>The Partially Signed Bitcoin Transaction (PSBT) format consists of key-value maps.
Each map consists of a sequence of key-value records, terminated by a 0x00 byte.
<a href="https://github.com/bitcoin/bips/blob/cf420089a4ed10c50e3ad2834fe13e72e1af7177/bip-0174.mediawiki#cite_note-1">BIP 174</a> and V2 <a href="https://github.com/bitcoin/bips/blob/cf420089a4ed10c50e3ad2834fe13e72e1af7177/bip-0370.mediawiki">BIP 370</a></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_r"><a class="link" href="#_r">R</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">RBF</dt>
<dd>
<p>The concept of replace-by-fee or RBF was developed by requiring replacements to pay for not only its own cost, but also the fee of the transactions being replaced, the DoS risk was strictly less than the risk of flooding with separate transactions.
<a href="https://en.bitcoin.it/wiki/Replace_by_fee">Read More</a></p>
</dd>
<dt class="hdlist1">RIPEMD-160</dt>
<dd>
<p>A 160-bit cryptographic hash function.
A strengthened version of RIPEMD with a 160-bit hash result, expected to be secure for the next ten years or more.
Used in bitcoin as a second hash, resulting in shorter outputs, when hashing a Public Key to an Address.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_s"><a class="link" href="#_s">S</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Satoshi</dt>
<dd>
<p>A Satoshi is the base denomination of coins on the Bitcoin network used in all transactions and validation.
"1 Bitcoin" is just an abstraction representing 1*10^8 satoshis which presented to users as a convenience to avoid them interacting with large number powers during network bootstrapping.
Displaying bitcoin payment values relative to "1 Bitcoin", e.g. "Send 0.0015 bitcoin to bc1qfw&#8230;&#8203;" is merely continuation of this abstraction.
Named after Satoshi Nakamoto.</p>
</dd>
<dt class="hdlist1">Satoshi Nakamoto</dt>
<dd>
<p>Satoshi Nakamoto is the name or pseudonym used by the person or group who designed bitcoin and created its original reference implementation.
As a part of the implementation, they also devised the first blockchain database.
In the process they were the first to solve the double-spending problem for digital currency.
Their real identity remains unknown.</p>
</dd>
<dt class="hdlist1">Script</dt>
<dd>
<p>Bitcoin uses a scripting system for transactions.
Forth-like, Script is simple, stack-based, and processed from left to right.
It is purposefully not Turing-complete, with no loops.</p>
</dd>
<dt class="hdlist1">ScriptPubKey (aka pubkey script)</dt>
<dd>
<p>ScriptPubKey or pubkey script, is a script included in outputs which sets the conditions that must be fulfilled for those satoshis to be spent.
Data for fulfilling the conditions can be provided in a signature script.</p>
</dd>
<dt class="hdlist1">ScriptSig (aka signature script)</dt>
<dd>
<p>ScriptSig or signature script, is the data generated by a spender which is almost always used as variables to satisfy a pubkey script.</p>
</dd>
<dt class="hdlist1">Secret Key (aka private key)</dt>
<dd>
<p>A point on the secp256k1 curve which can be used as a private key in an ECDSA signature operation to authorize spending of Bitcoins.
A secret key might take the form:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Segregated Witness</dt>
<dd>
<p>An upgrade to the Bitcoin protocol in which signature ("witness") data is separated from sender/receiver data to further optimize the structure of transactions.
It was implemented as a Soft Fork.</p>
</dd>
<dt class="hdlist1">SHA</dt>
<dd>
<p>The Secure Hash Algorithm or SHA is a family of cryptographic hash functions published by the National Institute of Standards and Technology (NIST).</p>
</dd>
<dt class="hdlist1">Simplified Payment Verification (SPV)</dt>
<dd>
<p>SPV or simplified payment verification is a method for verifying that particular transactions were included in a block, without downloading the entire block using Merkle Proofs.
This method of verification can be used by lightweight Bitcoin clients.</p>
</dd>
<dt class="hdlist1">Soft Fork</dt>
<dd>
<p>A tightening of consensus rules, such that transactions obeying the new ruleset must appear valid to old, un-upgraded nodes.
Not to be confused with fork, hard fork, software fork or Git fork.</p>
</dd>
<dt class="hdlist1">Stale Block</dt>
<dd>
<p>A valid block that was successfully mined but that isnt included on the current most-work chain tip, because some other valid block that was mined at the same height extended the old tip first.
The miner of a stale block doesn&#8217;t get the block reward or the transactions fees of this block.
Not to be confused with Orphan Block or Candidate Block.</p>
</dd>
<dt class="hdlist1">Stratum (STM)</dt>
<dd>
<p>Stratum or STM is used by Pooled Miners to request new work from a centralized server.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_t"><a class="link" href="#_t">T</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Threshold Multisignature</dt>
<dd>
<p>Threshold Multisignature transactions require signatures from <code>n-of-m</code> keys to authorize a transaction.
Also see Multisignature.</p>
</dd>
<dt class="hdlist1">Timelocks</dt>
<dd>
<p>A timelock is a type of encumbrance that restricts the spending of some bitcoin until a specified future time or block height.
Timelocks feature prominently in many bitcoin contracts, including payment channels and hashed timelock contracts.</p>
</dd>
<dt class="hdlist1">Transaction</dt>
<dd>
<p>A signed data structure expressing a transfer of value from one or more UTXOs to one or more recipients.
Transactions are transmitted over the Bitcoin network, collected by miners, and included into blocks, being made permanent on the blockchain.</p>
</dd>
<dt class="hdlist1">Turing Completeness</dt>
<dd>
<p>A programming language is "Turing complete" if it can run any program that a Turing machine can run, given enough time and memory.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_u"><a class="link" href="#_u">U</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Unspent Transaction Output (UTXO)</dt>
<dd>
<p>An unspent transaction output that can be spent as an input in a new transaction with a valid <code>ScriptSig</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_w"><a class="link" href="#_w">W</a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Wallet</dt>
<dd>
<p>Software used to send and receive bitcoin.
May store private keys, public keys, addresses or descriptors depending on wallet type and security setup and may be able to generate:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Addresses (derived from Descriptor or Public Keys)</p>
</li>
<li>
<p>PSBTs</p>
</li>
<li>
<p>Fully signed Transactions</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Wallet Import Format (WIF)</dt>
<dd>
<p>WIF or Wallet Import Format is a data interchange format designed to allow exporting and importing a single private key with a flag indicating whether or not it uses a compressed public key.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Some contributed definitions have been sourced under a CC-BY license from the <a href="https://en.bitcoin.it/wiki/Main_Page">bitcoin Wiki</a> or from other open source documentation sources.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
<!--- <script src="/assets/js/tocbot.js"></script> --->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<script>
    /* Tocbot dynamic TOC, works with tocbot 3.0.2 */
    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();
</script>
</body>
</html>