= Script

TIP: This section has been updated to Bitcoin Core @ https://github.com/bitcoin/bitcoin/tree/v23.0[v23.0^]

== Script origins

. New scripts are created when creating a new address.
. Scripts can be learned about when we receive a new transaction from the P2P network or from a newly-connected block.
. With Taproot there may be scripts in alternative Tapscript execution paths which nobody on the network will ever learn about.

== Scripts in Bitcoin Core

The primary script objects are found in _script.h_.
An enum over all the permitted OPCODES, `enum opcodetype`.
The `CScriptNum` class which handles arithmetic operations on integer ``CScriptNum``s, whether from a loose `int_64t` or from a second `CScriptNum` object.
The `CScript` class which supports serializing data into scripts, along with many helper functions such as returning the script type.

== Validating scripts

For some additional context on how scripts are validated in Bitcoin see <<Executing scripts>> in the Appendix.

Transactions contain a vector of inputs (`CTxIn`) and vector of outputs (`CTxOut`), along with other required data.

Each `CTxIn` contains:

* `COutPoint prevout;`
* `CScript scriptSig;`
* `uint32_t nSequence;`
* `CScriptWitness scriptWitness;`

Each `CTxOut` contains:

* `CAmount nValue;`
* `CScript scriptPubKey;`

When a new transaction is learned about from the wallet or P2P network (as a TX INV ) it is passed to <<Single transactions, `AcceptToMemoryPool()`>> which will run the various script checks.

TIP: Transactions learned about directly in blocks have their scripts validated via `ActivateBestChainStep()` --> `ConnectBlock()` --> `ConnectTip()` --> `CChainState::ConnectBlock()` (https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L1924-L2232[link^]), which will end up calling `CheckTxInputs()` and `CheckInputScripts()`, as described in the subsequent section on <<PolicyScriptChecks script checks, PolicyScriptChecks>>.

=== PreCheck script checks

`PreChecks()` performs some structural checks inside of `CheckTransaction()` before passing the transaction to `IsStandard()`.
In here the transaction weight is checked, along with the `scriptSig` size of every input and the type of every output.
Any failures are written back into the `reason` string which will be propagated up in the case the function returns `false`.

The next script checks come after the mempool is consulted to test for conflicts, and inputs are checked against our `CoinsCache` (UTXO set).
`AreInputsStandard()` will take the transaction and access each `vin` from a copy of our UTXO set `CCoinsViewCache`.

TIP: We use a cached version of `CCoinsView` here because although we want to introspect the transaction by doing a mock evaluation of the script, we do not want to modify the UTXO set yet, nor mark any coins as `DIRTY`.

The type of script can be evaluated using the _script/standard.cpp#Solver()_ function, which will return the script type as a member of the `TxOutType` https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/standard.h#L59-L71[enum^].

[example]
====
`Solver()` takes a scriptPubkey as a `CScript` and a vector of `unsigned_char` vectors called `vSolutionsRet`.
It will attempt to evaluate and return the script type, along with any parsed pubKeys or pubKeyHashes in the `vSolutionsRet` vector.

For example, if the script type is P2SH it will execute:

[source,cpp,options=nowrap]
----
    // Shortcut for pay-to-script-hash, which are more constrained than the other types:
    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL
    if (scriptPubKey.IsPayToScriptHash())
    {
        std::vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);
        vSolutionsRet.push_back(hashBytes);
        return TxoutType::SCRIPTHASH;
    }
----

In this case, simply reading the scriptHash into the `vSolutionsRet` vector before returning with the type.

For SegWit inputs the witness program is returned, for PayToPubKey (which although basically unused now is still supported) the pubKey is returned, and for P2PKH the pubKeyHash is returned.
The MultiSig case returns the number of required signatures, all the pubKeys and, the total number of keys.

====

If the input is `NONSTANDARD` or `WITNESS_UNKNOWN` then we can return early with `false`.
If the transaction is of type `SCRIPTHASH` (P2SH) then we want to check that the `scriptSig` does not have extra data included which is not relevant to the `scriptPubKey`, and that the `SigOpCount` for the input obeys the specific P2SH limits.
To do this we perform a mini evaluation of the script by passing in the `SCRIPT_VERIFY_NONE` https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.h#L44[flag^], which instructs the interpreter not to verify operations guarded by flags.

Looking into `EvalScript()` itself we can see which verification operations are going to be skipped by using this flag; in the positions we see the flag being tested e.g.:

[source,cpp,options=nowrap]
----
case OP_CHECKLOCKTIMEVERIFY:
{
    if (!(flags & SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
        // not enabled; treat as a NOP2
        break;
    }
----

With `SCRIPT_VERIFY_NONE` set this will skip `fRequireMinimal`, `OP_CHECKLOCKTIMEVERIFY`, `OP_CHECKSEQUENCEVERIFY`, discouragement of the upgradable ``NOP``s 1; 4; 5; 6; 7; 8; 9; 10; `OP_CHECKSIG` and `OP_CHECKSIGVERIFY`.
This makes the evaluation much cheaper by avoiding expensive signature verification, whilst still allowing quick testing that stack will not be empty (if signature verification succeeded), and that `MAX_P2SH_SIGOPS` count is not exceeded.

IMPORTANT: Avoiding expensive operations, e.g. full script evaluation, for as long as possible, whilst also avoiding repeating work, is a key anti-DoS consideration of transaction and script validation.

After `AreInputsStandard()` has returned, if the transaction is SegWit the witnesses are checked by `IsWitnessStandard()`.
This functions similarly to `AreInputsStandard()` is that it will loop over every `vin` to the transaction and access the coin using the same `CCoinsViewCache` as used previously.

The input's script `prevScript` is initialised to the input's scriptPubKey, but then a check is done to see if the input is of P2SH type (corresponding to a P2SH-wrapped address), again performing the mock script validation with the `SCRIPT_VERIFY_NONE` flag applied.
If it is found to be P2SH-wrapped then the input's script is set to the `scriptSig` as converted into a stack.

With the input script set witness evaluation can begin.
First the script is checked to be a valid witness program, i.e. a single byte `PUSH` opcode, followed by a sized data push.
This is using https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/script.cpp#L220-L234[`CScript::IsWitnessProgram()`^].

Segwit V0 or V1 script size limits (as appropriate) are checked before returning `true`.
The final script checks inside of `PreChecks()` are to get the full transaction sigOp cost, which is a total of the legacy, P2SH and Witness sigOps.

////
TODO: Why is this check https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L827-L829 not located right after the calculation, here: https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L806
////

=== PolicyScriptChecks script checks

This block is going to re-use the same `Workspace` as `PreChecks`, but at this stage doesn't re-use any cached `PreComputedTransactionData`.

The main check block is shown below:

._validation.cpp:982_
[source,cpp,options=nowrap]
----
    // Check input scripts and signatures.
    // This is done last to help prevent CPU exhaustion denial-of-service attacks.
    if (!CheckInputScripts(tx, state, m_view, scriptVerifyFlags, true, false, ws.m_precomputed_txdata)) {
        // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we
        // need to turn both off, and compare against just turning off CLEANSTACK
        // to see if the failure is specifically due to witness validation.
        TxValidationState state_dummy; // Want reported failures to be from first CheckInputScripts
        if (!tx.HasWitness() && CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, ws.m_precomputed_txdata) &&
                !CheckInputScripts(tx, state_dummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, ws.m_precomputed_txdata)) {
            // Only the witness is missing, so the transaction itself may be fine.
            state.Invalid(TxValidationResult::TX_WITNESS_STRIPPED,
                    state.GetRejectReason(), state.GetDebugMessage());
        }
        return false; // state filled in by CheckInputScripts
    }
----

This performs validation of the input scripts using our "policy flags", where policy flags refer to a https://github.com/bitcoin/bitcoin/blob/v23.0/src/policy/policy.h#L60-L79[list^] of script verification https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.h#L38-L147[flags^] that form "standard transactions", i.e. those transactions that will be relayed around the network by other nodes running the same policies.

****
Notice that `CheckInputScripts()` is run up to 3 times.
The first run will check all the inputs using the whole `STANDARD_SCRIPT_VERIFY_FLAGS` and `cacheSigStore` set to `true`, so that we cache expensive signature verification results.
If this returns `true` then `PolicyScriptChecks()` is complete and will also return `true` to the caller.

If this first check fails we then check to see if it is specifically a missing witness which is causing the failure.
In order to do this we will execute two more runs, one with `SCRIPT_VERIFY_WITNESS` and `SCRIPT_VERIFY_CLEANSTACK` disabled which should pass, and a second in series with only `SCRIPT_VERIFY_CLEANSTACK` disabled which should fail.
****

From this call-site inside MempoolAccept `CheckInputScripts()` is called with `cacheSigStore` set to `true`, and `cacheFullScriptStore` set to `false`.
This means that we will keep signature verifications in the `CSignatureCache` (named `signatureCache`).
Full scripts will not be cached.
The two caches are setup as https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1144-L1145[part^] of `AppInitMain()`.

`CheckInputScripts()` begins by checking that we have not already executed this input script and stored it in the global Cuckoo Cache `g_scriptExecutionCacheHasher`, if we have, then this means the previous execution already succeeded so we can return `true` early.
Next check that we have all our input coins loaded from the cached copy of the UTXO set `CCoinsViewCache`.

Now script execution begins by looping over each input and storing the input and transaction in a `CScriptCheck` closure (`check`) for later evaluation.
Calling the `()` operator on the closure will https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L1593-L1597[initialize^] a new `CScript` and `CScriptWitness` for the evaluation, and execute `VerifyScript()`.

NOTE: You can see the `cacheSigStore` boolean being propagated to the `CachingSignatureTransactionChecker` signalling that we should cache these signature evalations.

Execution of `VerifyScript` is described below.

=== VerifyScript

////
TODO:

What is this doing? interpreter.cpp:1974

    static const CScriptWitness emptyWitness;
    if (witness == nullptr) {
        witness = &emptyWitness;
    }
    bool hadWitness = false;

////

``Verifyscript()``s function is to very a single scriptSig (SS) against a scriptPubKey (SPK) and return a boolean `true` or `false`, returning a more specific error description via the passed in `ScriptError`.
Historically (in Bitcoin versions < 0.3.5) this was done by concatenating the SS and the SPK and evaluating as one, however this meant that malicious actors could leave arbitrary extra objects on the stack, ultimately resulting in being able to spend coins using any scripts with what should have been an invalid SS.
Therefore now evaluation takes place in two stages, first the SS, who's pre-populated `stack` is then passed in as an argument to SPK evaluation.

TIP: The mechanics of `EvalScript()` are shown in the section <<EvalScript>>.

If both calls to `EvalScript` succeed, then any witness program is verified, followed by P2SH scripts.
Notice here how in each of these cases the stack is trimmed to size `1` at the end of evaluation, because in both cases extra elements would ordinarily remain on the stack (P2SH and witness inputs).
If the evaluation succeeds then the `CLEANSTACK` rule is enforced https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.cpp#L2067-L2078[afterwards^].

=== EvalScript

`EvalScript()` handles the Forth-like script interpretation itself.
It takes in a stack, script, interpretation flags, a https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.h#L243-L267[signature checker^], a signature version and a `ScriptExecutionData` struct.

After checking that it's not about to evaluate a Taproot key-path spend (`SIGVERSION::TAPROOT`), which has no script to execute, we initialize some iterators on the script, along with variables to represent the current opcode, the push value, the condition stack and the altstack.
The https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.cpp#L282-L343[condition stack^] is used to help evaluation of IF/ELSE clauses and the altstack is used to push and pop items from the main stack during execution (using `OP_TOALTSTACK` and `OP_FROMALTSTACK`).

Next we check script size is less that `MAX_SCRIPT_SIZE` (10KB).
Although total serialized transaction size, and SigOpCount has been checked previously, this is the first time the size of the scripts themselves are checked.

Then comes the main evaluation for loop.
Whilst many conditions are checked, and specific invalidity errors returned, there is also the possibility of other un-tested errors occurring during evaluation, and so the loop is enclosed by a try-except block which will catch these errors, instead of causing a program crash.

[IMPORTANT]
====
Script execution is effectively executing uncontrolled, 3rd party data.
If a malicious actor found a way to purposefully provoke an unhandled error during evaluation, without the try-catch block, they would be able to effectively crash any node on the network of their choosing by sending it the malicious script.
====

The main loop is simple conceptually:

. Read an instruction using the `CScript::GetOp()` method.
This will read an `opcodetype` into the `opcode` variable, and the raw instruction into the `vchPushValue` variable.
. Test for the script element size, number of script ops, and whether this is a disabled opcode.
. Enter a switch on `opcode` to perform specific evaluation according to the operation specified.

== Signing a transaction

`script/sign.cpp#SignTransaction()` will sign a transaction one input at a time, by looping through the ``vin``s of the `CMutableTransaction` it has been passed.

The critical section of the `SignTransaction()` loop is shown below:

.src/script/sign.cpp#SignTransaction()
[source,cpp,options=nowrap]
----
    for (unsigned int i = 0; i < mtx.vin.size(); i++) {
        CTxIn& txin = mtx.vin[i];
        auto coin = coins.find(txin.prevout);
        if (coin == coins.end() || coin->second.IsSpent()) {
            input_errors[i] = "Input not found or already spent";
            continue;
        }
        const CScript& prevPubKey = coin->second.out.scriptPubKey;
        const CAmount& amount = coin->second.out.nValue;

        SignatureData sigdata = DataFromTransaction(mtx, i, coin->second.out);
        // Only sign SIGHASH_SINGLE if there's a corresponding output:
        if (!fHashSingle || (i < mtx.vout.size())) {
            ProduceSignature(*keystore, MutableTransactionSignatureCreator(&mtx, i, amount, nHashType), prevPubKey, sigdata);
        }

        UpdateInput(txin, sigdata);
----

The Pubkey and amount for each coin are retrieved, along with signature data for the coin.
`DataFromTransaction()` returns all the information needed to produce a signature for that coin as a `SignatureData` struct:

.src/script/sign.h#SignatureData
[source,cpp,options=nowrap]
----
// This struct contains information from a transaction input and also contains signatures for that input.
// The information contained here can be used to create a signature and is also filled by ProduceSignature
// in order to construct final scriptSigs and scriptWitnesses.
struct SignatureData {
    bool complete = false; ///< Stores whether the scriptSig and scriptWitness are complete
    bool witness = false; ///< Stores whether the input this SigData corresponds to is a witness input
    CScript scriptSig; ///< The scriptSig of an input. Contains complete signatures or the traditional partial signatures format
    CScript redeem_script; ///< The redeemScript (if any) for the input
    CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.
    CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.
    std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.
    std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>> misc_pubkeys;
    std::vector<CKeyID> missing_pubkeys; ///< KeyIDs of pubkeys which could not be found
    std::vector<CKeyID> missing_sigs; ///< KeyIDs of pubkeys for signatures which could not be found
    uint160 missing_redeem_script; ///< ScriptID of the missing redeemScript (if any)
    uint256 missing_witness_script; ///< SHA256 of the missing witnessScript (if any)

    SignatureData() {}
    explicit SignatureData(const CScript& script) : scriptSig(script) {}
    void MergeSignatureData(SignatureData sigdata);
};
----

With the signing `SigningProvider`, `scriptPubKey` and `sigdata` we are able to call `script/sign.cpp#ProduceSignature()` for signing on each individual input.
// TODO: Fact check!
Inputs by default will signed with a sighash of `SIGHASH_ALL`, but this can be re-configured as appropriate.

=== Producing a signature

Taking a look inside `ProduceSignature()` we can see how this works.

.src/script/sign.cpp
[source,cpp,options=nowrap]
----
bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)
{
    if (sigdata.complete) return true;

    std::vector<valtype> result;
    TxoutType whichType;
    bool solved = SignStep(provider, creator, fromPubKey, result, whichType, SigVersion::BASE, sigdata);
    bool P2SH = false;
    CScript subscript;
    sigdata.scriptWitness.stack.clear();

    // ...
}
----

The function performs some initialisations before calling `script/sign.cpp#SignStep()` for the first time, with the `SigVersion` `SIGVERSION::BASE`.
`SignStep()` in turn calls `Solver()`, which is a function designed to detect the script type encoding of the `scriptPubKey`, and then return the detected type along with the parsed ``scriptPubKey``s/hashes.

If it is successful, `SignStep` continues by switching over the script type and, depending on the script type, calling the required signing operation and pushing the required elements onto the `sigdata` variable.

.script/sign.cpp
[source,cpp,options=nowrap]
----
static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey,
                     std::vector<valtype>& ret, TxoutType& whichTypeRet, SigVersion sigversion, SignatureData& sigdata)
{
    // ...
    whichTypeRet = Solver(scriptPubKey, vSolutions);

    switch (whichTypeRet) {
    case TxoutType::NONSTANDARD:
    case TxoutType::NULL_DATA:
    case TxoutType::WITNESS_UNKNOWN:
    case TxoutType::WITNESS_V1_TAPROOT:
        // ...
    case TxoutType::PUBKEY:
        // ...
    case TxoutType::PUBKEYHASH:
        // ... 
    case TxoutType::SCRIPTHASH:
        // ...
    case TxoutType::MULTISIG:
        // ... 
    case TxoutType::WITNESS_V0_KEYHASH:
        // ...
    case TxoutType::WITNESS_V0_SCRIPTHASH:
        // ... 
    } 
    // ...
}
----

Once `SignStep()` returns to `ProduceSignature()`, a second switch takes place.
If we are trying to produce a signature for P2SH, P2WPKH or P2WSH then the first pass from `SignStep()` will have been enough to detect the `TxOutType` and assemble the (redeem/witness) scripts, but not yet generate the entire signature in required format.
In order to get this signature, `SignStep()` is called again, this time with the assembled redeem/witness script and the appropriate `TxOutType`.

TIP: This recursion makes sense if you consider that, in order to sign for these script-encumbered inputs, we don't want to sign for the `scriptPubKey` that we are starting with but for the {redeem|witness} script instead.

We can see this switch in `ProduceSignature()`:

.src/script/sign.cpp#ProduceSignature()
[source,cpp,options=nowrap]
----
    if (solved && whichType == TxoutType::SCRIPTHASH)
    {
        // Solver returns the subscript that needs to be evaluated;
        // the final scriptSig is the signatures from that
        // and then the serialized subscript:
        subscript = CScript(result[0].begin(), result[0].end());
        sigdata.redeem_script = subscript;
        solved = solved && SignStep(provider, creator, subscript, result, whichType, SigVersion::BASE, sigdata) && whichType != TxoutType::SCRIPTHASH;
        P2SH = true;
    }

    if (solved && whichType == TxoutType::WITNESS_V0_KEYHASH)
    {
        CScript witnessscript;
        // This puts the parsed pubkeys from the first pass into the witness script
        witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;
        TxoutType subType;
        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata);
        sigdata.scriptWitness.stack = result;
        sigdata.witness = true;
        result.clear();
    }
    else if (solved && whichType == TxoutType::WITNESS_V0_SCRIPTHASH)
    {
        CScript witnessscript(result[0].begin(), result[0].end());
        sigdata.witness_script = witnessscript;
        TxoutType subType;
        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata) && subType != TxoutType::SCRIPTHASH && subType != TxoutType::WITNESS_V0_SCRIPTHASH && subType != TxoutType::WITNESS_V0_KEYHASH;
        result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));
        sigdata.scriptWitness.stack = result;
        sigdata.witness = true;
        result.clear();
    } else if (solved && whichType == TxoutType::WITNESS_UNKNOWN) {
        sigdata.witness = true;
    }
----

Finally, if all went well the signature is checked with <<VerifyScript,`VerifyScript()`>>.

=== Creating a signature

TODO: dig into `CreateSig()`

== Appendix

=== Executing scripts

Bitcoin differs from most other cryptocurrencies by not including the script with the unspent transaction output on the blockchain, only the scriptPubKey is publicly viewable until spending time.
The practical effects of this are:

* Users wishing to sign transactions which are locked using locking scripts require *two* pieces of information:
.. The relevant private key(s)
.. The `redeemScript`, i.e. the contract of the script itself.

Scripts are executed by first evaluating the unlocking script, then evaluating the locking script on the same stack.
If both of these steps result in a `1` (or any other non-zero value) being the only item on the stack, the script is verified as `true`.

TODO: Not true exactly:
https://bitcoin.stackexchange.com/questions/112439/how-can-the-genesis-block-contain-arbitrary-data-on-it-if-the-script-is-invalid

If any of the following are true, the script will evaluate to `false`:

* The final stack is empty
* The top element on the stack is `0`
* There is more than one element remaining on the stack
* The script returns prematurely

There are a number of other ways which scripts can fail TODO

=== Script inside of addresses

Bitcoin addresses can be of a "script hash" type (P2SH, and now P2WSH).
As the name implies a valid script is created before being hashed.
This hash is then used to generate an address which coins can be sent to.
Once coins have been received to this address a (redeem / witness) script which hashes to the same hash must be provided (`scriptPubKey`), along with a satisfactory `scriptSig` in order to authorize a new spend.

The origins of this revolutionary (at the time) style of address are touched upon in this https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020429.html[email^] from ZmnSCPxj.
The general context of the email is recursive covenants.
A portion of the email is quoted below for convenience:

[quote, ZmnSCPxj]
____
Covenants were first expressed as a possibility, I believe, during discussions around P2SH.
Basically, at the time, the problem was this:

* Some receivers wanted to use k-of-n multisignature for improved security.
* The only way to implement this, pre-P2SH, was by putting in the `scriptPubKey` all the public keys.
* The sender is the one paying for the size of the `scriptPubKey`.
* It was considered unfair that the sender is paying for the security of the receiver.

Thus, `OP_EVAL` and the P2SH concept was conceived.
Instead of the `scriptPubKey` containing the k-of-n multisignature, you create a separate script containing the public keys, then hash it, and the `scriptPubKey` would contain the hash of the script.
By symmetry with the P2PKH template:

[source]
----
    OP_DUP OP_HASH160 <hash160(pubkey)> OP_EQUALVERIFY OP_CHECKSIG
----

The P2SH template would be:

[source]
----
    OP_DUP OP_HASH160 <hash160(redeemScript)> OP_EQUALVERIFY OP_EVAL
----

`OP_EVAL` would take the stack top vector and treat it as a Bitcoin SCRIPT.

It was then pointed out that `OP_EVAL` could be used to create recursive SCRIPTs by quining using `OP_CAT`.
`OP_CAT` was already disabled by then, but people were talking about re-enabling it somehow by restricting the output size of `OP_CAT` to limit the O(2^N) behavior.

Thus, since then, `OP_CAT` has been associated with ***recursive*** covenants (and people are now reluctant to re-enable it even with a limit on its output size, because recursive covenants).
In particular, `OP_CAT` in combination with `OP_CHECKSIGFROMSTACK` and `OP_CHECKSIG`, you could get a deferred `OP_EVAL` and then use `OP_CAT` too to quine.

Because of those concerns, the modern P2SH is now "just a template" with an implicit `OP_EVAL` of the `redeemScript`, but without any `OP_EVAL` being actually enabled.
____

For more details refer to https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki[BIP16^] which introduced P2SH addresses.

////

== Removed text

=== Signing scripts

In order to sign for a script we are going to call `SignTransaction()` which has the following signature:

.script/sign.cpp#SignTransaction()
[source,cpp,options=nowrap]
----
bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore, const std::map<COutPoint, Coin>& coins, int nHashType, std::map<int, std::string>& input_errors)
----

This function gets called either via the RPC (`signrawtransactionwithkey`) or from within the wallet, via either `LegacyScriptPubKeyMan` or `DescriptorScriptPubKeyMan` which are ultimately called as part of `CWallet::CreateTransactionInternal()`.
As we can see it takes a `CMutableTransaction` (a mutable version of a `CTransaction`), a  `SigningProvider`, a map of ``COutPoint``s and ``Coin``s and a `sighash`.

In order to sign for the script, we need to be able to "solve" the `ScriptPubKey` on the UTXOs being selected.
This is achieved internally by looping over each coin selected as input, setting `prevPubkey` to the coins `scriptPubkey`, retrieving the `SignatureData` from the coin (signatures and scripts) via `DataFromTransaction()` and then calling `ProduceSignature()`, passing in this information along with with an instance of `MutableTransactionSignatureCreator` as the signature creator, on each coin.

The remainder of the loop then verifies the produced signature using the cached version of the `CTransaction`, `txConst` so as not to repeat potentially expensive signature calculations.

.script/sign.cpp#SignTransaction()
[source,cpp,options=nowrap]
----
    // ...

    bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);

    // Use CTransaction for the constant parts of the
    // transaction to avoid rehashing.
    const CTransaction txConst(mtx);
    // Sign what we can:
    for (unsigned int i = 0; i < mtx.vin.size(); i++) {
        CTxIn& txin = mtx.vin[i];
        auto coin = coins.find(txin.prevout);
        if (coin == coins.end() || coin->second.IsSpent()) {
            input_errors[i] = "Input not found or already spent";
            continue;
        }
        const CScript& prevPubKey = coin->second.out.scriptPubKey;
        const CAmount& amount = coin->second.out.nValue;

        SignatureData sigdata = DataFromTransaction(mtx, i, coin->second.out);
        // Only sign SIGHASH_SINGLE if there's a corresponding output:
        if (!fHashSingle || (i < mtx.vout.size())) {
            ProduceSignature(*keystore, MutableTransactionSignatureCreator(&mtx, i, amount, nHashType), prevPubKey, sigdata);
        }

        UpdateInput(txin, sigdata);

        // amount must be specified for valid segwit signature
        if (amount == MAX_MONEY && !txin.scriptWitness.IsNull()) {
            input_errors[i] = "Missing amount";
            continue;
        }

        ScriptError serror = SCRIPT_ERR_OK;
        if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount, MissingDataBehavior::FAIL), &serror)) {
            if (serror == SCRIPT_ERR_INVALID_STACK_OPERATION) {
                // Unable to sign input and verification failed (possible attempt to partially sign).
                input_errors[i] = "Unable to sign input, invalid stack size (possibly missing key)";
            } else if (serror == SCRIPT_ERR_SIG_NULLFAIL) {
                // Verification failed (possibly due to insufficient signatures).
                input_errors[i] = "CHECK(MULTI)SIG failing with non-zero signature (possibly need more signatures)";
            } else {
                input_errors[i] = ScriptErrorString(serror);
            }
        } else {
            // If this input succeeds, make sure there is no error set for it
            input_errors.erase(i);
        }
    }
    return input_errors.empty();
----

Not every input will be signed for during this loop -- an obvious example would be a multi-signature transaction involving multiple keystores, therefore this function is robust against failing to sign for an input, but everything that this keystore can sign for is, and is also verified.

=== Verifying scripts

=== Standardness

=== Descriptors

Have a descriptor cache for descriptors in _src_script_descriptor.h_:

.src/script/descriptor.h
[source,cpp,options=nowrap]
----

/** \brief Interface for parsed descriptor objects.
 *
 * Descriptors are strings that describe a set of scriptPubKeys, together with
 * all information necessary to solve them. By combining all information into
 * one, they avoid the need to separately import keys and scripts.
 *
 * Descriptors may be ranged, which occurs when the public keys inside are
 * specified in the form of HD chains (xpubs).
 *
 * Descriptors always represent public information - public keys and scripts -
 * but in cases where private keys need to be conveyed along with a descriptor,
 * they can be included inside by changing public keys to private keys (WIF
 * format), and changing xpubs by xprvs.
 *
 * Reference documentation about the descriptor language can be found in
 * doc/descriptors.md.
 */

----

Special functions to parse a get checksums for descriptors.

=== Interpreting scripts

_src/script/interpreter.h_

`BaseSignatureChecker` class is used to check signatures and has functions for the various different signature types allowed:

.src/script/interpreter.h
[source,cpp,options=nowrap]
----
class BaseSignatureChecker
{
public:
    virtual bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const
    {
        return false;
    }

    virtual bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const
    {
        return false;
    }

    virtual bool CheckLockTime(const CScriptNum& nLockTime) const
    {
         return false;
    }

    virtual bool CheckSequence(const CScriptNum& nSequence) const
    {
         return false;
    }

    virtual ~BaseSignatureChecker() {}
};
----

This class gets overridden by the `GenericSignatureChecker` or `DeferringSignatureChecker`.

=== Building blocks

==== Keys

==== Redeem script

==== OPCODES

==== Interpreter 

==== SIGHASH flags

==== Script verification flags

In _src/script/bitcoinconsensus.h_

==== Script cache

==== Sig cache


== What is script

Bitcoin addresses that "store" coins are in reality cryptographic challenges that, in order to spend the coins, need to be solved by providing a solution whilst adhering to the rules of the scripting system.

The way that Bitcoin decided to implement such a challenge-response system was by using a script-based language -- called "Bitcoin Script" -- which could be used to both present the challenges, and through which to compose the solutions.

[quote, Satoshi Nakamoto]
____
The script is actually a predicate. It’s just an equation that evaluates to true or false. Predicate is a long and unfamiliar word so I called it script.
____

Usually we refer to the _challenge_ as a "locking script", or in the codebase `ScriptPubKey`, and the _solution_ as the "unlocking script" or `scriptSig`.
Often the locking script itself is hashed before being represented as an address and therefore the full "redeem script" must be retained by the party that generated the address (the receiver), because they will need to provide a full copy of the script along with it's satisfaction in order to spend the coins in the future.

.P2PK script example
[example]
====
The simplest example of this is a public key address, for which the challenge contains a public key and an `OP_CHECKSIG`, and simply requires as its solution a signature (over the transaction data) from the private key corresponding to the public key.
`OP_CHECKSIG` will cause the script interpreter to https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/interpreter.cpp#L1083-L1105[check^] that the pubkey at the top position of the stack (from the script pubkey) corresponds to the signature found at the second-from-top position on the stack (from the scriptsig).
If this evaluates to `true` both items are popped from the stack, and execution is complete.
====

Learn Me a Bitcoin has a https://learnmeabitcoin.com/technical/script[web page^] which demonstrates some common script types, as well as including a run-down of how script is crafted and interpreted.

== What is a script made of

Bitcoin script consists of two components:

. Data
. OPCODES (Operation Codes)

A full list of available (and disabled) OPCODES can be found in https://github.com/bitcoin/bitcoin/blob/v23.0/src/script/script.h#L65-L206[script.h^].

== Building a transaction

When we want to construct a transaction in Bitcoin Core, the general process (excluding fee constraints and coin selection) is as follows.

=== Constructing a transaction

We begin by initialising a new `CMutableTransaction` which we will use to build the transaction.
We use the mutable version of the transaction object as transaction assembly might require adding or removing inputs to satisfy fee constraints, as well as re-ordering of in- and outputs to throw off heuristics related to change addresses.

.primitives/transaction.h
[source,cpp,options=nowrap]
----
/** A mutable version of CTransaction. */
struct CMutableTransaction
{
    std::vector<CTxIn> vin;
    std::vector<CTxOut> vout;
    int32_t nVersion;
    uint32_t nLockTime;
    
    // ...
----

Next we create a vector of ``COutput``s (UTXOs) available for the wallet to select from as transaction inputs, followed by creating a vector of ``CRecipient``s to use as the transaction outputs, which notably includes the `scriptPubKey` for each recipient:

[source,cpp,options=nowrap]
----
struct CRecipient
{
    CScript scriptPubKey;
    CAmount nAmount;
    bool fSubtractFeeFromAmount;
};
----

For each recipient we then create a new `CTxOut` object with the `amount` and `scriptPubkey` and append this to our `CMutableTransaction.vout` vector.

(Optional): Create a change address script for ourselves of the appropriate type.

==== Coin selection

If coin selection is not being used (manual selection of input coins), we select coins to reach the required `amount` from our vector of ``COutput``s (UTXOs) and add them to a set of ``CInputCoin``s.

.wallet/coinselection.h
[source,cpp,options=nowrap]
----
class CInputCoin {
public:
    // ..
    COutPoint outpoint;
    CTxOut txout;
    CAmount effective_value;
    CAmount m_fee{0};
    CAmount m_long_term_fee{0};
    // ..
----

Next we add each selected coin to `CMutableTransaction.vin` as a `CTxIn` and shuffle the `vin` coin order, then lock the wallet and begin to sign the transaction with `CWallet::SignTransaction()`.

=== Signing setup

In order to have our `{Descriptor|Legacy}ScriptPubKeyMan` sign the transaction, we need to pass it a mapping from ``COutput``s to ``Coin``s, in the form: `std::map<COutpoint, Coin>`.

We generate this mapping inside `CWallet::SignTransaction()` which, when called with a `CMutableTransaction` as argument, begins by iterating the vector of ``vin``s in the transaction, using `mapWallet.find()` to locate the previous transaction and return it as a `CWalletTx`, which we use to initialise each `Coin`.

.src/wallet/wallet.cpp
[source,cpp,options=nowrap]
----
bool CWallet::SignTransaction(CMutableTransaction& tx) const
{
    AssertLockHeld(cs_wallet);

    // Build coins map
    std::map<COutPoint, Coin> coins;
    for (auto& input : tx.vin) {
        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);
        if(mi == mapWallet.end() || input.prevout.n >= mi->second.tx->vout.size()) {
            return false;
        }
        const CWalletTx& wtx = mi->second;
        coins[input.prevout] = Coin(wtx.tx->vout[input.prevout.n], wtx.m_confirm.block_height, wtx.IsCoinBase());
    }
    std::map<int, std::string> input_errors;
    return SignTransaction(tx, coins, SIGHASH_ALL, input_errors);
}
----

With our coin map we can loop through every ScriptPubKeyMan available to us and call its `{Descriptor|Legacy}ScriptPubKeyMan->SignTransaction()` function on the coin map.
This has the effect of trying to sign each coin with all available ScriptPubKeyMans in a single pass.
This is actioned by calling `CWallet::SignTransaction()` again, this time including the coin map and sighash type as arguments which calls a different function `SignTransaction()` specialization:

.src/wallet/wallet.cpp
[source,cpp,options=nowrap]
----
bool CWallet::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const
{
    // Try to sign with all ScriptPubKeyMans
    for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {
        // spk_man->SignTransaction will return true if the transaction is complete,
        // so we can exit early and return true if that happens
        if (spk_man->SignTransaction(tx, coins, sighash, input_errors)) {
            return true;
        }
    }

    // At this point, one input was not fully signed otherwise we would have exited already
    return false;
}
----

The ScriptPubKeyMan will first collect the relevant keys for each coin into a `FlatSigningProvider` and will call `script/sign.cpp#SignTransaction()` on the transaction, passing along the `FlatSigningProvider`.

./wallet/scriptpubkeyman.cpp
[source,cpp,options=nowrap]
----
bool DescriptorScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const
{
    std::unique_ptr<FlatSigningProvider> keys = std::make_unique<FlatSigningProvider>();
    for (const auto& coin_pair : coins) {
        std::unique_ptr<FlatSigningProvider> coin_keys = GetSigningProvider(coin_pair.second.out.scriptPubKey, true);
        if (!coin_keys) {
            continue;
        }
        *keys = Merge(*keys, *coin_keys);
    }

    return ::SignTransaction(tx, keys.get(), coins, sighash, input_errors);
}
----

////
