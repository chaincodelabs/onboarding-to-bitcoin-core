= Overview & architecture of Bitcoin Core

== Decentralized development

Olivia Lovenmark and Amiti Uttarwar describe in their https://blog.okcoin.com/2020/09/15/developing-bitcoin/[blog post] "Developing Bitcoin", how changes to bitcoin follow the pathway from proposal to being merged into the software, and finally into voluntary adoption by users choosing to use the software.

== Bitcoin Core development process and documentation

The Bitcoin Core project itself contains two documents of particular interest to Contributors:

. https://github.com/bitcoin/bitcoin/tree/master/CONTRIBUTING.md[CONTRIBUTING.md] -- How to get started contributing to the project.
. https://github.com/bitcoin/bitcoin/tree/master/doc/developer-notes.md[developer-notes.md] -- Development guidelines, coding style etc.

=== Reviews

Jon Atack's article https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core[How To Contribute Pull Requests To Bitcoin Core] describes some less-obvious requirements that any PR you make might be subjected to during peer review, for example that it needs an accompanying test, or that an intermediate commit on the branch doesn't compile.
It also describes the uncodified expectation that Contributors should not only be writing code, but perhaps more importantly be providing reviews on other Contributors' PRs.
Most developers enjoy writing their own code more than reviewing code from others, but the decentralized review process is arguably the most critical defence Bitcoin development has against malicious actors and therefore important to try and uphold.

IMPORTANT: Jon's personal estimates of "5-15 PR reviews|issues solved" per PR submitted is not a hard requirement, just what Jon himself feels would be best for the project. Don't be put off submitting a potentially valuable PR just because "you haven't done enough reviews"!

// Archived @ https://archive.is/MyohE
Gloria Zhao's https://github.com/glozow/bitcoin-notes/blob/master/review-checklist.md[review checklist] details what a "good" review might look like, along with some examples of what she personally considers good reviews.
In addition to this it details how potential Reviewers can approach a new PR they have chosen to review, along with the sorts of questions they should be asking (and answering) in order to provide a meaningful review.
Some examples of the subject areas Gloria covers include the PR's subject area, motivation, downsides, approach, security and privacy risks, implementation of the idea, performance impact, concurrency footguns, tests and documentation needed.

=== Commit messages

When writing commit messages be sure to have read Chris Beams' "How to Write a Git Commit Message" https://chris.beams.io/posts/git-commit/[blog post].
As described in CONTRIBUTING.md PRs should be prefixed with the component or area the PR affects.
Common areas are listed in CONTRIBUTING.md section: https://github.com/bitcoin/bitcoin/tree/master/CONTRIBUTING.md#creating-the-pull-request[Creating the pull request].
Individual commit messages are also often given similar prefixes in the commit title depending on which area of the codebase the changes primarily affect.

=== Build issues

Some compile-time issues can be caused by an unclean build directory.
The comments in https://github.com/bitcoin/bitcoin/issues/19330[issue 19330] provide some clarifications and tips on how other Contributors clean their directories, as well as some ideas for shell aliases to boost productivity.

=== Debugging Bitcoin Core

// Archived @ https://archive.is/hRExH
Fabian Jahr has created a https://github.com/fjahr/debugging_bitcoin[guide] on "Debugging Bitcoin Core", aimed at detailing the ways in which various Bitcoin Core components can be debugged, including the Bitcoin Core binary itself, unit tests, functional tests along with an introduction to core dumps and the Valgrind memory leak detection suite.

Of particular note to Developers are the configure flags used to build Bitcoin Core without optimisations to permit more effective debugging of the various resulting binary files.

Fabian has also presented on this topic a number of times:

. On his https://www.youtube.com/watch?v=6aPSCDAiqVI[ChainCode labs' residency].
. At https://www.youtube.com/watch?v=gr75ubfNQ20[Scaling Bitcoin 2019].

== Bitcoin Core architecture

lsilva01 has written a deep technical dive into the architecture of Bitcoin Core as part of the Bitcoin Core Onboarding Documentation in https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc[Bitcoin Architecture].

Once you've gained some insight into the architecture of the program itself you can learn further details about which code files implement which functionality from the https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.1_regions.asciidoc[Bitcoin Core regions] document.

James O'Beirne has recorded 3 videos which go into detail on how the codebase is laid out, how the build system works, what developer tools there are, as well as what the primary function of many of the files in the codebase are:

. https://www.youtube.com/watch?v=J1Ru8V36z_Y[Architectural tour of Bitcoin Core (part 1 of 3)]
. https://www.youtube.com/watch?v=RVWcUnpZX4E[Architectural tour of Bitcoin Core (part 2 of 3)]
. https://www.youtube.com/watch?v=UiD5DZU9Zp4[Architectural tour of Bitcoin Core (part 3 of 3)]

== Test networks

Three types of test network are available:

1. Testnet
2. Regtest
3. Signet

These three networks all use coins of zero value, so can be used experimentally.

They primary differences between the networks are as follows:

.Comparison of different test networks
[cols="1h,1,1,1"]
|===================================================================================================================================
| Feature                   | Testnet                        | Regtest                       | Signet

| Mining algorithm          | Public hashing with difficulty | Local hashing, low difficulty | Signature from authorized signers
| Block production schedule | Varies per hashrate            | On-demand                     | Reliable intervals (default 2.5 mins)
| P2P port                  | 18333                          | 18443                         | 38333
| RPC port                  | 18332                          | 18442                         | 38332
| Peers                     | Public                         | None                          | Public
| Topology                  | Organic                        | Manual                        | Organic
| Chain birthday            | 2011-02-02                     | At time of use                | 2020-09-01
| Can initiate re-orgs      | If Miner                       | Yes                           | No
| Primary use               | Networked testing              | Automated integration tests   | Networked testing
|===================================================================================================================================

== Signet testing network

Signet is both a tool that allows Developers to create their own networks for testing interactions between different Bitcoin software, and the name of the most popular of these public testing networks.
Signet was codified in https://github.com/bitcoin/bips/tree/master/bip-0325.mediawiki[BIP 325].

To connect to the "main" Signet network, simply start bitcoind with the signet option, e.g. `bitcoind -signet`.
Don't forget to also pass the signet option to `bitcoin-cli` if using it to control bitcoind, e.g. `bitcoin-cli -signet your_command_here`.
Instructions on how to setup your own Signet network can be found in the Bitcoin Core Signet https://github.com/bitcoin/bitcoin/tree/master/contrib/signet/README.md[README.md].
The Bitcoin wiki Signet https://en.bitcoin.it/wiki/Signet[page] provides additional background on Signet.

== Regtest testing network

Another test network named _regtest_, which stands for _regression test_, is also available.
This network is enabled by starting bitcoind with the `-regtest` option.
This is an entirely self-contained mode, giving you complete control of the state of the blockchain.
Blocks can be mined instantly, and only explicitly.

The https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc[functional tests] use this mode, but you can run it manually.
It provides a good means to learn and experiment on your own terms.
It's often run with a single node but may be run with multiple co-located (local) nodes (most of the functional tests do this).
The blockchain initially contains only the genesis block, so you need to mine >100 blocks in order to have any spendable coins from a coinbase transaction.
Here's an example session (after you've built `bitcoind` and `bitcoin-cli`):

[source,bash,options="nowrap"]
----
$ mkdir /tmp/regtest-datadir
$ src/bitcoind -regtest -daemon -datadir=/tmp/regtest-datadir
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getblockchaininfo
{
  "chain": "regtest",
  "blocks": 0,
  "headers": 0,
  "bestblockhash": "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",
  _(...)_
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir createwallet testwallet
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir generate 3
{
  "address": "bcrt1qpw3pjhtf9myl0qk9cxt54qt8qxu2mj955c7esx",
  "blocks": [
    "6b121b0c094b5e107509632e8acade3f6c8c2f837dc13c72153e7fa555a29984",
    "5da0c549c3fddf2959d38da20789f31fa7642c3959a559086436031ee7d7ba54",
    "3210f3a12c25ea3d8ab38c0c4c4e0d5664308b62af1a771dfe591324452c7aa9"
  ]
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getblockchaininfo
{
  "chain": "regtest",
  "blocks": 3,
  "headers": 3,
  "bestblockhash": "3210f3a12c25ea3d8ab38c0c4c4e0d5664308b62af1a771dfe591324452c7aa9",
  _(...)_
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getbalances
{
  "mine": {
    "trusted": 0.00000000,
    "untrusted_pending": 0.00000000,
    "immature": 150.00000000
  }
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir stop
----

Monitor `/tmp/regtest-datadir/regtest/debug.log` to see what `bitcoind` is doing.
You may stop and restart the node and it will use the existing state.
(Simply remove the data directory to start again from scratch.)

=== Manual testing while running a functional test

Running regtest as described allows you to start from scratch with an empty chain, empty wallet, and no existing state.
A particularly effective alternate way to use regtest is to start a https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc[functional test] and cause it to pause during execution (after it's created various state), and then interact with the test using `bitcoin-cli` as described above.
Add `import time; time.sleep(600)` somewhere in a functional test (Python script) to suspend the test at that point for 10 minutes.

When the test is paused (you may want to add a `print("paused")` statement just before the call to `sleep()` to know it's been reached), find the data directory for the nodes, for example:

[source,bash,options=nowrap]
----
$ ps alx | grep bitcoind
0  1000   57478   57476  20   0 1031376 58604 pipe_r SLl+ pts/10    0:06 /g/bitcoin/src/bitcoind -datadir=/tmp/bitcoin_func_test_ovsi15f9/node0 -logtimemicros -debug (...)
0  1000   57479   57476  20   0 965964 58448 pipe_r SLl+ pts/10     0:06 /g/bitcoin/src/bitcoind -datadir=/tmp/bitcoin_func_test_ovsi15f9/node1 -logtimemicros -debug (...)
----

You can look at the `bitcoin.conf` files within the data directories to see what other config options are being specified for the test (there's always `regtest=1`), which is a good way to learn advanced uses of regtest.

Now you can submit RPC requests to a specific node, for example:

[source,bash,options=nowrap]
----
$ src/bitcoin-cli -datadir=/tmp/bitcoin_func_test_ovsi15f9/node0 getblockchaininfo
----

Another way to pause execution is to set a breakpoint, either by using a Python debugger, or by adding `import pdb; pdb.set_trace()` at the desired stopping point; when the script reaches this point you'll see the debugger's `(Pdb)` prompt, at which you can type `help` and see and do all kinds of useful things.
This has the further advantage (over calling `time.sleep()`), in that you can single-step through the test while also manually interacting with the nodes, combining automated and manual testing.

== BIPs

Bitcoin uses Bitcoin Improvement Proposals (BIPs) as a design document for introducing new features or behaviour into bitcoin.
Bitcoin Magazine describes what a BIP is in their article https://bitcoinmagazine.com/guides/what-is-a-bitcoin-improvement-proposal-bip[What Is A Bitcoin Improvement Proposal (BIP)], specifically highlighting how BIPs are not necessarily binding documents required to achieve consensus.

The BIPs are currently hosted on GitHub in the bitcoin/bips https://github.com/bitcoin/bips[repo].

[example]
====
The BIPs include https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki[BIP 2] which self-describes the BIP process in more detail.
Of particular interest might be the sections https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki#BIP_types[BIP Types] and https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki#BIP_workflow[BIP Workflow].
====

=== What does having a BIP number assigned to an idea mean

Bitcoin Core https://github.com/bitcoin/bitcoin/pull/22665[issue #22665] described how BIP125 was not being strictly adhered to by Bitcoin Core.
This raised discussion amongst developers about whether the code (a.k.a. the implementation) or the BIP itself should act as the specification, with most developers expressing that they felt that "the code was the spec" and any BIP generated was merely a design document to aid with re-implementation by others, and should be corrected if necessary.

NOTE: This view was not completely unanimous in the community.

For consensus-critical code most Bitcoin Core Developers consider "the code is the spec" to be the ultimate source of truth, which is one of the reasons that recommending running other full node implementations can be so difficult.
A knock-on effect of this was that there were calls for review on BIP2 itself, with newly-appointed BIP maintainer Karl-Johan Alm (a.k.a. kallewoof) posting his thoughts to the https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019457.html[bitcoin-dev mailing list].

In summary a BIP represents a design document which should assist others in implementing a specific feature in a compatible way.
These features are optional to usage of Bitcoin, and therefore implementation of BIPs are not required to use Bitcoin, only to remain compatible.
Simply being _assigned_ a BIP does *not* mean that an idea is endorsed as being a "good" idea, only that it is fully-specified in a way that others could use to re-implement.
Many ideas are assigned a BIP and then never implemented or used on the wider network.

== Getting started with development

What are the best ways to get started with Bitcoin Core development?

One of the roles most in-demand from the project is that of code review, and in fact this is also one of the best ways of getting familiarized with the codebase too!
Reviewing a few PRs, and adding your review comments to the PR on GitHub can be really valuable for you, the PR author and the bitcoin community.
This https://testing.googleblog.com/2018/05/code-health-understanding-code-in-review.html[Google Code Health] blog post gives some good advice on how to go about code review and getting past "feeling that you're not as smart as the programmer who wrote the change".
If you're going to ask some questions as part of review, try and keep questions https://testing.googleblog.com/2019/11/code-health-respectful-reviews-useful.html[respectful].

There is also a Bitcoin Core PR https://bitcoincore.reviews/[Review Club] held weekly on IRC which provides an ideal entry point into the Bitcoin Core codebase.
A PR is selected, questions on the PR are provided to be discussed on irc.libera.chat #bitcoin-core-pr-reviews IRC room and a host will lead discussion around the changes.

Aside from review, there are 3 main avenues which might lead you to submitting your *own* PR to the repository:

. Finding a `good first issue`, as tagged in the https://github.com/bitcoin/bitcoin/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22[issue tracker]
. Fixing a bug
. Adding a new feature (that you want for yourself?)

Choosing a "good first issue" from an area of the codebase that seems interesting to you is often a good approach.
This is because these issues have been somewhat implicitly "concept ACKed" by other Contributors as "something that is likely worth someone working on".

If you don't have a bug fix or new feature in mind and you're struggling to find a good first issue which looks suitable for you, don't panic.
Instead keep reviewing other Contributors' PRs to continue improving your understanding of the process (and the codebase) while you watch the Issue tracker for something which you like the look of.

When you've decided what to work on it's time to take a look at the current behaviour of that part of the code and perhaps more importantly, try to understand _why_ this was originally implemented in this way.
This process of codebase "archaeology" will prove invaluable in the future when you are trying to learn about other parts of the codebase on your own.

==  Codebase archaeology

When considering changing code it can be helpful to try and first understand the rationale behind why it was implemented that way originally.
One of the best ways to do this is by using a combination of git tools:

- `git blame`
- `git log -S`
- `git log -G`
- `git log -p`

... and the discussions in various places on the GitHub repo.

=== git blame

The git `blame` command will show you when (and by who) a particular line of code was last _changed_.

For example, if we checkout Bitcoin Core at https://github.com/bitcoin/bitcoin/tree/v22.0[v22.0] and we are planning to make a change related to the `m_addr_send_times_mutex` found in _src/net_processing.cpp_, we might want to find out more about its history before touching it.

With `git `blame` we can find out the last person who touched this code:

[source,bash,options="nowrap"]
----
# Find the line number for blame
$ grep -n m_addr_send_times_mutex src/net_processing.cpp
233:    mutable Mutex m_addr_send_times_mutex;
235:    std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};
237:    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(m_addr_send_times_mutex){0};
4304:    LOCK(peer.m_addr_send_times_mutex);
----

[source,bash,options=nowrap]
----
$ git blame -L233,233 src/net_processing.cpp

76568a3351 (John Newbery 2020-07-10 16:29:57 +0100 233)     mutable Mutex m_addr_send_times_mutex;
----

With this information we can easily look up that commit to gain some additional context:

[source,bash,options=nowrap]
----
$ git show 76568a3351

───────────────────────────────────────
commit 76568a3351418c878d30ba0373cf76988f93f90e
Author: John Newbery <john@johnnewbery.com>
Date:   Fri Jul 10 16:29:57 2020 +0100

    [net processing] Move addr relay data and logic into net processing

----

So we've learned now that this mutex was moved here by John from net.{cpp|h} in it's most recent touch.
Let's see what else we can find out about it.

=== git log -S

`git log -S` allows us to search for commits where this line was _modified_ (not where it was only moved, for that use `git log -G`).

[TIP]
====
A 'modification' (vs. a 'move') in git parlance implies that there are uneven instances of the search term in the commit diffs' add/remove sections.

This implies that this term has either been added or removed in the commit.
====

[source,bash,options=nowrap]
----
$ git log -S m_addr_send_times_mutex
───────────────────────────────────────
commit 76568a3351418c878d30ba0373cf76988f93f90e
Author: John Newbery <john@johnnewbery.com>
Date:   Fri Jul 10 16:29:57 2020 +0100

    [net processing] Move addr relay data and logic into net processing

───────────────────────────────────────
commit ad719297f2ecdd2394eff668b3be7070bc9cb3e2
Author: John Newbery <john@johnnewbery.com>
Date:   Thu Jul 9 10:51:20 2020 +0100

    [net processing] Extract `addr` send functionality into MaybeSendAddr()

    Reviewer hint: review with

     `git diff --color-moved=dimmed-zebra --ignore-all-space`

───────────────────────────────────────
commit 4ad4abcf07efefafd439b28679dff8d6bbf62943
Author: John Newbery <john@johnnewbery.com>
Date:   Mon Mar 29 11:36:19 2021 +0100

    [net] Change addr send times fields to be guarded by new mutex

----

We learn now that John also originally added this to _net.{cpp|h}_, before later moving it into _net_processing.{cpp|h}_ as part of a push to separate out `addr` relay data and logic from _net.cpp_.

=== git log -p

`git log -p` (usually also given with a file name argument) follows each commit message with a _patch_ (diff) of the changes made by that commit to that file (or files).
This is similar to `git blame` except that `git blame` shows the source of only lines _currently_ in the file.

=== git log --follow _file..._

One of the most famous https://github.com/bitcoin/bitcoin/pull/9260[file renames] was _src/main.{h,cpp}_ to _src/validation.{h,cpp}_ in 2016.
If you simply run `git log src/validation.h`, the oldest displayed commit is one that implemented the rename.
`git log --follow src/validation.h` will show the same recent commits followed by the older _src/main.h_ commits.

To see the history of a file that's been removed, specify ` -- ` before the file name, such as `git log -- some_removed_file.cpp`.

=== PR discussion

To get even more context on the change we can leverage GitHub and take a look at the comments on the PR where this mutex was introduced (or at any subsequent commit where it was modified).
To find the PR you can either paste the commit hash (`4ad4abcf07efefafd439b28679dff8d6bbf62943`) into GitHub, or list merge commits in reverse order, showing oldest merge with the commit at the top to show the specific PR number e.g.:

[source,bash,options=nowrap]
----
$ git log --merges --reverse --oneline --ancestry-path 4ad4abcf07efefafd439b28679dff8d6bbf62943..upstream | head -n 1

d3fa42c79 Merge bitcoin/bitcoin#21186: net/net processing: Move addr data into net_processing
----

Reading up on https://github.com/bitcoin/bitcoin/pull/21186[PR#21186] will hopefully provide us with more context we can use.

[example]
====
We can see from the linked https://github.com/bitcoin/bitcoin/issues/19398#issue-646725848[issue 19398] what the motivation for this move was.
====

== Solo work

:bip-extensions-mail: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019457.html
:core-dev-08-26: https://www.erisian.com.au/bitcoin-core-dev/log-2021-08-26.html

* Read lsilva01's https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc[1.0 Bitcoin Architecture]. Particularly sections:
** Executables
** https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.1_regions.asciidoc[Regions] (and all sub-sections)

TODO: Add questions on current architecture of Core

== Group work

=== Signet

Either:

* One member of the group create a private signet as documented on the Bitcoin Wiki https://en.bitcoin.it/wiki/Signet#Custom_Signet[Custom Signet] page.
* Distribute the `signetchallenge` value
* One or all group members can act as Signet miners
* Have all group members connect in to the custom signet

OR:

* Group members request some signet coins from the https://signet.bc-2.jp/[signet faucet] or using the https://github.com/bitcoin/bitcoin/tree/master/contrib/signet#getcoinspy[getcoins.py] script.
+
NOTE: The Signet `getcoins.py` script may not work if a captcha has been added to the site.

THEN:

* Send coins around the group

