= Overview & Development process 

TIP: This section has been updated to Bitcoin Core @ https://github.com/bitcoin/bitcoin/tree/v23.0[v23.0^]

WARNING: Whilst this disclaimer is present this documentation is considered a work in progress and may be subject to minor or major changes at any time without notice.

WARNING: This documentation can temporarily be found hosted at https://obc.256k1.dev[^], however the hosted location is likely to change in the near future.

== Contributor journeys

Some Contributors have documented their journeys into the space which lets us learn about approaches they found useful, and also any pitfalls and things they found difficult along the way.

* https://github.com/amitiuttarwar[Amiti Uttarwar^] - https://medium.com/@amitiu/onboarding-to-bitcoin-core-7c1a83b20365[Onboarding to Bitcoin Core^]
* https://github.com/jonatack[Jon Atack^] - https://jonatack.github.io/articles/on-reviewing-and-helping-those-who-do-it[On Reviewing, and Helping Those Who Do It^]
* https://github.com/jimmysong[Jimmy Song^] - https://bitcointechtalk.com/a-gentle-introduction-to-bitcoin-core-development-fdc95eaee6b8[A Gentle Introduction to Bitcoin Core Development^]

== Decentralized development

Olivia Lovenmark and Amiti Uttarwar describe in their https://blog.okcoin.com/2020/09/15/developing-bitcoin/[blog post^] "Developing Bitcoin", how changes to bitcoin follow the pathway from proposal to being merged into the software, and finally into voluntary adoption by users choosing to use the software.

== Developer guidelines

The Bitcoin Core project itself contains three documents of particular interest to Contributors:

. https://github.com/bitcoin/bitcoin/tree/master/CONTRIBUTING.md[CONTRIBUTING.md^] -- How to get started contributing to the project.  (Forking, creating branches, commit patches)
. https://github.com/bitcoin/bitcoin/tree/master/doc/developer-notes.md[developer-notes.md^] -- Development guidelines, coding style etc.
. https://github.com/bitcoin/bitcoin/blob/master/doc/productivity.md[productivity.md^] -- Many tips for improving developer productivity (ccache, reviewing code, refspecs, git diffs)
. https://github.com/bitcoin/bitcoin/blob/master/test/README.md[test/README.md] -- Guidance on running the test suite

TIP: Using `ccache` as described in _productivity.md_ above will speed up builds of Bitcoin Core dramatically.

TIP: Setting up a ramdisk for the test suite as described in _test/README.md_ will speed up running the test suite dramatically.

== Development workflow

Bitcoin Core uses a GitHub-based workflow for development.
The primary function of GitHub in the workflow is to discuss patches and connect them with review comments.

While some other prominent projects, e.g. the Linux kernel, use email to solicit feedback and review, Bitcoin Core has used GitHub for many years.
Initially, Satoshi distributed the code through private emails and hosting source archives at bitcoin.org, and later by hosting on SourceForge (which used SVN but did not at that time have a pull request system like GitHub).
The earliest reviewers submitted changes using patches either through email exchange with Satoshi, or by posting them on the bitcoin forum.

In August 2009, the source code was moved to GitHub by Sirius, and development has remained there and used the GitHub workflows ever since.

=== Use of GitHub

The GitHub side of the Bitcoin Core workflow for Contributors consists primarily of:

* Issues
* PRs
* Reviews
* Comments

Generally, issues are used for two purposes:

. Posting known issues with the software, e.g., bug reports, crash logs
. Soliciting feedback on potential changes without providing associated code, as would be required in a PR.

GitHub provides their own https://guides.github.com/features/issues/[guide^] on mastering Issues which is worth reading to understand the feature-set available when working with an issue.

PRs are where Contributors can submit their code against the main codebase and solicit feedback on the concept, the approach taken for the implementation, and the actual implementation itself.

PRs and Issues are often linked to/from one another:

[example]
====
One common workflow is when an Issue is opened to report a bug.
After replicating the issue, a Contributor creates a patch and then opens a PR with their proposed changes.

In this case, the Contributor should, in addition to comments about the patch, reference that the patch fixes the issue.
For a patch which fixes issue 22889 this would be done by writing "fixes #22889" in the PR description or in a commit message.
In this case, the syntax "fixes #issue-number" is caught by GitHub's https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue[pull request linker^], which handles the cross-link automatically.
====

Another use-case of Issues is soliciting feedback on ideas that might require _significant_ changes.
This helps free the project from having too many PRs open which aren't ready for review and might waste reviewers' time.
In addition, this workflow can also save Contributors their _own_ valuable time, as an idea might be identified as unlikely to be accepted _before_ the contributor spends their time writing the code for it.

Most code changes to bitcoin are proposed directly as PRs -- there's no need to open an Issue for every idea before implementing it unless it may require significant changes.
Additionally, other Contributors (and would-be Reviewers) will often agree with the approach of a change, but want to "see the implementation" before they can really pass judgement on it.

GitHub is therefore used to help store and track reviews to PRs in a public way.

Comments (inside Issues, PRs, Projects etc.) are where all (GitHub) users can discuss relevant aspects of the item and have history of those discussions preserved for future reference.
Often Contributors having "informal" discussions about changes on e.g. IRC will be advised that they should echo the gist of their conversation as a comment on GitHub, so that the rationale behind changes can be more easily determined in the future.

=== Reviewing code

Jon Atack provides a guide to reviewing a Bitcoin Core PR in his article https://jonatack.github.io/articles/how-to-review-pull-requests-in-bitcoin-core[How To Review Pull Requests in Bitcoin Core^].

// Archived @ https://archive.is/MyohE
Gloria Zhao's https://github.com/glozow/bitcoin-notes/blob/master/review-checklist.md[review checklist^] details what a "good" review might look like, along with some examples of what she personally considers good reviews.
In addition to this, it details how potential Reviewers can approach a new PR they have chosen to review, along with the sorts of questions they should be asking (and answering) in order to provide a meaningful review.
Some examples of the subject areas Gloria covers include the PR's subject area, motivation, downsides, approach, security and privacy risks, implementation of the idea, performance impact, concurrency footguns, tests and documentation needed.

=== Contributing code

This section details some of the processes surrounding code contributions to the Bitcoin Core project along with some common pitfalls and tips to try and avoid them.

==== Branches

You should *not* use the built-in GitHub branch https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository[creation^] process, as this interferes with and confuses the Bitcoin Core git process.

Instead, you should use either the native https://git-scm.com/downloads[`git`^] or the GitHub https://github.com/cli/cli[`gh` cli^] (requires `git`) tools to create your own branches locally, before pushing them to your fork of the repo, and opening a PR against the Bitcoin Core repo from there.

==== Creating a PR

Jon Atack's article https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core[How To Contribute Pull Requests To Bitcoin Core^] describes some less-obvious requirements that any PR you make might be subjected to during peer review, for example that it needs an accompanying test, or that an intermediate commit on the branch doesn't compile.
It also describes the uncodified expectation that Contributors should not only be writing code, but perhaps more importantly be providing reviews on other Contributors' PRs.
Most developers enjoy writing their own code more than reviewing code from others, but the decentralized review process is arguably the most critical defence Bitcoin development has against malicious actors and therefore important to try and uphold.

IMPORTANT: Jon's estimates of "5-15 PR reviews|issues solved" per PR submitted is not a hard requirement, just what Jon himself feels would be best for the project. Don't be put off submitting a potentially valuable PR just because "you haven't done enough reviews"!

==== Commit messages

When writing commit messages be sure to have read Chris Beams' "How to Write a Git Commit Message" https://chris.beams.io/posts/git-commit/[blog post^].
As described in CONTRIBUTING.md, PRs should be prefixed with the component or area the PR affects.
Common areas are listed in CONTRIBUTING.md section: https://github.com/bitcoin/bitcoin/tree/master/CONTRIBUTING.md#creating-the-pull-request[Creating the pull request^].
Individual commit messages are also often given similar prefixes in the commit title depending on which area of the codebase the changes primarily affect.

==== Continuous integration

When PRs are submitted against the primary Bitcoin Core repo a series of CI https://github.com/bitcoin/bitcoin/tree/v23.0/ci[tests^] will automatically be run.
These include a series of linters and formatters such as `clang-format`, `flake8` and `shellcheck`.
It's possible (and advised) to run these checks locally against any changes you make before you push them.

In order to run the lints yourself you'll have to first make sure your python environment and system have the packages listed in the CI install https://github.com/bitcoin/bitcoin/blob/v23.0/ci/lint/04_install.sh[script].
You can then run a decent sub-set of the checks by running:

[source,bash]
----
python test/lint/lint-circular-dependencies.py

# requires requires 'flake8', 'mypy', 'pyzmq', 'codespell', 'vulture'
python test/lint/lint-python.py

python test/lint/lint-whitespace.py
----

Or you can run all checks with:

[source,bash]
----
python test/lint/all-lint.py
----

NOTE: Previously these checks were shell scripts (`*.sh`), but they have now been migrated to python on master.
+
If you are following with tag v23.0 these may still exist as `*.sh`.

Linting your changes reduces the chances of pushing them as a PR and then having them quickly being marked as failing CI. The GitHub PR page auto-updates the CI status.

TIP: If you do fail a lint or any other CI check, force-pushing the fix to your branch will cancel the currently-running CI checks and restart them.

==== Build issues

Some compile-time issues can be caused by an unclean build directory.
The comments in https://github.com/bitcoin/bitcoin/issues/19330[issue 19330^] provide some clarifications and tips on how other Contributors clean their directories, as well as some ideas for shell aliases to boost productivity.

==== Debugging Bitcoin Core

// Archived @ https://archive.is/hRExH
Fabian Jahr has created a https://github.com/fjahr/debugging_bitcoin[guide^] on "Debugging Bitcoin Core", aimed at detailing the ways in which various Bitcoin Core components can be debugged, including the Bitcoin Core binary itself, unit tests, functional tests along with an introduction to core dumps and the Valgrind memory leak detection suite.

Of particular note to Developers are the configure flags used to build Bitcoin Core without optimisations to permit more effective debugging of the various resulting binary files.

Fabian has also presented on this topic a number of times.
A https://btctranscripts.com/scalingbitcoin/tel-aviv-2019/edgedevplusplus/debugging-bitcoin/[transcript^] of his edgedevplusplus talk is available.

=== Codebase archaeology

When considering changing code it can be helpful to try and first understand the rationale behind why it was implemented that way originally.
One of the best ways to do this is by using a combination of git tools:

* `git blame`
* `git log -S`
* `git log -G`
* `git log -p`
* `git log -L`

As well as the discussions in various places on the GitHub repo.

==== git blame

The git `blame` command will show you when (and by who) a particular line of code was last _changed_.

For example, if we checkout Bitcoin Core at https://github.com/bitcoin/bitcoin/tree/v22.0[v22.0^] and we are planning to make a change related to the `m_addr_send_times_mutex` found in _src/net_processing.cpp_, we might want to find out more about its history before touching it.

With `git `blame` we can find out the last person who touched this code:

[source,bash,options="nowrap"]
----
# Find the line number for blame
$ grep -n m_addr_send_times_mutex src/net_processing.cpp
233:    mutable Mutex m_addr_send_times_mutex;
235:    std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};
237:    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(m_addr_send_times_mutex){0};
4304:    LOCK(peer.m_addr_send_times_mutex);
----

[source,bash,options=nowrap]
----
$ git blame -L233,233 src/net_processing.cpp

76568a3351 (John Newbery 2020-07-10 16:29:57 +0100 233)     mutable Mutex m_addr_send_times_mutex;
----

With this information we can easily look up that commit to gain some additional context:

[source,bash,options=nowrap]
----
$ git show 76568a3351

───────────────────────────────────────
commit 76568a3351418c878d30ba0373cf76988f93f90e
Author: John Newbery <john@johnnewbery.com>
Date:   Fri Jul 10 16:29:57 2020 +0100

    [net processing] Move addr relay data and logic into net processing

----

So we've learned now that this mutex was moved here by John from _net.{cpp|h}_ in it's most recent touch.
Let's see what else we can find out about it.

==== git log -S

`git log -S` allows us to search for commits where this line was _modified_ (not where it was only moved, for that use `git log -G`).

[TIP]
====
A 'modification' (vs. a 'move') in git parlance is the result of uneven instances of the search term in the commit diffs' add/remove sections.

This implies that this term has either been added or removed in the commit.
====

[source,bash,options=nowrap]
----
$ git log -S m_addr_send_times_mutex
───────────────────────────────────────
commit 76568a3351418c878d30ba0373cf76988f93f90e
Author: John Newbery <john@johnnewbery.com>
Date:   Fri Jul 10 16:29:57 2020 +0100

    [net processing] Move addr relay data and logic into net processing

───────────────────────────────────────
commit ad719297f2ecdd2394eff668b3be7070bc9cb3e2
Author: John Newbery <john@johnnewbery.com>
Date:   Thu Jul 9 10:51:20 2020 +0100

    [net processing] Extract `addr` send functionality into MaybeSendAddr()

    Reviewer hint: review with

     `git diff --color-moved=dimmed-zebra --ignore-all-space`

───────────────────────────────────────
commit 4ad4abcf07efefafd439b28679dff8d6bbf62943
Author: John Newbery <john@johnnewbery.com>
Date:   Mon Mar 29 11:36:19 2021 +0100

    [net] Change addr send times fields to be guarded by new mutex

----

We learn now that John also originally added this to _net.{cpp|h}_, before later moving it into _net_processing.{cpp|h}_ as part of a push to separate out `addr` relay data and logic from _net.cpp_.

==== git log -p

`git log -p` (usually also given with a file name argument) follows each commit message with a _patch_ (diff) of the changes made by that commit to that file (or files).
This is similar to `git blame` except that `git blame` shows the source of only lines _currently_ in the file.

==== git log -L

The `-L` parameter provided to git log will allow you to trace certain lines of a file through a range given by `<start,<end>`.

However, newer versions of git will also allow you to provide `git log -L` with a function name and a file, using:

[source,shell]
----
git log -L :<funcname>:<file>
----

This will then display commits which modified this function in your pager.

==== git log --follow _file..._

One of the most famous https://github.com/bitcoin/bitcoin/pull/9260[file renames^] was _src/main.{h,cpp}_ to _src/validation.{h,cpp}_ in 2016.
If you simply run `git log src/validation.h`, the oldest displayed commit is one that implemented the rename.
`git log --follow src/validation.h` will show the same recent commits followed by the older _src/main.h_ commits.

To see the history of a file that's been removed, specify " -- " before the file name, such as:
[source,bash]
----
git log -- some_removed_file.cpp
----

==== PR discussion

To get even more context on the change we can leverage GitHub and take a look at the comments on the PR where this mutex was introduced (or at any subsequent commit where it was modified).
To find the PR you can either paste the commit hash (`4ad4abcf07efefafd439b28679dff8d6bbf62943`) into GitHub, or list merge commits in reverse order, showing oldest merge with the commit at the top to show the specific PR number e.g.:

[source,bash,options=nowrap]
----
$ git log --merges --reverse --oneline --ancestry-path 4ad4abcf07efefafd439b28679dff8d6bbf62943..upstream | head -n 1

d3fa42c79 Merge bitcoin/bitcoin#21186: net/net processing: Move addr data into net_processing
----

Reading up on https://github.com/bitcoin/bitcoin/pull/21186[PR#21186^] will hopefully provide us with more context we can use.

[example]
====
We can see from the linked https://github.com/bitcoin/bitcoin/issues/19398#issue-646725848[issue 19398^] what the motivation for this move was.
====

=== Building from source

When building Bitcoin Core from source, there are some platform-dependant instructions to follow.

To learn how to build for your platform, visit the Bitcoin Core https://github.com/bitcoin/bitcoin/tree/master/doc[bitcoin/doc^] directory, and read the file named "build-\*.md", where "*" is the name of your platform.
For windows this is "build-windows.md", for macOS this is "build-osx.md" and for most linux distributions this is "build-unix.md".

There is also a guide by Jon Atack on how to https://jonatack.github.io/articles/how-to-compile-bitcoin-core-and-run-the-tests[compile and test Bitcoin Core^].

==== Cleaner builds

It can be helpful to use a separate build directory e.g. `build/` when compiling from source.
This can help avoid spurious Linker errors without requiring you to run `make clean` often.

From within your Bitcoin Core source directory you can run:

[source,bash]
----
# Clean current source dir in case it was already configured
make distclean

# Make new build dir
mkdir build && cd build

# Run normal build sequence with amended path
../autogen.sh
../configure --your-normal-options-here
../make -j `nproc`
../make check
----

=== Codebase documentation

Bitcoin Core uses https://www.doxygen.nl/index.html[Doxygen^] to generate developer documentation automatically from its annotated C++ codebase.
Developers can access documentation of the current release of Bitcoin Core online at https://doxygen.bitcoincore.org/[doxygen.bitcoincore.org^], or alternatively can generate documentation for their current git `HEAD` using `make docs` (see https://github.com/bitcoin/bitcoin/tree/master/doc/developer-notes.md#generating-documentation[Generating Documentation^] for more info).

=== Testing

Three types of test network are available:

1. Testnet
2. Regtest
3. Signet

These three networks all use coins of zero value, so can be used experimentally.

They primary differences between the networks are as follows:

.Comparison of different test networks
[cols="1h,1,1,1"]
|===================================================================================================================================
| Feature                   | Testnet                        | Regtest                       | Signet

| Mining algorithm          | Public hashing with difficulty | Local hashing, low difficulty | Signature from authorized signers
| Block production schedule | Varies per hashrate            | On-demand                     | Reliable intervals (default 2.5 mins)
| P2P port                  | 18333                          | 18444                         | 38333
| RPC port                  | 18332                          | 18443                         | 38332
| Peers                     | Public                         | None                          | Public
| Topology                  | Organic                        | Manual                        | Organic
| Chain birthday            | 2011-02-02                     | At time of use                | 2020-09-01
| Can initiate re-orgs      | If Miner                       | Yes                           | No
| Primary use               | Networked testing              | Automated integration tests   | Networked testing
|===================================================================================================================================

==== Signet

Signet is both a tool that allows Developers to create their own networks for testing interactions between different Bitcoin software, and the name of the most popular of these public testing networks.
Signet was codified in https://github.com/bitcoin/bips/tree/master/bip-0325.mediawiki[BIP 325^].

To connect to the "main" Signet network, simply start bitcoind with the signet option, e.g. `bitcoind -signet`.
Don't forget to also pass the signet option to `bitcoin-cli` if using it to control bitcoind, e.g. `bitcoin-cli -signet your_command_here`.
Instructions on how to setup your own Signet network can be found in the Bitcoin Core Signet https://github.com/bitcoin/bitcoin/tree/master/contrib/signet/README.md[README.md^].
The Bitcoin wiki Signet https://en.bitcoin.it/wiki/Signet[page^] provides additional background on Signet.

==== Regtest

Another test network named _regtest_, which stands for _regression test_, is also available.
This network is enabled by starting bitcoind with the `-regtest` option.
This is an entirely self-contained mode, giving you complete control of the state of the blockchain.
Blocks can simply be mined on command by the network operator.

The https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc[functional tests^] use this mode, but you can also run it manually.
It provides a good means to learn and experiment on your own terms.
It's often run with a single node but may be run with multiple co-located (local) nodes (most of the functional tests do this).
The blockchain initially contains only the genesis block, so you need to mine >100 blocks in order to have any spendable coins from a mature coinbase.
Here's an example session (after you've built `bitcoind` and `bitcoin-cli`):

[source,bash,options="nowrap"]
----
$ mkdir -p /tmp/regtest-datadir
$ src/bitcoind -regtest -datadir=/tmp/regtest-datadir
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getblockchaininfo
{
  "chain": "regtest",
  "blocks": 0,
  "headers": 0,
  "bestblockhash": "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206",
  _(...)_
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir createwallet testwallet
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir generate 3
{
  "address": "bcrt1qpw3pjhtf9myl0qk9cxt54qt8qxu2mj955c7esx",
  "blocks": [
    "6b121b0c094b5e107509632e8acade3f6c8c2f837dc13c72153e7fa555a29984",
    "5da0c549c3fddf2959d38da20789f31fa7642c3959a559086436031ee7d7ba54",
    "3210f3a12c25ea3d8ab38c0c4c4e0d5664308b62af1a771dfe591324452c7aa9"
  ]
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getblockchaininfo
{
  "chain": "regtest",
  "blocks": 3,
  "headers": 3,
  "bestblockhash": "3210f3a12c25ea3d8ab38c0c4c4e0d5664308b62af1a771dfe591324452c7aa9",
  _(...)_
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir getbalances
{
  "mine": {
    "trusted": 0.00000000,
    "untrusted_pending": 0.00000000,
    "immature": 150.00000000
  }
}
$ src/bitcoin-cli -regtest -datadir=/tmp/regtest-datadir stop
----

You may stop and restart the node and it will use the existing state.
(Simply remove the data directory to start again from scratch.)

==== Manual testing while running a functional test

Running regtest as described allows you to start from scratch with an empty chain, empty wallet, and no existing state.

An effective way to use regtest is to start a https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc[functional test^] and insert a python debug breakpoint.
You can set a breakpoint in a test by adding `import pdb; pdb.set_trace()` at the desired stopping point; when the script reaches this point you'll see the debugger's `(Pdb)` prompt, at which you can type `help` and see and do all kinds of useful things.

While the (Python) test is paused, you can still control the node using `bitcoin-cli`.
First you need to look up the data directory for the node(s), as below:

[source,bash,options=nowrap]
----
$ ps alx | grep bitcoind
0  1000   57478   57476  20   0 1031376 58604 pipe_r SLl+ pts/10    0:06 /g/bitcoin/src/bitcoind -datadir=/tmp/bitcoin_func_test_ovsi15f9/node0 -logtimemicros -debug (...)
0  1000   57479   57476  20   0 965964 58448 pipe_r SLl+ pts/10     0:06 /g/bitcoin/src/bitcoind -datadir=/tmp/bitcoin_func_test_ovsi15f9/node1 -logtimemicros -debug (...)
----

With the `-datadir` path you can look at the `bitcoin.conf` files within the data directories to see what config options are being specified for the test (there's always `regtest=1`) in addition to the runtime options, which is a good way to learn about some advanced uses of regtest.

In addition to this, we can use the `-datadir=` option with `bitcoin-cli` to control specific nodes, e.g.:

[source,bash,options=nowrap]
----
$ src/bitcoin-cli -datadir=/tmp/bitcoin_func_test_ovsi15f9/node0 getblockchaininfo
----

////
Add `import time; time.sleep(600)` somewhere into a functional test (which is just a Python script) to suspend the test at that point for 10 minutes. (you may want to add a `print("paused")` statement just before the call to `sleep()` to know it's been reached)

This has the further advantage (over calling `time.sleep()`), in that you can single-step through the test while also manually interacting with the nodes, combining automated and manual testing.

////

=== Getting started with development

One of the roles most in-demand from the project is that of code review, and in fact this is also one of the best ways of getting familiarized with the codebase too!
Reviewing a few PRs and adding your review comments to the PR on GitHub can be really valuable for you, the PR author and the bitcoin community.
This https://testing.googleblog.com/2018/05/code-health-understanding-code-in-review.html[Google Code Health^] blog post gives some good advice on how to go about code review and getting past "feeling that you're not as smart as the programmer who wrote the change".
If you're going to ask some questions as part of review, try and keep questions https://testing.googleblog.com/2019/11/code-health-respectful-reviews-useful.html[respectful^].

There is also a Bitcoin Core PR https://bitcoincore.reviews/[Review Club^] held weekly on IRC which provides an ideal entry point into the Bitcoin Core codebase.
A PR is selected, questions on the PR are provided beforehand to be discussed on irc.libera.chat #bitcoin-core-pr-reviews IRC room and a host will lead discussion around the changes.

Aside from review, there are 3 main avenues which might lead you to submitting your *own* PR to the repository:

. Finding a `good first issue`, as tagged in the https://github.com/bitcoin/bitcoin/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22[issue tracker^]
. Fixing a bug
. Adding a new feature (that you want for yourself?)

Choosing a "good first issue" from an area of the codebase that seems interesting to you is often a good approach.
This is because these issues have been somewhat implicitly "concept ACKed" by other Contributors as "something that is likely worth someone working on".
Don't confuse this for meaning that if you work on it that it is certain to be merged though.

If you don't have a bug fix or new feature in mind and you're struggling to find a good first issue which looks suitable for you, don't panic.
Instead keep reviewing other Contributors' PRs to continue improving your understanding of the process (and the codebase) while you watch the Issue tracker for something which you like the look of.

When you've decided what to work on it's time to take a look at the current behaviour of that part of the code and perhaps more importantly, try to understand _why_ this was originally implemented in this way.
This process of codebase "archaeology" will prove invaluable in the future when you are trying to learn about other parts of the codebase on your own.

=== #bitcoin-core-dev IRC channel

The Bitcoin Core project has an IRC channel `#bitcoin-core-dev` available on the Libera.chat network.
If you are unfamiliar with IRC there is a short guide on how to use it with a client called Matrix https://hackmd.io/ZcCoEDnOSTSqb2RDa7fB8Q[here^].
IRC clients for all platforms and many terminals are available.

"Lurking" (watching but not talking) in the IRC channel can both be a great way to learn about new developments as well as observe how new technical changes and issues are described and thought about from other developers with an adversarial mindset.
Once you are comfortable with the rules of the room and have questions about development then you can join in too!

[NOTE]
====
This channel is reserved for discussion about _development of the Bitcoin Core software only_, so please don't ask general Bitcoin questions or talk about the price or other things which would be off topic in there.

There are plenty of other channels on IRC where those topics can be discussed.
====

There are also regular meetings held on #bitcoin-core-dev which are free and open for anyone to attend.
Details and timings of the various meetings are found https://bitcoincore.org/en/meetings/[here^].

=== Communication

In reality there are no hard rules on choosing a discussion forum, but in practice there are some common conventions which are generally followed:

* If you want to discuss the codebase of the Bitcoin Core implementation, then discussion on either the GitHub repo or IRC channel is usually most-appropriate.
* If you want to discuss changes to the core bitcoin protocol, then discussion on the mailing list is usually warranted to solicit feedback from (all) bitcoin developers, including the many of them that do not work on Bitcoin Core directly.
** If mailing list discussions seem to indicate interest for a proposal, then creation of a BIP usually follows.

If discussing something Bitcoin Core-related, there can also be a question of whether it's best to open an Issue, to first discuss the problem and brainstorm possible solution approaches, or whether you should implement the changes as you see best first, open a PR, and then discuss changes in the PR.
Again, there are no hard rules here, but general advice would be that for potentially-controversial subjects, it might be worth opening an Issue first, before (potentially) wasting time implementing a PR fix which is unlikely to be accepted.

Regarding communication timelines it is important to remember that many contributors are unpaid volunteers, and even if they are sponsored or paid directly, nobody owes you their time.
That being said, often during back-and-forth communication you might want to nudge somebody for a response and it's important that you do this in a courteous way.
There are again no hard rules here, but it's often good practice to give somebody on the order of a few days to a week to respond.
Remember that people have personal lives and often jobs outside of Bitcoin development.

==== ACK / NACK

If you are communicating on an Issue or PR, you might be met with "ACK"s and "NACK"s (or even "approach (N)ACK" or similar).
ACK, or "acknowledge" generally means that the commenter approves with what is being discussed previously.
NACK means they tend to not approve.

What should you do if your PR is met with NACKs or a mixture of ACKs and NACKs?
Again there are no hard rules but generally you should try to consider all feedback as constructive criticism.
This can feel hard when veteran contributors appear to drop by and with a single "NACK" shoot down your idea, but in reality it presents a good moment to pause and reflect on _why_ someone is not agreeing with the path forward you have presented.

Although there are again no hard "rules" or "measurement" systems regarding (N)ACKs, maintainers -- who's job it is to measure whether a change has consensus before merging -- will often use their discretion to attribute more weight behind the (N)ACKs of contributors that they feel have a good understanding of the codebase in this area.

This make sense for many reasons, but lets imagine the extreme scenario where members of a Reddit/Twitter thread (or other group) all "https://www.dictionary.com/e/slang/brigading/[brigade]" a certain pull request on GitHub, filling it with tens or even hundreds of NACKs...
In this scenario it makes sense for a maintainer to somewhat reduce the weighting of these NACKs vs the (N)ACKs of regular contributors:

We are not sure which members of this brigade:

* Know how to code and with what competency
* Are familiar with the Bitcoin Core codebase
* Understand the impact and repercussions of the change

Whereas we can be more sure that regular contributors **and** those respondents who are providing additional rationale in addition to their (N)ACK, have some understanding of this nature.
Therefore it make sense that we should weight regular contributors' responses, and those with additional compelling rationale, more heavily than GitHub accounts created yesterday which reply with a single word (N)ACK.

From this extreme example we can then use a sliding scale to the other extreme where, if a proven expert in this area is providing a lone (N)ACK to a change, that we should perhaps step back and consider this more carefully.

Does this mean that your views as a new contributor are likely to be ignored?
**No**!!
However it might mean that you might like to include rationale in any ACK/NACK comments you leave on PRs, to give more credence to your views.

When others are (N)ACK-ing your work, you should not feel discouraged because they have been around longer than you.
If they have not left rationale for the comment, then you should ask them for it.
If they have left rationale but you disagree, then you can politely state your reasons for disagreement.

In terms of choosing a tone, the best thing to do it to participate in PR review for a while and observe the tone used in public when discussing changes.

=== Backports

Bitcoin Core often backports fixes for bugs and soft fork activations into previous software releases.

Generally maintainers will handle backporting for you, unless for some reason the process will be too difficult.
If this point is reached a decision will be made on whether the backport is abandoned, or a specific (new) fix is created for the older software version.

== Reproducible Guix builds

Bitcoin Core uses the https://guix.gnu.org/[Guix^] package manager to achieve reproducible builds.
Carl Dong gave an introduction to GUIX via a https://btctranscripts.com/breaking-bitcoin/2019/bitcoin-build-system/[remote talk^] in 2019, and also discussed it further on a ChainCode https://btctranscripts.com/chaincode-labs/chaincode-podcast/2020-11-30-carl-dong-reproducible-builds/[podcast^] episode.

There are official https://github.com/bitcoin/bitcoin/blob/master/contrib/guix/README.md[instructions^] on how to run a Guix build in the Bitcoin Core repo which you should certainly follow for your first build, but once you have managed to set up the Guix environment (along with e.g. MacOS SDK), hebasto provides a more concise workflow for subsequent or repeated builds in his https://gist.github.com/hebasto/7293726cbfcd0b58e1cfd5418316cee3[gist^].

== Software Life-cycle

An overview of the software life-cycle for Bitcoin Core can be found at https://bitcoincore.org/en/lifecycle/

////
== Solo work

:bip-extensions-mail: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019457.html
:core-dev-08-26: https://www.erisian.com.au/bitcoin-core-dev/log-2021-08-26.html

* Read lsilva01's https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc[1.0 Bitcoin Architecture]. Particularly sections:
** Executables
** https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.1_regions.asciidoc[Regions] (and all sub-sections)

TODO: Add questions on current architecture of Core

////

== Organisation & roles

The objective of the Bitcoin Core Organisation is to represent an entity that is decentralized as much as practically possible on a centralised platform
One where no single Contributor, Member, or Maintainer has unilateral control over what is/isn't merged into the project.
Having multiple Maintainers, Members, Contributors, and Reviewers gives this objective the best chance of being realised.

=== Contributors

Anyone who contributes code to the codebase is labelled a Contributor by GitHub and also by the community.
As of Version 23.0 of Bitcoin Core, there are > 850 individual Contributors credited with changes.

=== Members

Some Contributors are also labelled as Members of the https://github.com/orgs/bitcoin/people[Bitcoin organisation^].
There are no defined criteria for becoming a Member of the organisation; persons are usually nominated for addition or removal by current Maintainer/Member/Admin on an ad-hoc basis.
Members are typically frequent Contributors/Reviewers and have good technical knowledge of the codebase.

Some members also have some additional permissions over Contributors, such as adding/removing tags on issues and Pull Requests (PRs); however, being a Member **does not** permit you to merge PRs into the project.
Members can also be assigned sections of the codebase in which they have specific expertise to be more easily requested for review as Suggested Reviewers by PR authors.

////
NOTE: It is neither necessary nor desirable to "request reviews" from suggested reviewers in a normal workflow. Doing so without a good reason might be interpreted as being pushy and having the opposite result than intended.
////

=== Maintainers

Some organisation Members are also project Maintainers.
The number of maintainers is arbitrary and is subject to change as people join and leave the project, but has historically been less than 10.
PRs can only be merged into the main project by Maintainers.
While this might give the illusion that Maintainers are in control of the project, the Maintainers' role dictates that they *should not* be unilaterally deciding which PRs get merged and which don't.
Instead, they should be determining the mergability of changes based primarily on the reviews and discussions of other Contributors on the GitHub PR.

Working on that basis, the Maintainers' role becomes largely _janitorial_.
They are simply executing the desires of the community review process, a community which is made up of a decentralized and diverse group of Contributors.

////
A list of Maintainers and suggested Reviewers can be found in the https://github.com/bitcoin/bitcoin/tree/master/REVIEWERS[REVIEWERS^] document.
As the document states, these are *not* the only people who should be reviewing PRs.
The project needs as many reviews on each PR as possible, ideally from a diverse range of Reviewers.
////

=== Organisation fail-safes

It is possible for a "rogue PR" to be submitted by a Contributor; we rely on systematic and thorough peer review to catch these.
There has been https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019490.html[discussion^] on the mailing list about purposefully submitting malicious PRs to test the robustness of this review process.

In the event that a Maintainer goes rogue and starts merging controversial code, or conversely, _not_ merging changes that are desired by the community at large, then there are two possible avenues of recourse:

. Have the Lead Maintainer remove the malicious Maintainer
. In the case that the Lead Maintainer themselves is considered to be the rogue agent: fork the project to a new location and continue development there.

In the case that GitHub itself becomes the rogue entity, there have been numerous discussions about how to move away from GitHub, which have been summarized on the devwiki https://github.com/bitcoin-core/bitcoin-devwiki/wiki/GitHub-alternatives-for-Bitcoin-Core[here^].
This summary came in part from discussions on https://github.com/bitcoin/bitcoin/issues/20227[this^] GitHub issue.

== BIPs

Bitcoin uses Bitcoin Improvement Proposals (BIPs) as a design document for introducing new features or behaviour into bitcoin.
Bitcoin Magazine describes what a BIP is in their article https://bitcoinmagazine.com/guides/what-is-a-bitcoin-improvement-proposal-bip[What Is A Bitcoin Improvement Proposal (BIP)^], specifically highlighting how BIPs are not necessarily binding documents required to achieve consensus.

The BIPs are currently hosted on GitHub in the bitcoin/bips https://github.com/bitcoin/bips[repo^].

[TIP]
.BIP process
====
The BIPs include https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki[BIP 2^] which self-describes the BIP process in more detail.
Of particular interest might be the sections https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki#BIP_types[BIP Types^] and https://github.com/bitcoin/bips/tree/master/bip-0002.mediawiki#BIP_workflow[BIP Workflow^].
====

=== What does having a BIP number assigned to an idea mean

Bitcoin Core https://github.com/bitcoin/bitcoin/pull/22665[issue #22665^] described how BIP125 was not being strictly adhered to by Bitcoin Core.
This raised discussion amongst developers about whether the code (i.e. "the implementation") or the BIP itself should act as the specification, with most developers expressing that they felt that "the code was the spec" and any BIP generated was merely a design document to aid with re-implementation by others, and should be corrected if necessary.

NOTE: This view was not completely unanimous in the community.

For consensus-critical code most Bitcoin Core Developers consider "the code is the spec" to be the ultimate source of truth, which is one of the reasons that recommending running other full node implementations can be so difficult.
A knock-on effect of this was that there were calls for review on BIP2 itself, with respect to how BIPs should be updated/amended.
Newly-appointed BIP maintainer Karl-Johan Alm (a.k.a. kallewoof) posted his thoughts on this to the https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019457.html[bitcoin-dev mailing list^].

In summary a BIP represents a design document which should assist others in implementing a specific feature in a compatible way.
These features are optional to usage of Bitcoin, and therefore implementation of BIPs are not required to use Bitcoin, only to remain compatible.
Simply being _assigned_ a BIP does *not* mean that an idea is endorsed as being a "good" idea, only that it is fully-specified in a way that others could use to re-implement.
Many ideas are assigned a BIP and then never implemented or used on the wider network.

////
== Group work

=== Signet

Either:

* One member of the group create a private signet as documented on the Bitcoin Wiki https://en.bitcoin.it/wiki/Signet#Custom_Signet[Custom Signet] page.
* Distribute the `signetchallenge` value
* One or all group members can act as Signet miners
* Have all group members connect in to the custom signet
* Some notes on this https://hackmd.io/KLaH9u6iTBuNokLhgJ0lnA[here].

OR:

* Group members request some signet coins from the https://signet.bc-2.jp/[signet faucet] or using the https://github.com/bitcoin/bitcoin/tree/master/contrib/signet#getcoinspy[getcoins.py] script.
+
NOTE: The Signet `getcoins.py` script may not work if a captcha has been added to the site.

THEN:

* Send coins around the group

== Practice

=== Research topics/questions

* What stops a hacker hijacking the Bitcoin Core website and hosting malicious binaries?
** How about malicious binaries hosted by linux package managers?
* Where can you go for help if Bitcoin Core doesn't build on your machine?
* Before you create a PR to the main bitcoin core repo, what checks should you do locally?
** Are there any additional checks you can think of which are only run in the bitcoin core repo (and not your fork)?

=== Solo work

.

==== Git exercises

* Understand lsilva01's https://github.com/lsilva01/operating-bitcoin-core-v1/blob/main/git-tutorial.md[git tutorial for Bitcoin Core]
* https://chris.beams.io/posts/git-commit/[Write good commit messages]

==== GitHub workflow basics

* Fork the https://github.com/bitcoin/bitcoin[bitcoin core repository]
** GitHub provides a guide on how to https://guides.github.com/activities/forking/[fork a project]
* Download a clone of your fork of the bitcoin project to your local machine
* Checkout a tag, branch or PR

==== Building bitcoin from source

* Compile the source code you cloned
* Run the tests
. https://github.com/bitcoin/bitcoin/tree/master/test[Project test overview]
. https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc[Functional test suite]
. Also see https://github.com/bitcoin/bitcoin/tree/master/test#running-the-tests[Bitcoin Core, running the tests]
. https://github.com/bitcoin/bitcoin/tree/master/src/test/README.md[Bitcoin Core, unit tests]

==== Cross-Compile Bitcoin Core

Bitcoin Core has a build system that allows for cross-compiling to various systems.
More on this system can be found under the https://github.com/bitcoin/bitcoin/tree/master/depends[bitcoin/depends] sub-directory.

* Starting from a Linux Host or Virtual Machine, take a look at the depends https://github.com/bitcoin/bitcoin/tree/master/depends#readme[README].
* Install the necessary dependencies for cross-compilation to Windows
* Follow the instructions and cross-compile for Windows
* Run and test the cross-compiled binary on a Windows host or Virtual Machine

==== Review a PR

* Find a PR (which can be open or closed) on GitHub which looks interesting and/or accessible
* Checkout the PR locally
* Review the changes
** Record any questions that arise during code review
* Build the PR
* Test the PR
* Break a test / add a new test
* Leave review feedback on GitHub, possibly including:
** ACK/NACK
** Approach
** How you reviewed it
** Your system specifications if relevant
** Suggesting nits

==== Create a test using test framework

* You can refer to the https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/functional_test_framework.asciidoc[Functional Test Framework] doc
* Try and write a new functional test which can send p2p messages between nodes
+
TIP: starting with `ping` and `pong` messages might be easiest
* Try writing a more advanced test

=== Group work

* Each submit a PR on a team member's fork of Bitcoin Core (not the main repo)
* Review a different team member's PR
* Submit your review of the PR as a GitHub comment on the PR

////

