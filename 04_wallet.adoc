= Wallet

TIP: This section has been updated to Bitcoin Core @ https://github.com/bitcoin/bitcoin/tree/v23.0[v23.0^]

Bitcoin Core includes an optional wallet component.
The wallet allows users to make and receive transactions using their own node, so that they can validate incoming payment against their own node.

The wallet component has the following general aims:

. Have best-in-class security
** Be extremely well tested
** Be reviewed by competent developers
. Have good privacy by default
. Be smart about coin selection with respect to:
** Transaction fees
** Privacy
. Implement state-of-the-art features:
** Taproot
** Wallet descriptors
** Miniscript
. Be backwards compatible with old (Bitcoin Core) wallet files where possible

Wallets can be one of two types, "legacy" or https://github.com/bitcoin/bitcoin/blob/v23.0/doc/descriptors.md["descriptor"^].

[TIP]
====
Bitcoin Core moved to descriptor wallets as they are unambiguous as to which public keys and scripts should be used.

They also simplify backups and make im/ex-porting wallet keys into other software less error-prone.
====

== Wallet overview

////
* https://github.com/chaincodelabs/bitcoin-core-onboarding/tree/main/1.1_regions.asciidoc#wallet_region[Bitcoin core onboarding - wallet/^] describes the main functions of a wallet, along with some differences between legacy and descriptor wallets.
////

****
Blockchain Commons provides some examples of https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/03_3_Setting_Up_Your_Wallet.md[Setting up a wallet] using the `bitcoin-cli tool.
****

=== Wallet Database

Wallets are stored on disk as databases, either using Berkeley Database (BDB) or sqlite format.

TIP: The version of BDB we used for the wallet is unmaintained, so new wallets should prefer sqlite format

The wallet is stored on disk as a Key Value store.

.Wallet database
[mermaid,target=wallet-database,format=svg,align="center"]
....
flowchart BT
   database["database\n(KV store)"]

    Transactions --> database
    Keys --> database
    Key_metadata --> database
    wallet_metadata --> database
    database -- load db --> CWallet
....

These are some of the https://github.com/bitcoin/bitcoin/blob/master/src/wallet/walletdb.cpp#L30-L62[records^] which help us regenerate a descriptor wallet (populating a `DescriptorScriptPubKeyMan` (DSPKM)) from the database:

[source,cpp,options=nowrap]
----
// walletdb.cpp
const std::string WALLETDESCRIPTOR{"walletdescriptor"};
const std::string WALLETDESCRIPTORCACHE{"walletdescriptorcache"};
const std::string WALLETDESCRIPTORLHCACHE{"walletdescriptorlhcache"};
const std::string WALLETDESCRIPTORCKEY{"walletdescriptorckey"};
const std::string WALLETDESCRIPTORKEY{"walletdescriptorkey"};
----

For Legacy wallets (populating a `LegacyScriptPubKeyMan` (LSPKM)) we use the records with `*.KEY` & `SCRIPT`.

Wallet metadata may include a `tipLocator` -- the most recent tip -- and a wallet `version` which is used in database upgrades.

To load the wallet we read the database by iterating the records and loading them to `CWallet`, using `ReadKeyValue()` to deserialize.

.Loading wallet records from the database
[cols="2,3"]
|===
|Record |Load point

|`DBKeys::TX`
|(Bitcoin) transactions end up in `mapWallet` via the call to `pwallet->LoadToWallet(hash, fill_wtx)`

|`DBKeys::KEY`
|Keys for legacy wallets are loaded into `CKey` or `Key`, then read into the appropriate SPKM (or one is created and keys added to it) using `pwallet->GetOrCreateLegacyScriptPubKeyMan()`.

a|`DBKeys::WALLETDESCRIPTOR` +
`DBKeys::WALLETDESCRIPTORCACHE` +
`DBKeys::WALLETDESCRIPTORLHCACHE` +
`DBKeys::WALLETDESCRIPTORKEY` +
`DBKeys::WALLETDESCRIPTORCKEY`

|Descriptor wallet information generally goes into `DescriptorScriptPubKeyMan`.

a|`DBKeys::NAME` +
`DBKeys::PURPOSE`

|Addresses go into `m_address_book`

|===

You can see where all the other DB records are deserialized to by examining the `ReadKeyValue()` https://github.com/bitcoin/bitcoin/blob/master/src/wallet/walletdb.cpp#L321-L746[function].

The various `*ScriptPubkeyMan` objects are all owned by the `CWallet` instance eventually, however `LegacyScriptPubKeyMan` is both created and owned by `CWallet`, whereas `DescriptorScriptPubKeyMan` is created externally to `CWallet` and only after loading exists in the `CWallet` context.

Note that `TxSpends` is **not** tracked in the wallet database (and loaded at startup), but instead is rebuilt from scratch because it's fast to do so and we must reload every transaction anyway, so it's not much more work to regenerate `TxSpends` at the same time.
////
TODO: Why do we reload every transaction anyway ^?
////

=== Key-type classes in the wallet

There are a number of `Key` classes in the wallet code and keeping track of their functions can be confusing at times due to naming similarities.
Below are listed some of these classes along with some primary functions.

[id=wallet-key-types]
****
[horizontal]
`CKey`:: An encapsulated private key. Used for signing and deriving child keys.
`CKeyID`:: A _reference_ to a `CKey` by the hash160 of its pubkey. Used for key lookups when fetching keys e.g. for signing.
`CPrivKey`:: A serialized (OpenSSL format) private key with associated parameters. Used to read/write private keys to/from the database.
`CPubKey`:: A public key. Used in many places.
`CExtKey`:: An extended public key (includes private key and chaincode). Used for deriving BIP32 child keys.
`CMasterKey`:: Contains an encryption salt `vchSalt` and a randomly generated encryption key `vchCryptedKey`. The `CMasterKey` object itself is what is encrypted by the user's passphrase and the inner `vchCryptedKey` is what is used to en/de-crypt the wallet keys.
`CKeyingMaterial`:: Plain text which is to be encrypted or has been decrypted using the `CMasterKey`.
`CKeyPool`:: A single key which has been taken from a ``CWallet``'s keypool for use. `CKeyPool` keys are stored in the wallet database.
`CryptedKeyMap`:: A map of `CKeyID` to a pair of (`CPubKey` + an encrypted private key). Used to lookup keys (by `CKeyID`) when the wallet is encrypted.
****

=== Encryption

There is encryption in the wallet code, but it is found within both `CWallet` and `*ScriptPubKeyMan` so is not yet well encapsulated.

IMPORTANT: When encryption is enabled secret data must only ever reside in memory and should **never** be written to disk.

When you unlock an encrypted wallet you can set a `timeout`.
When the timeout expires secret data is deleted from memory, and the wallet "re-locked".

==== Decrypting the wallet

As detailed in <<wallet-key-types, Key Types>>, the `CMasterKey.vchCryptedKey` is the actual secret key used to en/de-crypt the keys in the wallet.

`CWallet` stores a `CMasterKey`, which is **not** a https://github.com/bitcoinbook/bitcoinbook/blob/173974f69e263c7de536a334224d642e6dca7d71/ch05.asciidoc#HDWalletFromSeed[master private key^].
The `CMasterKey` is encrypted by the user's passphrase.

When the user changes their passphrase, they are only changing the encryption applied to the `CMasterKey`, the inner `vchCryptedKey` is not changed.
This means that we do not have to read all items in the wallet database, decrypt them with the old key, encrypt them with the new key, and then write them, back to the database again.
Instead, we only have to change the encryption applied to the `CMasterKey`, which is much less error-prone, and more secure.

Each `CWallet` has a map of ``CMasterKey``s and when unlock is called it will try each one to see if it can decrypt and then unlock the wallet.

==== Encrypting the wallet

Only private keys are encrypted.
This allows us to watch for new transactions _without_ having to decrypt the wallet as each new block|transaction arrives.

Decrypting the Bitcoin Core wallet requires the user to enter their passphrase, so is not convenient to do at every new block.

When encrypting a wallet, a `CMasterKey` encryption key is generated, which is then sent to the `ScriptPubKeyMan` to encrypt using its `.Encrypt()` method.

Once the wallet is encrypted for the first time, we re-generate all of our keys.
This is to avoid the wallet using things which were not "born encrypted" in the future.
For `LegacyScriptPubKeyMan` this means creating a new HD seed, and for `DescriptorScriptPubKeyMan` 8 new descriptors.

If the wallet has already been used before -- while it existed in un-encrypted state -- the old ``ScriptPubKeyMan``'s are retained and so remain usable, but are not marked as `active`.
The wallet will switch to the new SPKM after encryption has completed by marking the new SPKM as `active`.

We take extra care during the encryption phase to either complete atomically or fail.
This includes database writes where we don't want to write half and crash, for example.
Therefore we will throw an assertion if the write fails.

[CAUTION]
====
When you instruct a BDB database to delete a record, they are actually kept but "marked as" deleted, and _might_ be fully deleted some time in the future.

This is not appropriate for our use case, for example when asking the DB to delete private keys after the wallet is encrypted for the first time.
Therefore we use some https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L758-L765[hacks^] so that when we request deletion of unencrypted private keys from the DB, they are properly deleted immediately and not "marked as" deleted.
====

[IMPORTANT]
====
When encryption is enabled secret data must only ever exist in decrypted form in memory.
====

=== Transaction tracking

When we learn about a new block the `BlockConnected` signal is https://github.com/bitcoin/bitcoin/blob/v23.0/src/validation.cpp#L2940[fired^] after successful validation.
This prompts the wallet to https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1317-L1328[iterate^] all inputs and outputs, calling `IsMine()` on all of them.
As part of the https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1100[check^], we https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1394-L1396[loop^] over the wallet's ``scriptPubkeyMan``s to check if any of the scripts belong to us.

If a script does belong to us, it will be inserted into `mapWallet` along with some metadata related to the time.
`mapWallet` contains all the transactions the wallet is interested in, including received and sent transactions.

When we https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L237[load^] a wallet into memory, we iterate all `TxSpends`.
`TxSpends` stores wallet transactions which were already spent and confirmed.

Therefore, when the wallet needs to select coins to spend, it can select from the coins:

`mapWallet - TxSpends - notMine`

=== Calculating a balance

For balance calculation we https://github.com/bitcoin/bitcoin/blob/master/src/wallet/receive.cpp#L293-L320[iterate^] `mapWallet` and add values to a `Balance` struct.

[source,cpp,options=nowrap]
----
struct Balance {
    CAmount m_mine_trusted{0};           //!< Trusted, at depth=GetBalance.min_depth or more
    CAmount m_mine_untrusted_pending{0}; //!< Untrusted, but in mempool (pending)
    CAmount m_mine_immature{0};          //!< Immature coinbases in the main chain
    CAmount m_watchonly_trusted{0};
    CAmount m_watchonly_untrusted_pending{0};
    CAmount m_watchonly_immature{0};
};
----

////
(does this call `availableCoins`?)
////

We do some caching during iteration so that we avoid re-calculating the same values for multiple transactions.

.Wallet balance terminology
[sidebar]
****
[horizontal]
`debit`:: amount out
`credit`:: amount in
`availableCredit`:: amount available to send out (not dirty or immature)
****

Calculating the above requires using `TxSpends` and `IsMine`.

When a new transaction involving the wallet takes place, really what happens is that it's marked as `DIRTY`, which deletes the cached entry for the parent transaction.
This means that the next time `GetBalance()` is called, `debit` is recalculated correctly.
https://bitcoincore.reviews/18113[This^] Bitcoin Core PR review club goes into more detail on coins being marked as `DIRTY` and `FRESH` in the cache.

`TxSpends` is calculated by looking at the outpoints in the transaction itself.

.`COutput` vs `COutPoint`
[sidebar]
****
[horizontal]
`COutPoint`:: a pair of `txid : index`, useful when you want to know which UTXO an input spends.
`COutput`:: created for coin selection and contains the entire previous UTXO (script, amount), along with helpers for calculating fees and effective value.
****

``COutput``s are ephemeral -- we create them, perform another operation with them and discard them.
They are stored in `availableCoins` which is recreated when calling functions such as `GetAvailableBalance()`, `ListCoins()` and `CreateTransactionInternal()`.

In a spending transaction all inputs have their corresponding `OutPoints`, and we map these to spending transactions in `TxSpends`.

IMPORTANT: We assume anything (i.e. transactions) that reach the wallet have already been validated by the node and we therefore blindly assume that it is valid in wallet code.

If a transaction is our own we check for validity with `testMempoolAccept` before submitting to the P2P network.

=== IsMine

For DSPKM running `IsMine()` is really simple: descriptors generate a list of ScriptPubKeys, and, if the SPK we are interested in is in the list, then it's ours.

`IsMine` returns an https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/ismine.h#L20-L49[enum^].
This is used as a return value, a filter and set of flags simultaneously.
There is more background on the general `IsMine` semantics in the v0.21.0 https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.21.0.md#ismine-semantics[release notes^].

LSPKM can have watch-only and spendable flags set at the same time, but DSPKM is either or, because descriptor wallets do not allow mixtures of spendable and watch-only keys in the same SPKM.
Because Legacy wallets are all key-based, we will need to see if a script _could have been generated by one of our keys_; what type of script it is; and if we have a (private) key for it.

For Legacy watch-only wallets we simply check "do we have this script stored as a script?" (where `CScripts` in the database are our watch-only scripts)".
If we don't have a `CKey` for a script but it exists in `mapScripts` then it's implicitly watch-only.

A problem with this current method of `IsMine` for legacy wallets is that it's tough to figure out what your wallet considers "Mine" -- it's probably a finite set, but maybe not...

Another consideration is that the LSPKM `IsMine` includes P2PK outputs -- which don't have addresses!
This un-enumerability can be an issue in migration of Legacy to Descriptor wallets.

There is also the possibility that someone can mutate address to different address type and you will still see it as `IsMine`. E.g. mutate P2PK into P2PKH address and wallet will still detect.

With descriptors we only look for scripts explicitly.
With descriptor wallets `IsMine` might not recognise script hashes from scripts, because it was not told to watch for them and consider them as belonging to it.

We use the `IsMine` filters in many places, primarily to distinguish between spendable and watch-only:

`IsMine::All`:: spendable and watch-only (use for legacy wallet)
`IsMine::Used`:: not used by `IsMine`, but instead used as a filter for tracking when addresses have been reused.

[sidebar]
****
PR https://github.com/bitcoin/bitcoin/pull/19602[19602^] enables migration of legacy wallets -> descriptor wallets from Bitcoin Core version 24.0.
Although legacy wallets are now effectively end of life it's still relevant to have documentation for legacy wallets.
****

See the section on how wallets determine whether transactions belong to them using the <<ismine-enum,IsMine>> enum for more in-depth information.

=== Conflict tracking

Conflict tracking is related to changing the state as the mempool tells us about conflicting transactions.

`mapTxSpends` is a multimap which permits having the same `COutPoint` mapping to _two_ transactions. (i.e. two transactions spending the same input)
This is how we can tell if things are conflicted: look up an outpoint and check to see how many transactions are there, if > 1 then we know that there was a conflict.

If there is a conflict we can look up the wallet transaction and see what state it's in, and we can be sure about whether it is currently or previously conflicted.

Conflict tracking is particularly relevant for coin selection...
////
TODO: Why?
////

[id=coin-selection-overview]
=== Coin selection

See https://bitcoinops.org/en/topics/coin-selection/[Bitcoin Optech^] for more information on coin selection.
There is a section digging deeper into the coin selection code found <<coin-selection,below>>.
To select inputs to a transaction our primary considerations are privacy and fees.

The below sections form an overview of creating a transaction via `CreateTransactionInternal()`.

==== `AvailableCoins()`

The gist of how we generate a list of coins available to spend (via `AvailableCoins()`) is that we iterate `mapWallet` and check for coins that:

* Are not immature coinbase outputs
* Are not conflicted
* Must be at least in our mempool
* Not currently replacing or being replaced by another transaction
* Are not locked
* Are `IsMine`
* Are `spendable`

...and return them as a `std::vector<COutput>`.

[id=GroupOutputs]
==== `GroupOutputs()`

Once we have this vector of coins `GroupOutputs()` will turn them into ``OutputGroup``s.
An `OutputGroup` consists of outputs with the same script, i.e. "coins sent to the same address".

////
Effective Value is = Coins value - Fee
////

[id=selectCoins]
==== `selectCoins()`

If you manually choose inputs, it will add outputs to the transaction automatically.
It tries first to make sure that all outputs selected have 6 confirmations, if unsuccessful it then tries again with 1 confirmation as the lower bound.

For change outputs it starts with 1 confirmation and then again with 0.
If this is still unsuccessful it increases the number of ancestors and descendants that unconfirmed change can have.

==== `AttemptSelection()`

This function is orchestrating the <<GroupOutputs,Output group>> creation, and then the <<selectCoins,coin selection>>.
Currently, this is always based on the <<coin-selection,waste metric>>.

It is using 3 algorithms and then selecting the "best" of the three (based on the waste metric):

. Branch n bound (bnb)
. Knapsack
. Single Random Draw (SRD)

There is currently an idea that a limited SRD could replace Knapsack in the future.
Due to this plan for removal, it would not make sense to focus development effort on improving the Knapsack algorithm at this time.

=== Transaction creation

Once the coins have been selected they are returned back to `CreateTransactionInternal()`, which will create the final transaction.

Right now when we determine the change output, we don't use what `selectionResult` says the change output should be.
What we actually do is make the tx with in? outputs and set the change amount to be the sum inputs-outputs, so the change amount includes the transaction fee.
To get the correct change amount we now calculate the size of this after signing, we use dummysigner to add a dummy signature (74 0's and the correct script), and now we can calculate the correct fee.
We reduce that fee from the change output amount, and if this now goes below *some threshold?* (the "cost of change" thing from BnB) or if it is dust we drop the change output and add it's value to the fee.

So now we have an unsigned tx which we need to sign.

=== Signing

We pass the tx to `CWallet::SignTransaction()` which will call `IsMine()` on each input to figure out which ScriptPubKeyMan (spkman) owns that input, then ask the spkman to fetch its `SigningProviders` to provide the signer which can sign the transaction, and return that to us.

With PSBTs we have the `fillPSBT()` method in `CWallet` which calls `*ScriptPubKeyMan::fillPSBT()`.
We do this because we can add previous UTXOs due to transaction tracking; the SPKM adds the scripts and key derivation paths and will then optionally sign.

== Separation of wallet and node

Both the `bitcoind` and `bitcoin-qt` programs use the same source code for the wallet component.
`bitcoin-qt` is not therefore a gui frontend for `bitcoind` but a stand-alone binary which happens to share much of the same code.
There has been discussion since at least as early as 2014 about https://github.com/bitcoin/bitcoin/issues/3882[splitting wallet code^] out from the rest of the codebase, however this has not been completed yet.

The https://github.com/bitcoin-core/bitcoin-devwiki/wiki//Process-Separation[Process Separation^] project is tracking development working towards separating out node, wallet and GUI code even further.
In the mean time developers have preferred to focus on improving the organisation of the (wallet) source code within the project and to focus on making wallet code more asynchronous and independent of node code, to avoid locking the node while wallet code-paths are executing.

=== Wallet interfaces

In order to facilitate code separation, distinct interfaces between the node and the wallet have been created:

* The node holds a https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/interfaces.cpp#L114[`WalletImpl`^] interface to call functions on the wallet.
* The wallet holds a https://github.com/bitcoin/bitcoin/blob/v23.0/src/node/interfaces.cpp#L452[`ChainImpl`^] interface to call functions on the node.
* The node notifies the wallet about new transactions and blocks through the https://github.com/bitcoin/bitcoin/blob/v23.0/src/node/interfaces.cpp#L364[`CValidationInterface`^].

TIP: For more information on `*Impl` classes see <<pimpl-technique,PIMPL technique>> in the appendix.

== Wallet component initialisation

The wallet component is initialized via the `WalletInitInterface` class as specified in https://github.com/bitcoin/bitcoin/blob/v23.0/src/walletinitinterface.h#L14-L26[_src/walletinitinterface.h_^].
The member functions are marked as virtual in the `WalletInitInterface` definition, indicating that they are going to be overridden later by a derived class.

Both _wallet/init.cpp_ and _dummywallet.cpp_ include derived classes which override the member functions of `WalletInitInterface`, depending on whether the wallet is being compiled in or not.

The primary https://github.com/bitcoin/bitcoin/blob/v23.0/src/Makefile.am#L389-L394[_src/Makefile.am_^] describes which of these modules is chosen to override: if `./configure` has been run with the wallet feature enabled (default), then _wallet/init.cpp_ is added to the sources, otherwise (`./configure --disable-wallet`) _dummywallet.cpp_ is added:

.src/Makefile.am
[source,sh,options=nowrap]
----
if ENABLE_WALLET
libbitcoin_server_a_SOURCES += wallet/init.cpp
endif
if !ENABLE_WALLET
libbitcoin_server_a_SOURCES += dummywallet.cpp
endif
----

_src/walletinitinterface.h_ declares the global `g_wallet_init_interface`  which will handle the configured `WalletInitInterface`.

The wallet interface is created when the `Construct()` method is called on the `g_wallet_init_interface` object by https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1179-L1184[`AppInitMain()`^] in _init.cpp_.
`Construct` takes a reference to a `NodeContext` as argument, and then checks that the wallet has not been disabled by a runtime argument before calling `interfaces::MakeWalletLoader()` on the node.
This initialises a new `WalletLoader` object which is then added to the `node` object, both to the general list of `node.chain_clients` (wallet processes or other clients which want chain information from the node) in addition to being assigned as the unique `node.wallet_client` role, which specifies the particular `node.chain_client` that should be used to load or create wallets.

The `NodeContext` struct is defined as the following:

.src/node/context.h
[quote]
____
...contains references to chain state and connection state.

...used by init, rpc, and test code to pass object references around without needing to declare the same variables and parameters repeatedly, or to use globals...
The struct isn't intended to have any member functions.
It should just be a collection of references that can be used without pulling in unwanted dependencies or functionality.
____

== Wallets and program initialisation

Wallets can optionally be loaded as part of main program startup (i.e. from _src/init.cpp_).
Any wallets loaded during the life cycle of the main program are also unloaded as part of program shutdown.

=== Specifying wallets loaded at startup

Wallet(s) to be loaded as part of program startup can be specified by passing `-wallet=` or `-walletdir=` arguments to `bitcoind`/`bitcoin-qt`.
If the wallet has been compiled in but no `-wallet*=` arguments have been passed, then the default wallet directory (_$datadir/wallets_) will be checked as per `GetWalletDir()`:

Wallets can also be loaded after program startup via the `loadwallet` RPC.

=== VerifyWallets

Wallet verification refers to verification of the `-wallet` arguments as well as the underlying wallet database(s) on disk.

Wallets loaded via program arguments are first verified as part of `AppInitMain()` which first https://github.com/bitcoin/bitcoin/blob/v23.0/src/init.cpp#L1209-L1213[verifies wallet database integrity^] by calling https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/load.cpp#L25-L101[`VerifyWallets()`^] via the `WalletClientImpl` override of `client->verify()`.

`VerifyWallets()` takes an `interfaces::Chain` object as argument, which is currently used to send init and error messages (about wallet verification) back to the GUI.
`VerifyWallets()` starts by checking that the `walletdir` supplied by argument, or default of `""`, is valid.
Next it loops through all wallets it finds in the `walletdir` and adds them to an `std::set` called `wallet_paths`, first de-duplicating them by tracking their absolute paths, and then checking that  the `WalletDatabase` for each wallet exists (or is otherwise constructed successfully) and can be verified.

If this check passes for all wallets, then `VerifyWallets()` is complete and will return `true` to calling function `AppInitMain`, otherwise `false` will be returned.
If `VerifyWallets()` fails and returns `false` (due to a corrupted wallet database, but notably not due to an incorrect wallet path), the main program process `AppInit()` will be immediately interrupted and shutdown.

[IMPORTANT]
====
Program shutdown on a potentially-corrupt wallet database is a deliberate design decision.
This is so that the wallet cannot display information to the user which is not guaranteed by the database.
====

=== LoadWallets

"Startup" wallet(s) are loaded  when `client->load()` is called on each `node.chain_client` as part of https://github.com/bitcoin/bitcoin/tree/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/init.cpp#L1728-L1732[init.cpp^].

.src/init.cpp#AppInitMain()
[source,cpp,options=nowrap]
----
for (const auto& client : node.chain_clients) {
    if (!client->load()) {
        return false;
    }
}
----

The call to  `load()` on the wallet `chain_clients` has again been overridden, this time by ``WalletClientImpl``'s `LoadWallets()` https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/load.cpp#L103-L139[method^].
This function works similarly to `VerifyWallets()`, first creating the `WalletDatabase` (memory) object for each wallet, although this time skipping the verify step, before creating a `CWallet` object from the database and adding it to the global list of wallets, the vector `vpwallets`, by calling `AddWallet()`.

[IMPORTANT]
====
There are a number of steps in `init.cpp` that happen before the wallet is loaded, notably the blockchain is synced first.
This is a safeguard which means that wallet operations cannot be called on a wallet which has been loaded against stale blockchain data.
====

_init.cpp_ is run on a single thread.
This means that calls to wallet code block further initialisation of the node.

The `interfaces::Chain` object taken as argument by `LoadWallets()` is used to pass back any error messages, exactly as it was in <<VerifyWallets,`VerifyWallets()`>>.
More information on `AddWallet()` can be https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L110-L120[found in _src/wallet.cpp_].

=== StartWallets

The wallet is finally ready when (all) `chain_clients` have been started in _init.cpp_ which calls the overridden `client->start()` method from the `WalletClientImpl` class, resulting in https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/load.cpp#L141-L152[src/wallet/load.cpp#StartWallets()^] being called.

This calls the `GetWallets()` function which returns a vector of pointers to the interfaces for all loaded `CWallet` objects, called `vpwallets`.
As part of startup `PostInitProcess()` is called on each wallet which, after grabbing the main wallet lock `cs_wallet`, synchronises the wallet and mempool by adding wallet transactions not yet in a block to our mempool, and updating the wallet with any relevant transactions from the mempool.

Also, as part of `StartWallets`, `flushwallet` _might_ be scheduled (if configured by argument) scheduling wallet transactions to be re-broadcast every second, although this interval is https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L1869-L1912[delayed^] upstream with a random timer.

=== FlushWallets

All wallets loaded into the program are "flushed" (to disk) before shutdown.
As part of `init.cpp#Shutdown()` the `flush()` method is called on each member of `node.chain_clients` in sequence.
`WalletClientImpl` again overrides this method to call `wallet/load.cpp#FlushWallets()` which makes sure all wallet changes have been successfully flushed to the wallet database.

// TODO: Find out why we flush again here?
Finally the `stop()` method is called on each member of `node.chain_clients` which is overridden by `StopWallets()`, flushing again and this time calling `close()` on the database file.

== Wallet Locks

Grepping the _src/wallet_ directory for locks, conventionally of the form `cs_*`, yields ~500 matches.
For comparison the entire remainder of the codebase excluding _src/wallet/*_ yields almost 1000 matches.
Many of these matches are asserts and declarations, however this still illustrates that the wallet code is highly reliant on locks to perform atomic operations with respect to the current chain state.

=== The `cs_wallet` lock

In order to not block the rest of the program during wallet operations, each `CWallet` has its own recursive mutex `cs_wallet`:

NOTE: There is currently an https://github.com/bitcoin/bitcoin/issues/19303[issue^] tracking replacement of Recursive Mutexes with Mutexes, to make locking logic easier to follow in the codebase.

.src/wallet/wallet.h
[source,cpp,options=nowrap]
----
/*
 * Main wallet lock.
 * This lock protects all the fields added by CWallet.
 */
mutable RecursiveMutex cs_wallet;
----

Most wallet operations whether reading or writing data require the use of the lock so that atomicity can be guaranteed.
Some examples of wallet operations requiring the lock include:

. Creating transactions
. Signing transactions
. Broadcasting/committing transactions
. Abandoning transactions
. Bumping transaction (fees)
. Checking `IsMine`
. Creating new addresses
. Calculating balances
. Creating new wallets
. Importing new {priv|pub}keys/addresses
. Importing/dumping wallets

In addition to these higher level functions, most of ``CWallet``'s private member functions also require a hold on `cs_wallet`.

=== Other wallet locks

. _src/wallet/bdb.cpp_, which is responsible for managing BDB wallet databases on disk, has its own mutex `cs_db`.
. If external signers have been enabled (via `./configure --enable-external-signer`) then they too have their own mutex `cs_desc_man` which is acquired when descriptors are being setup.
. `BlockUntilSyncedToCurrentChain()` has a unique lock exclude placed on it to prevent the caller from holding `cs_main` during its execution, and therefore prevent a possible deadlock:
+
.src/wallet/wallet.h
[source,cpp,options=nowrap]
----
/**
 * Blocks until the wallet state is up-to-date to /at least/ the current
 * chain at the time this function is entered
 * Obviously holding cs_main/cs_wallet when going into this call may cause
 * deadlock
 */
void BlockUntilSyncedToCurrentChain() const LOCKS_EXCLUDED(::cs_main) EXCLUSIVE_LOCKS_REQUIRED(!cs_wallet);
----

== Controlling the wallet

As we can see wallet component startup and shutdown is largely driven from outside the wallet codebase from _src/init.cpp_.

Once the wallet component is started and any wallets supplied via argument have been verified and loaded, wallet functionality ceases to be called from _init.cpp_ and instead is controlled using external programs in a number of ways.
The wallet can be controlled using `bitcoin-cli` or `bitcoin-qt` GUI, and wallet files can be interacted with using the stand-alone `bitcoin-wallet` tool.

Both `bitcoind` and `bitcoin-qt` run a (JSON) RPC server which is ready to service, amongst other things, commands to interact with wallets.
The command line tool `bitcoin-cli` will allow interaction of any RPC server started by either `bitcoind` or `bitcoin-qt`.

TIP: If using `bitcoin-qt` there is also an RPC console built into the GUI or you can run with `-server=1` to allow access via `bitcoin-cli`.

If using the `bitcoin-qt` GUI itself then communication with the wallet is done directly via qt's https://github.com/bitcoin/bitcoin/blob/v23.0/src/qt/walletmodel.h#L51-L52[`WalletModel` interface^].

Commands which can be used to control the wallet via RPC are listed in https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/rpc/wallet.cpp#L662-L731[_rpcwallet.cpp_^].

=== Wallet via RPC

If we take a look at the https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/rpc/wallet.cpp#L195-L238[`loadwallet` RPC^] we can see similarities to ``WalletClientImpl``'s `LoadWallets()` function.

However this time the function will check the `WalletContext` to check that we have a wallet context (in this case a reference to a chain interface) loaded.
Next it will call https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L260-L271[`wallet.cpp#LoadWallet`^] which starts by grabbing `g_loading_wallet_mutex` and adding the wallet to `g_loading_wallet_set`, before calling https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/wallet.cpp#L227-L257[`LoadWalletInternal`^] which adds the wallet to `vpwallets` and sets up various event notifications.

Further operation of the wallet RPCs are detailed in their man pages, but one thing to take note of is that whilst `loadwallet()` (and `unloadwallet()`) both take a `wallet_name` argument, the other wallet RPCs do not.
Therefore in order to control a specific wallet from an instance of `bitcoin{d|-qt}` that has multiple wallets loaded, bitcoin-cli must be called with the `-rpcwallet` argument, to specify the wallet which the action should be performed against, e.g. `bitcoin-cli --rpcwallet=your_wallet_name getbalance`

=== Via `bitcoin-cli` tool

****
Blockchain Commons contains numerous guides and examples of controlling the wallet using `bitcoin-cli`, including:

* https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/04_0_Sending_Bitcoin_Transactions.md[Sending Bitcoin Transactions^] including using raw transactions
* https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/05_0_Controlling_Bitcoin_Transactions.md[Controlling Bitcoin Transactions^] using RBF and CPFP
* https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/06_0_Expanding_Bitcoin_Transactions_Multisigs.md[Using multisig^] to send and receive
* https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/07_0_Expanding_Bitcoin_Transactions_PSBTs.md[Creating and using PSBTs^] and integrating them with hardware wallets
* https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/08_0_Expanding_Bitcoin_Transactions_Other.md[Adding locktimes and OP_RETURN data^]
****

== CWallet

The `CWallet` object is the fundamental wallet representation inside Bitcoin Core.
`CWallet` stores transactions and balances and has the ability to create new transactions.
`CWallet` also contains references to the chain interface for the wallet along with storing wallet metadata such as `nWalletVersion`, wallet flags, wallet name and address book.

=== CWallet creation

The `CWallet` constructor takes a pointer to the chain interface for the wallet, a wallet name and a pointer to the underlying `WalletDatabase`:

The constructor is not called directly, but instead from the public function `CWallet::Create()`, which is itself called from `CreateWallet()`, `LoadWallets()` (or `TestLoadWallet()`).
In addition to the arguments required by the constructor, `CWallet::Create()` also has a `wallet_flags` argument.
Wallet flags are represented as a single `unit64_t` bit field which encode certain wallet properties:

.src/wallet/walletutil.h
[source,cpp,options=nowrap]
----
enum WalletFlags : uint64_t {
    WALLET_FLAG_AVOID_REUSE = (1ULL << 0),
    WALLET_FLAG_KEY_ORIGIN_METADATA = (1ULL << 1),
    WALLET_FLAG_DISABLE_PRIVATE_KEYS = (1ULL << 32),
    WALLET_FLAG_BLANK_WALLET = (1ULL << 33),
    WALLET_FLAG_DESCRIPTORS = (1ULL << 34),
    WALLET_FLAG_EXTERNAL_SIGNER = (1ULL << 35),
};
----

See https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/walletutil.h#L36-L70[_src/wallet/walletutil.h_^] for additional information on the meanings of the wallet flags.

`CWallet::Create()` will first attempt to create the `CWallet` object and load it, returning if any errors are encountered.

If `CWallet::Create` is creating a new wallet -- on its 'first run' -- the wallet version and wallet flags will be set, before either `LegacyScriptPubKeyMan` or ``DescriptorScriptPubKeyMan``'s are setup, depending on whether the `WALLET_FLAG_DESCRIPTORS` flag was set on the wallet.

Following successful creation, various program arguments are checked and applied to the wallet.
These include options such as `-addresstype`, `-changetype`, `-mintxfee` and `-maxtxfee` amongst others.
It is at this stage that warnings for unusual or unsafe values of these arguments are generated to be returned to the user.

After the wallet is fully initialized and setup, its keypool will be topped up before the wallet is locked and registered with the <<Validation interface>>, which will handle callback notifications generated during the (optional) upcoming chain rescan.
The rescan is smart in detecting the wallet "birthday" using metadata stored in the <<scriptpubkeymanagers,SPKM>> and won't scan blocks produced before this date.

Finally, the `walletinterface` is setup for the wallet before the `WalletInstance` is returned to the caller.

[id=scriptpubkeymanagers]
== ScriptPubKeyManagers (SPKM)

Each wallet contains one or more ``ScriptPubKeyManager``s which are derived from the https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/scriptpubkeyman.h#L166[base^] SPKM class and are in control of storing the ``scriptPubkey``s managed by that wallet.

****
"A wallet" in the general sense therefore becomes "a collection of ``ScriptPubKeyManager``s", which are each managing an address type.
****

In the current implementation, this means that a default (descriptor) wallet consists of 8 ``ScriptPubKeyManager``s, one SPKM for each combination shown in the table <<descriptor-spkmans,below>>.

[id=descriptor-spkmans]
.Descriptor wallet SPKMans
[%autowidth.stretch]
|===

|{nbsp} |LEGACY |P2SH-SEGWIT |BECH32 |BECH32M

|Receive
|✓
|✓
|✓
|✓


|Change
|✓
|✓
|✓
|✓

|===

Here is the _descriptor_ wallet code fragment which sets up an SPKM for each `OUTPUT_TYPE`:

.src/wallet/wallet.cpp#SetupDescriptorScriptPubKeyMans()
[source,cpp,options=nowrap]
----
// ...

for (bool internal : {false, true}) {
    for (OutputType t : OUTPUT_TYPES) {
        auto spk_manager = std::unique_ptr<DescriptorScriptPubKeyMan>(new DescriptorScriptPubKeyMan(*this));
        if (IsCrypted()) {
            if (IsLocked()) {
                throw std::runtime_error(std::string(__func__) + ": Wallet is locked, cannot setup new descriptors");
            }
            if (!spk_manager->CheckDecryptionKey(vMasterKey) && !spk_manager->Encrypt(vMasterKey, nullptr)) {
                throw std::runtime_error(std::string(__func__) + ": Could not encrypt new descriptors");
            }
        }
        spk_manager->SetupDescriptorGeneration(master_key, t, internal);
        uint256 id = spk_manager->GetID();
        m_spk_managers[id] = std::move(spk_manager);
        AddActiveScriptPubKeyMan(id, t, internal);
    }
}

// ...
----

By contrast a Legacy wallet will set up a **single** SPKM which will then be _aliased_ to a SPKM for each of the 6 `LEGACY_OUTPUT_TYPES`: `LEGACY`, `P2SH-SEGWIT` and `BECH32`.
This gives it the external appearance of 6 distinct SPKMans, when really it only has 1:

.src/wallet/wallet.cpp#SetupLegacyScriptPubKeyMan()
[source,cpp,options=nowrap]
----
// ...

auto spk_manager = std::unique_ptr<ScriptPubKeyMan>(new LegacyScriptPubKeyMan(*this));
for (const auto& type : LEGACY_OUTPUT_TYPES) {
    m_internal_spk_managers[type] = spk_manager.get();
    m_external_spk_managers[type] = spk_manager.get();
}
m_spk_managers[spk_manager->GetID()] = std::move(spk_manager);

// ...
----

SPKMans are stored in maps inside a `CWallet` according to output type.
"External" and "Internal" (SPKMans) refer to whether the addresses generated are designated for giving out "externally", i.e. for receiving new payments to, or for "internal", i.e. change addresses.

Prior to https://github.com/bitcoin/bitcoin/commit/c729afd0a3b74a3943e4c359270beaf3e6ff8a7b[c729afd0^] the equivalent SPKM functionality (fetching new addresses and signing transactions) was contained within `CWallet` itself, now however is split out for better maintainability and upgradability properties as brought about by the https://github.com/bitcoin-core/bitcoin-devwiki/wiki/Wallet-Class-Structure-Changes[wallet box class structure changes^].
Therefore `CWallet` objects no longer handle keys and addresses.

The change to a `CWallet` made up of (multiple) ``{Descriptor|Legacy}ScriptPubKeyMan``'s is also sometimes referred to as the "Wallet Box model", where each SPKM is thought of as a distinct "box" within the wallet, which can be called upon to perform new address generation and signing functions.

=== Keys in the wallet

==== Legacy wallet keys

Legacy wallets used the "keypool" model which stored a bunch of keys.
See https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/scriptpubkeyman.h#L52-L100[_src/wallet/scriptbpubkeyman.h_#L52-L100^] for historical context on the "keypool" model.

The wallet would then simply iterate over each public key and generate a scriptPubKey (a.k.a. PubKey script) and address for each type of script the wallet supported.
However this approach has a number of shortcomings (from least to most important):

. One key could have multiple addresses
. It was difficult to sign for multisig
. Adding new script functionality required adding new hardcoded script types into the wallet code _for each new type of script_.

Such an approach was not scalable in the long term and so a new format of wallet needed to be introduced.

==== Descriptor wallet keys

Descriptor wallets instead store output script "descriptors".
These descriptors can be of *any* valid script type, including arbitrary scripts which might be "unknown" to the wallet software, and this means that wallets can deterministically generate addresses for any type of valid descriptor provided by the user.

Descriptors not only contain what is needed to generate an address, they also include all the script template data needed to "solve" (i.e. spend) outputs received at them.
In other words they permit a valid `scriptSig` (`redeemScript` or `witnessScript`) to be generated.
The document https://github.com/bitcoin/bitcoin/blob/v23.0/doc/descriptors.md[Support for Output Descriptors in Bitcoin Core^] provides more details and examples of these output descriptors.

=== How wallets identify relevant transactions

==== 1. Receiving notifications about new transactions or new blocks

When a Bitcoin Core node learns about a new transaction, the wallet component needs to determine whether it's related to one of it's loaded ``CWallet``s.
The first thing to notice is that `CWallet` implements the `interfaces::Chain::Notifications`.

[source,cpp,options=nowrap]
----
class CWallet final : public WalletStorage, public interfaces::Chain::Notifications
----

This interface gives the wallet the ability to receive notifications such as `transactionAddedToMempool`, `transactionRemovedFromMempool`, `blockConnected` and so on.
The names of these methods are self-explanatory.

To register itself as notification client, the wallet has the `std::unique_ptr<interfaces::Handler> m_chain_notifications_handler` attribute and it is initialized in `CWallet::AttachChain(...)` method.

This method updates the wallet according to the current chain, scanning new blocks, updating the best block locator, and registering for notifications about new blocks and transactions. This is called when the wallet is created or loaded (`CWallet::Create(...)`).

[source,cpp,options=nowrap]
----
bool CWallet::AttachChain(const std::shared_ptr<CWallet>& walletInstance, interfaces::Chain& chain, const bool rescan_required, bilingual_str& error, std::vector<bilingual_str>& warnings)
{
    LOCK(walletInstance->cs_wallet);
    // allow setting the chain if it hasn't been set already but prevent changing it
    assert(!walletInstance->m_chain || walletInstance->m_chain == &chain);
    walletInstance->m_chain = &chain;

    walletInstance->m_chain_notifications_handler = walletInstance->chain().handleNotifications(walletInstance);
    // ...
}
----

This briefly explains how the wallet is able to listen to new transactions or blocks.
More information about the notification mechanism can be seen in the https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc#notifications-mechanism-validationinterface[Notifications Mechanism (ValidationInterface)^] section of https://github.com/chaincodelabs/bitcoin-core-onboarding/blob/main/1.0_bitcoin_core_architecture.asciidoc[Bitcoin Architecture^] article.

==== 2. Notification Handlers

The next step is to filter which transactions interest the wallet.

Four of these notification handlers are the ones that are relevant to filter transactions.
All of them call `CWallet::SyncTransaction(...)`.

[source,cpp,options=nowrap]
----
// src/wallet/wallet.h
void SyncTransaction(const CTransactionRef& tx, const SyncTxState& state, bool update_tx = true, bool rescanning_old_block = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);

// src/wallet/wallet.cpp
void CWallet::SyncTransaction(const CTransactionRef& ptx, const SyncTxState& state, bool update_tx, bool rescanning_old_block)
{
    if (!AddToWalletIfInvolvingMe(ptx, state, update_tx, rescanning_old_block))
        return; // Not one of ours

    // If a transaction changes 'conflicted' state, that changes the balance
    // available of the outputs it spends. So force those to be
    // recomputed, also:
    MarkInputsDirty(ptx);
}

void CWallet::transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {
    LOCK(cs_wallet);
    SyncTransaction(tx, TxStateInMempool{});
    // ...
}

void CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {
    // ...
    if (reason == MemPoolRemovalReason::CONFLICT) {
        // ...
        SyncTransaction(tx, TxStateInactive{});
    }
}

void CWallet::blockConnected(const CBlock& block, int height)
{
    // ...
    for (size_t index = 0; index < block.vtx.size(); index++) {
        SyncTransaction(block.vtx[index], TxStateConfirmed{block_hash, height, static_cast<int>(index)});
        transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);
    }
}

void CWallet::blockDisconnected(const CBlock& block, int height)
{
    // ...
    for (const CTransactionRef& ptx : block.vtx) {
        SyncTransaction(ptx, TxStateInactive{});
    }
}
----

Note that `CWallet::SyncTransaction(...)` adds the transaction(s) to wallet if it is relevant and then marks each input of the transaction (`const std::vector<CTxIn> CTransaction::vin`) as dirty so the balance can be recalculated correctly.

==== 3. Scanning the block chain

Another method that calls `CWallet::SyncTransaction(...)` is the `CWallet::ScanForWalletTransactions(...)`, which scans the block chain (starting in `start_block` parameter) for transactions relevant to the wallet.

This method is called when manually requesting a rescan (`rescanblockchain` RPC), when adding a new descriptor or when a new key is added to the wallet.

[source,cpp,options=nowrap]
----
CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_block, int start_height, std::optional<int> max_height, const WalletRescanReserver& reserver, bool fUpdate)
{
    // ...
    for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {
        SyncTransaction(block.vtx[posInBlock], TxStateConfirmed{block_hash, block_height, static_cast<int>(posInBlock)}, fUpdate, /*rescanning_old_block=*/true);
    }
    // ...
}
----

==== 4. `AddToWalletIfInvolvingMe(...)`

`CWallet::AddToWalletIfInvolvingMe` performs the following steps:

. If the transaction is confirmed, it checks if it conflicts with another.
If so, marks the transaction (and its in-wallet descendants) as conflicting with a particular block (`if (auto* conf = std::get_if<TxStateConfirmed>(&state))`).
. It checks if the wallet already contains the transaction.
If so, updates if requested in the `fUpdate` parameter or finishes the execution (`if (fExisted && !fUpdate) return false;`).
. It checks if the transaction interests the wallet (`if (fExisted || IsMine(tx) || IsFromMe(tx))`)
** If so, it checks if any keys in the wallet keypool that were supposed to be unused have appeared in a new transaction.
*** If so, removes those keys from the keypool (`for (auto &dest : spk_man->MarkUnusedAddresses(txout.scriptPubKey))`).
. Finally, it adds the transaction to the wallet (`AddToWallet(...)`).
This function inserts the new transaction in `CWallet::mapWallet`, updates it with relevant information such as `CWalletTx::nTimeReceived` (time it was received by the node), `CWalletTx::nOrderPos` (position in ordered transaction list) and so on.
+
This function also writes the transaction to database (`batch.WriteTx(wtx)`) and mark the transaction as dirty to recalculate balance.

._src/wallet/wallet.cpp_
[source,cpp,options=nowrap]
----
bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const SyncTxState& state, bool fUpdate, bool rescanning_old_block)
{
    const CTransaction& tx = *ptx;
    {
        AssertLockHeld(cs_wallet);

        if (auto* conf = std::get_if<TxStateConfirmed>(&state)) {
            // ...
        }

        bool fExisted = mapWallet.count(tx.GetHash()) != 0;
        if (fExisted && !fUpdate) return false;
        if (fExisted || IsMine(tx) || IsFromMe(tx))
        {
            for (const CTxOut& txout: tx.vout) {
                for (const auto& spk_man : GetScriptPubKeyMans(txout.scriptPubKey)) {
                    for (auto &dest : spk_man->MarkUnusedAddresses(txout.scriptPubKey)) {
                        // ...
                    }
                }
            }

            TxState tx_state = std::visit([](auto&& s) -> TxState { return s; }, state);
            return AddToWallet(MakeTransactionRef(tx), tx_state, /*update_wtx=*/nullptr, /*fFlushOnClose=*/false, rescanning_old_block);
        }
    }
    return false;
}

CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const TxState& state, const UpdateWalletTxFn& update_wtx, bool fFlushOnClose, bool rescanning_old_block)
{
    LOCK(cs_wallet);

    WalletBatch batch(GetDatabase(), fFlushOnClose);

    uint256 hash = tx->GetHash();

    // ...

    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(tx, state));
    CWalletTx& wtx = (*ret.first).second;
    // ...
    if (fInsertedNew) {
        wtx.nTimeReceived = GetTime();
        wtx.nOrderPos = IncOrderPosNext(&batch);
        // ...
    }

    // ...

    // Write to disk
    if (fInsertedNew || fUpdated)
        if (!batch.WriteTx(wtx))
            return nullptr;

    // Break debit/credit balance caches:
    wtx.MarkDirty();

    // ...

    return &wtx;
}
----

==== 5. `CWallet::IsMine(...)`

As the name implies, the method that actually identifies which transactions belong to the wallet is `IsMine()`.

[source,cpp,options=nowrap]
----
isminetype CWallet::IsMine(const CScript& script) const
{
    AssertLockHeld(cs_wallet);
    isminetype result = ISMINE_NO;
    for (const auto& spk_man_pair : m_spk_managers) {
        result = std::max(result, spk_man_pair.second->IsMine(script));
    }
    return result;
}
----

Note the `CWallet::IsMine(const CScript& script)` is just a proxy to the `ScriptPubKeyMan::IsMine(const CScript &script)`.
This is an important distinction, because in Bitcoin Core the class `CWallet` does not manage the keys.
This work is done by `ScriptPubKeyMan` subclasses: `DescriptorScriptPubKeyMan` and `LegacyScriptPubKeyMan`.
All `ScriptPubKeyMan` instances belonging to the wallet are stored in `CWallet::m_spk_managers`.

Another important aspect of that method is the return type, the `enum isminetype`.
This type is defined in `src/wallet/ismine.h`.

[id=ismine-enum]
[source,cpp,options=nowrap]
----
enum isminetype : unsigned int {
    ISMINE_NO         = 0,
    ISMINE_WATCH_ONLY = 1 << 0,
    ISMINE_SPENDABLE  = 1 << 1,
    ISMINE_USED       = 1 << 2,
    ISMINE_ALL        = ISMINE_WATCH_ONLY | ISMINE_SPENDABLE,
    ISMINE_ALL_USED   = ISMINE_ALL | ISMINE_USED,
    ISMINE_ENUM_ELEMENTS,
};
----

For `LegacyScriptPubKeyMan`:
* `ISMINE_NO`: the scriptPubKey is not in the wallet;
* `ISMINE_WATCH_ONLY`: the scriptPubKey has been imported into the wallet;
* `ISMINE_SPENDABLE`: the scriptPubKey corresponds to an address owned by the wallet user (who can spend with the private key);
* `ISMINE_USED`: the scriptPubKey corresponds to a used address owned by the wallet user;
* `ISMINE_ALL`: all ISMINE flags except for USED;
* `ISMINE_ALL_USED`: all ISMINE flags including USED;
* `ISMINE_ENUM_ELEMENTS`: the number of isminetype enum elements.

For `DescriptorScriptPubKeyMan` and future `ScriptPubKeyMan`:
* `ISMINE_NO`: the scriptPubKey is not in the wallet;
* `ISMINE_SPENDABLE`: the scriptPubKey matches a scriptPubKey in the wallet.
* `ISMINE_USED`: the scriptPubKey corresponds to a used address owned by the wallet user.

[NOTE]
====
`IsMine` historically was located outside of the wallet code, but now takes a more logical position as a member function of `CWallet` which returns an `isminetype` value from an enum.

More information on the `IsMine` semantics can be found in https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.21.0.md#ismine-semantics[release-notes-0.21.0.md#ismine-semantics^].
====

==== 6. `DescriptorScriptPubKeyMan::IsMine(...)`

`DescriptorScriptPubKeyMan::IsMine(...)` basically checks if `DescriptorScriptPubKeyMan::m_map_script_pub_keys` contains the `CScript scriptPubKey` passed in parameter.

[source,cpp,options=nowrap]
----
isminetype DescriptorScriptPubKeyMan::IsMine(const CScript& script) const
{
    LOCK(cs_desc_man);
    if (m_map_script_pub_keys.count(script) > 0) {
        return ISMINE_SPENDABLE;
    }
    return ISMINE_NO;
}
----

`DescriptorScriptPubKeyMan::m_map_script_pub_keys` is a `std::map<CScript, int32_t>` type (a map of scripts to the descriptor range index).

==== 7. `LegacyScriptPubKeyMan::IsMine(...)`

`LegacyScriptPubKeyMan::IsMine(...)` is only a proxy for `IsMineResult IsMineInner(...)`.

[source,cpp,options=nowrap]
----
isminetype LegacyScriptPubKeyMan::IsMine(const CScript& script) const
{
    switch (IsMineInner(*this, script, IsMineSigVersion::TOP)) {
    case IsMineResult::INVALID:
    case IsMineResult::NO:
        return ISMINE_NO;
    case IsMineResult::WATCH_ONLY:
        return ISMINE_WATCH_ONLY;
    case IsMineResult::SPENDABLE:
        return ISMINE_SPENDABLE;
    }
    assert(false);
}
----

`IsMineResult IsMineInner(...)` is only used by `LegacyScriptPubKeyMan` (which should be deprecated at some point) and is considerably more complex than its equivalent in the more modern `DescriptorScriptPubKeyMan`.

The first step is to call `Solver(scriptPubKey, vSolutions)` method, which parses a scriptPubKey and identifies the script type for standard scripts. If successful, returns the script type and parsed pubkeys or hashes, depending on the type. For example, for a P2SH script, `vSolutionsRet` will contain the script hash, for P2PKH it will contain the key hash, an so on.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(const LegacyScriptPubKeyMan& keystore, const CScript& scriptPubKey, IsMineSigVersion sigversion, bool recurse_scripthash=true)
{
    IsMineResult ret = IsMineResult::NO;

    std::vector<valtype> vSolutions;
    TxoutType whichType = Solver(scriptPubKey, vSolutions);
    // ...
}
----

The next step is to handle each script type separately. Note that if it is a Taproot transaction, it will not be considered spendable by legacy wallets. They purposely do not support Taproot as they are marked for deprecation.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    TxoutType whichType = Solver(scriptPubKey, vSolutions);

    CKeyID keyID;
    switch (whichType) {
    case TxoutType::NONSTANDARD:
    case TxoutType::NULL_DATA:
    case TxoutType::WITNESS_UNKNOWN:
    case TxoutType::WITNESS_V1_TAPROOT:
        break;
    case TxoutType::PUBKEY:
        // ...
    case TxoutType::WITNESS_V0_KEYHASH:
        // ...
    case TxoutType::PUBKEYHASH:
        // ...
    case TxoutType::SCRIPTHASH:
        // ...
    case TxoutType::WITNESS_V0_SCRIPTHASH:
        // ...
    case TxoutType::MULTISIG:
        // ...
    }
    } // no default case, so the compiler can warn about missing cases

    if (ret == IsMineResult::NO && keystore.HaveWatchOnly(scriptPubKey)) {
        ret = std::max(ret, IsMineResult::WATCH_ONLY);
    }
    return ret;
}
----

If no script type conditions are met for a `scriptPubKey`, the function checks at the end if it is a watch-only script in the wallet.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    switch (whichType) {
        // ...
        case TxoutType::PUBKEY:
        keyID = CPubKey(vSolutions[0]).GetID();
        if (!PermitsUncompressed(sigversion) && vSolutions[0].size() != 33) {
            return IsMineResult::INVALID;
        }
        if (keystore.HaveKey(keyID)) {
            ret = std::max(ret, IsMineResult::SPENDABLE);
        }
        break;
        // ...
    }
    // ...
}
----

When the script type is a public key, the function first checks if it is a `P2PK` (uncompressed public key), otherwise it must be 33 bytes (compressed format).

It then checks if the wallet keystore has the key. In this case, it means the script can be spent by the wallet.

[NOTE]
====

In the early days of Bitcoin, the transactions were of type `P2PK`, which were specified in uncompressed format.
However using this format turned out to be both wasteful for storing unspent transaction outputs (UTXOs) and a compressed format was adopted for `P2PKH` and `P2WPKH`.

Uncompressed format has:

* `04` - Marker
* x coordinate - 32 bytes, big endian
* y coordinate - 32 bytes, big endian

And the compressed has:

* `02` if y is even, `03` if odd - Marker
* x coordinate - 32 bytes, big endian

Note that the compressed format has a total of 33 bytes (x coordinate + marker).

More recently, taproot address `P2TR` was introduced and it uses a format called `x-only`, with only x coordinate - 32 bytes, big endian.
====

The next step is the SegWit format (`P2WPKH`).
First the function invalidates the script if this has a `P2WPKH` nested inside `P2WSH`.
It then checks that the script is in the expected format with the `OP_0` before the witness output.

If these two validations pass, the script will be recreated as Public Key Hash and the function will be called recursively.
Note that in this second call, the script will be handled as `TxoutType::PUBKEYHASH`.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::WITNESS_V0_KEYHASH:
    {
        if (sigversion == IsMineSigVersion::WITNESS_V0) {
            // P2WPKH inside P2WSH is invalid.
            return IsMineResult::INVALID;
        }
        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {
            // We do not support bare witness outputs unless the P2SH version of it would be
            // acceptable as well. This protects against matching before segwit activates.
            // This also applies to the P2WSH case.
            break;
        }
        ret = std::max(ret, IsMineInner(keystore, GetScriptForDestination(PKHash(uint160(vSolutions[0]))), IsMineSigVersion::WITNESS_V0));
        break;
    }
    // ...
}
----

The `TxoutType::PUBKEYHASH` logic is very similar to the `TxoutType::PUBKEY`: it checks if the wallet keystore has the key, which means the script can be spent by the wallet.

Before that, however, the function validates whether the key must be compressed.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::PUBKEYHASH:
        keyID = CKeyID(uint160(vSolutions[0]));
        if (!PermitsUncompressed(sigversion)) {
            CPubKey pubkey;
            if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {
                return IsMineResult::INVALID;
            }
        }
        if (keystore.HaveKey(keyID)) {
            ret = std::max(ret, IsMineResult::SPENDABLE);
        }
        break;
    // ...
}
----

The next item to be dealt with is `TxoutType::SCRIPTHASH`.
The logic is very similar to the one seen before.
First the script is validated (`P2SH` inside `P2WSH` or `P2SH` is invalid) and the function checks if the script exists in THE wallet keystore.
As with `TxoutType::WITNESS_V0_KEYHASH`, the function will recurse into nested p2sh and p2wsh scripts or will simply treat any script that has been stored in the keystore as spendable.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::SCRIPTHASH:
    {
        if (sigversion != IsMineSigVersion::TOP) {
            // P2SH inside P2WSH or P2SH is invalid.
            return IsMineResult::INVALID;
        }
        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));
        CScript subscript;
        if (keystore.GetCScript(scriptID, subscript)) {
            ret = std::max(ret, recurse_scripthash ? IsMineInner(keystore, subscript, IsMineSigVersion::P2SH) : IsMineResult::SPENDABLE);
        }
        break;
    }
    // ...
}
----

`TxoutType::WITNESS_V0_SCRIPTHASH` has the same logic seen in the previous item.
The only difference is that the has `Hash160` is recreated with the solved script hash, since `P2SH-P2WSH` is allowed.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::WITNESS_V0_SCRIPTHASH:
    {
        if (sigversion == IsMineSigVersion::WITNESS_V0) {
            // P2WSH inside P2WSH is invalid.
            return IsMineResult::INVALID;
        }
        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {
            break;
        }
        uint160 hash;
        CRIPEMD160().Write(vSolutions[0].data(), vSolutions[0].size()).Finalize(hash.begin());
        CScriptID scriptID = CScriptID(hash);
        CScript subscript;
        if (keystore.GetCScript(scriptID, subscript)) {
            ret = std::max(ret, recurse_scripthash ? IsMineInner(keystore, subscript, IsMineSigVersion::WITNESS_V0) : IsMineResult::SPENDABLE);
        }
        break;
    }
    // ...
}
----

The last type of script is `TxoutType ::MULTISIG`, whose logic is straightforward.
`Solver (...)` returns all the keys of the script and then they are validated in the same way as the previous scripts.
Transactions are only considered `ISMINE_SPENDABLE` if the node has all keys.

[source,cpp,options=nowrap]
----
IsMineResult IsMineInner(...)
{
    // ...
    case TxoutType::MULTISIG:
    {
        if (sigversion == IsMineSigVersion::TOP) {
            break;
        }

        std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);
        if (!PermitsUncompressed(sigversion)) {
            for (size_t i = 0; i < keys.size(); i++) {
                if (keys[i].size() != 33) {
                    return IsMineResult::INVALID;
                }
            }
        }
        if (HaveKeys(keys, keystore)) {
            ret = std::max(ret, IsMineResult::SPENDABLE);
        }
        break;
    }
    // ...
}
----

Thus, we cover most of the code responsible for identifying which transactions belong to the wallet.
The code related to `IsMine(...)` or `IsMineInner(...)` is used either when the transactions arrive through the mempool or by blocks.

== Constructing transactions

In order to construct a transaction the wallet will validate the outputs, before selecting some coins to use in the transaction.
This involves multiple steps and we can follow an outline of the process by walking through the https://github.com/bitcoin/bitcoin/blob/v23.0/src/wallet/rpc/spend.cpp#L125-L223[`sendtoaddress` RPC command^], which returns by calling `SendMoney()`.

After initialisation `SendMoney()` will call `wallet.CreateTransaction()` (`CWallet::CreateTransaction()`) followed by `wallet.CommitTransaction()` if successful.
If we follow `wallet.CreateTransaction()` we see that it is a wrapper function which calls private member function `CWallet::CreateTransactionInternal()`.

=== CreateTransactionInternal

We fetch change addresses of an "appropriate type" here, where "appropriate" means that it should try to minimise revealing that it is a change address, for example by being a different `OUTPUT_TYPE` to the other outputs.
Once a suitable change address is selected A new `ReserveDestination` object is created which keeps track of reserved addresses to prevent address re-use.

TIP: The address is not "fully" reserved until `GetReservedDestination()` is called later.

Next some basic checks on the requested transaction parameters are carried out (e.g. sanity checking of amounts and recipients) by looping through each pair of (recipient, amount).
After initializing a new transaction (`txNew`), a fee calculation (`feeCalc`) and variables for the transaction size, we enter into a new code block where the `cs_wallet` lock is acquired and the `nLockTime` for the transaction is set:

.src/wallet/wallet.cpp#CWallet::CreateTransactionInternal()
[source,cpp,options=nowrap]
----
// ...

CMutableTransaction txNew;
FeeCalculation feeCalc;
CAmount nFeeNeeded;
std::pair<int64_t, int64_t> tx_sizes;
int nBytes;
{
    std::set<CInputCoin> setCoins;
    LOCK(cs_wallet);
    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());
        {
            std::vector<COutput> vAvailableCoins;
            AvailableCoins(vAvailableCoins, true, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);

    // ...
----

Bitcoin Core chooses to set `nLockTime` to the current block to discourage https://bitcoinops.org/en/topics/fee-sniping/[fee sniping^].

// TODO: Check if I've missed any reasons for the locks.
[TIP]
====
We must acquire the lock here because we are about to attempt to select coins for spending, and optionally reserve change addresses.

If we did not have the lock it might be possible for the wallet to construct two transactions which attempted to spend the same coins, or which used the same change address.
====

=== AvailableCoins

After this, a _second_ new code block is entered where "available coins" are inserted into a vector of ``COutput``s named `vAvailableCoins`.
The concept of an "available coin" is somewhat complex, but roughly it excludes:

. "used" coins
. coins which do not have enough confirmations (N.B. confirmations required differs for own change)
. coins which are part of an immature coinbase (< 100 confirmations)
. coins which have not entered into our mempool
. coins which are already being used to (attempt) replacement of other coins

This call to `AvailableCoins()` is our first reference back to the underlying ``ScriptPubKeyMan``s controlled by the wallet.
The function iterates over all coins belonging to us -- found in the `CWallet.mapWallet` mapping -- checking coin availability before querying for a `SolvingProvider` (ultimately calling `GetSigningProvider()`): essentially querying whether the active `CWallet` has a `ScriptPubKeyMan` which can sign for the given output.

.src/wallet/wallet.cpp#CWallet::GetSolvingProvider()
[source,cpp,options=nowrap]
----
std::unique_ptr<SigningProvider> CWallet::GetSolvingProvider(const CScript& script, SignatureData& sigdata) const
{
    for (const auto& spk_man_pair : m_spk_managers) {
        if (spk_man_pair.second->CanProvide(script, sigdata)) {
            return spk_man_pair.second->GetSolvingProvider(script);
        }
    }
    return nullptr;
}
----

Below is a section of the `AvailableCoins()` function which illustrates available coins being added to the `vAvailableCoins` vector, with the call to `GetSolvingProvider()` visible.

[NOTE]
====
If a `SigningProvider` is found a second check is performed: to see if the coin is "solvable" by calling `IsSolvable()`.

Whilst `getSolvingProvider()` might return a `SigningProvider` (read: SPKM), not all SPKMs will be able to provide *private* key data needed for signing transactions, e.g. in the case of a watch-only wallet.
====

After we have determined solvablility, "spendability" is calculated for each potential output along with any coin control limitations:

.src/wallet/wallet.cpp#AvailableCoins()
[source,cpp,options=nowrap]
----
    // ...

    for (unsigned int i = 0; i < wtx.tx->vout.size(); i++) {

        // ...

        std::unique_ptr<SigningProvider> provider = GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);

        bool solvable = provider ? IsSolvable(*provider, wtx.tx->vout[i].scriptPubKey) : false;
        bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));

        vCoins.push_back(COutput(&wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));

        // Checks the sum amount of all UTXO's.
        if (nMinimumSumAmount != MAX_MONEY) {
            nTotal += wtx.tx->vout[i].nValue;

            if (nTotal >= nMinimumSumAmount) {
                return;
            }
        }

        // Checks the maximum number of UTXO's.
        if (nMaximumCount > 0 && vCoins.size() >= nMaximumCount) {
            return;
        }

        // ...
----

See the full https://github.com/bitcoin/bitcoin/blob/4b5659c6b115315c9fd2902b4edd4b960a5e066e/src/wallet/wallet.cpp#L2209-L2334[`CWallet::AvailableCoins()`^] implementation for additional details and caveats.

=== CreateTransactionInternal continued

After available coins have been determined, we check to see if the user has provided a custom change address (used coin control), or whether the earlier not-fully-reserved change address should finally be reserved and selected by calling `GetReservedDestination()`.
The change outputs' `size`, `discard_free_rate` and `effective_fee_rate` are then calculated.
The `discard_fee_rate` refers to any change output which would be dust at the `discard_rate`, and that you would be willing to discard completely and add to fee (as well as continuing to pay the fee that would have been needed for creating the change).

[id=coin-selection]
=== Coin selection

Now that we have a vector of available coins and our fee rate settings estimated, we are ready to start coin selection itself.
This is still an active area of research, with two possible coin selection solving algorithms currently implemented:

. Branch and bound ("bnb")
. Knapsack

The branch and bound algorithm is well-documented in the codebase itself:

.src/wallet/coinselection.cpp
[source,cpp,options=nowrap]
----
/*
This is the Branch and Bound Coin Selection algorithm designed by Murch. It searches for an input
set that can pay for the spending target and does not exceed the spending target by more than the
cost of creating and spending a change output. The algorithm uses a depth-first search on a binary
tree. In the binary tree, each node corresponds to the inclusion or the omission of a UTXO. UTXOs
are sorted by their effective values and the trees is explored deterministically per the inclusion
branch first. At each node, the algorithm checks whether the selection is within the target range.
While the selection has not reached the target range, more UTXOs are included. When a selection's
value exceeds the target range, the complete subtree deriving from this selection can be omitted.
At that point, the last included UTXO is deselected and the corresponding omission branch explored
instead. The search ends after the complete tree has been searched or after a limited number of tries.

The search continues to search for better solutions after one solution has been found. The best
solution is chosen by minimizing the waste metric. The waste metric is defined as the cost to
spend the current inputs at the given fee rate minus the long term expected cost to spend the
inputs, plus the amount the selection exceeds the spending target:

waste = selectionTotal - target + inputs × (currentFeeRate - longTermFeeRate)

The algorithm uses two additional optimizations. A lookahead keeps track of the total value of
the unexplored UTXOs. A subtree is not explored if the lookahead indicates that the target range
cannot be reached. Further, it is unnecessary to test equivalent combinations. This allows us
to skip testing the inclusion of UTXOs that match the effective value and waste of an omitted
predecessor.

The Branch and Bound algorithm is described in detail in Murch's Master Thesis: https://murch.one/wp-content/uploads/2016/11/erhardt2016coinselection.pdf

@param const std::vector<CInputCoin>& utxo_pool The set of UTXOs that we are choosing from.
       These UTXOs will be sorted in descending order by effective value and the CInputCoins'
       values are their effective values.
@param const CAmount& target_value This is the value that we want to select. It is the lower
       bound of the range.
@param const CAmount& cost_of_change This is the cost of creating and spending a change output.
       This plus target_value is the upper bound of the range.
@param std::set<CInputCoin>& out_set -> This is an output parameter for the set of CInputCoins
       that have been selected.
@param CAmount& value_ret -> This is an output parameter for the total value of the CInputCoins
       that were selected.
@param CAmount not_input_fees -> The fees that need to be paid for the outputs and fixed size
       overhead (version, locktime, marker and flag)
*/

----

You can read a little more about the differences between these two coin selection algorithms in this https://bitcoin.stackexchange.com/questions/32145/what-are-the-trade-offs-between-the-different-algorithms-for-deciding-which-utxo/32445#32445[StackExchange answer^].

You can read more about `waste` and the waste metric in this https://bitcoin.stackexchange.com/questions/113622/what-does-waste-metric-mean-in-the-context-of-coin-selection/113625#113625[StackExchange answer^].

Coin selection is performed as a loop, as it may take multiple iterations to select the optimal coins for a given transaction.

== Multiwallet

Work on the https://github.com/bitcoin/bitcoin/projects/2[multiwallet project^] means that Bitcoin Core can now handle dynamic loading and unloading of multiple wallets while running.

== Validation interface

TODO

== COutput

TODO

== HWI

////
== Relation to consensus soft forks

Much of the meat of the recently soft-forked changes (e.g. Taproot) reside not inside consensus code, but rather require improvements to the wallet.

== Removed text

* When adding new wallet features which will be included in the GUI, it can be good practice to first implement them as RPC commands because it's easier to create good test coverage for them.
* Advanced transaction signature operations (e.g. signature aggregation, sighash flags) happen in the wallet code.

=== Concepts

* Wallet architecture
* key management
** HD wallets
** Output script descriptors
* Separation of wallet and node functionality
* Key Management
* Transaction Construction
** Taproot
** SegWit
** Bech32
** PSBT
** Coin selection
** CPFP
** RBF
** Transaction batching
** Adaptor signatures
* Multiwallet
* Hardware wallet interface (HWI)
* QT
////
